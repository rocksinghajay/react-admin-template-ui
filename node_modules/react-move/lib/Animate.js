'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _performanceNow = require('performance-now');

var _performanceNow2 = _interopRequireDefault(_performanceNow);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _d3Interpolate = require('d3-interpolate');

var _d3Ease = require('d3-ease');

var Easing = _interopRequireWildcard(_d3Ease);

var _Utils = require('./Utils');

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


//
var msPerFrame = 1000 / 60;

var defaults = {
  data: {},
  ignore: [],
  duration: 500,
  easing: 'easeCubicOut',
  onRest: function onRest() {
    return null;
  },
  flexDuration: false,
  immutable: true
};

var Animate = function (_Component) {
  _inherits(Animate, _Component);

  function Animate(props) {
    _classCallCheck(this, Animate);

    var _this = _possibleConstructorReturn(this, (Animate.__proto__ || Object.getPrototypeOf(Animate)).call(this));

    var defaultState = props.default,
        data = props.data;

    _this.destination = data;
    _this.state = {
      current: defaultState || data
    };
    return _this;
  }

  _createClass(Animate, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.wasAnimating = false;
      this.animationID = null;
      this.lastRenderTime = 0;
      this.interpolators = {};
      this.progress = 0;
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.pivot(this.props);
      this.ranFirst = true;
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.pivot(props);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.animationID != null) {
        _raf2.default.cancel(this.animationID);
        this.animationID = null;
      }
    }
  }, {
    key: 'pivot',
    value: function pivot(props) {
      var data = props.data,
          easing = props.easing,
          ignore = props.ignore,
          immutable = props.immutable;

      // Detect non-change render

      var needsUpdate = immutable ? this.props.data !== data : !_Utils2.default.deepEquals(this.props.data, data);

      if (this.ranFirst && !needsUpdate) {
        return;
      }

      // Update the easing function
      this.easer = typeof easing === 'function' ? easing : Easing[easing] || Easing[defaults.easing];

      // Update the origins and destinations
      this.origin = this.state.current;
      this.destination = data;

      // Update the interpolators
      for (var key in this.destination) {
        if (!Object.prototype.hasOwnProperty.call(this.destination, key)) {
          continue;
        }
        if (ignore.indexOf(key) > -1) {
          this.interpolators[key] = null;
          continue;
        }
        if (this.origin[key] === this.destination[key]) {
          this.interpolators[key] = null;
          continue;
        }
        this.interpolators[key] = (0, _d3Interpolate.interpolate)(this.origin[key], this.destination[key]);
      }

      // Reset the startTime and the progress
      this.startTime = (0, _performanceNow2.default)();
      this.progress = 0;
      if (!this.wasAnimating) {
        this.lastRenderTime = (0, _performanceNow2.default)();
      }

      // Be sure to render the origin frame
      this.renderProgress();

      // Animate if needed
      this.animate();
    }
  }, {
    key: 'animate',
    value: function animate() {
      var _this2 = this;

      if (this.animationID) {
        return;
      }

      var _props = this.props,
          onRest = _props.onRest,
          duration = _props.duration,
          flexDuration = _props.flexDuration;


      this.animationID = (0, _raf2.default)(function () {
        // If the animation is complete, tie up any loose ends...
        if (_this2.progress >= 1) {
          if (_this2.wasAnimating) {
            onRest();
          }

          // no need to cancel animationID here shouldn't have any in flight
          _this2.animationID = null;
          _this2.wasAnimating = false;
          return;
        }

        // It's time to animate!
        _this2.wasAnimating = true;

        // Keep track of time
        var currentTime = (0, _performanceNow2.default)();
        var timeSinceLastFrame = currentTime - _this2.lastRenderTime;

        // Are we using flexDuration?
        if (flexDuration) {
          // Add however many milliseconds behind we are to the startTime to offset
          // any dropped frames
          _this2.startTime += Math.max(Math.floor(timeSinceLastFrame - msPerFrame), 0);
        }

        // Update the progress
        _this2.progress = Math.max(Math.min((currentTime - _this2.startTime) / duration, 1), 0);

        // Render the progress
        _this2.renderProgress();

        // Update the lastRenderTime
        _this2.lastRenderTime = currentTime;

        // Mark the frame as done
        _this2.animationID = null;

        // Try to animate again
        _this2.animate();
      });
    }
  }, {
    key: 'renderProgress',
    value: function renderProgress() {
      var _props2 = this.props,
          data = _props2.data,
          duration = _props2.duration;


      var newCurrent = {};

      // Then use the percentage and easer to interpolate to the destination
      for (var key in data) {
        if (!Object.prototype.hasOwnProperty.call(data, key)) {
          continue;
        }

        // If ignored or no change needed, skip right to the value
        if (this.interpolators[key] === null) {
          newCurrent[key] = data[key];
        } else {
          // Otherwise, interpolate with the progress
          newCurrent[key] = duration ? this.interpolators[key](this.easer(this.progress)) : this.interpolators[key](this.progress);
        }
      }

      this.setState({
        current: newCurrent
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var renderedChildren = this.props.children(this.state.current);
      return renderedChildren && _react2.default.Children.only(renderedChildren);
    }
  }]);

  return Animate;
}(_react.Component);

Animate.defaultProps = defaults;
exports.default = Animate;


Animate.defaults = defaults;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9BbmltYXRlLmpzIl0sIm5hbWVzIjpbIkVhc2luZyIsIm1zUGVyRnJhbWUiLCJkZWZhdWx0cyIsImRhdGEiLCJpZ25vcmUiLCJkdXJhdGlvbiIsImVhc2luZyIsIm9uUmVzdCIsImZsZXhEdXJhdGlvbiIsImltbXV0YWJsZSIsIkFuaW1hdGUiLCJwcm9wcyIsImRlZmF1bHRTdGF0ZSIsImRlZmF1bHQiLCJkZXN0aW5hdGlvbiIsInN0YXRlIiwiY3VycmVudCIsIndhc0FuaW1hdGluZyIsImFuaW1hdGlvbklEIiwibGFzdFJlbmRlclRpbWUiLCJpbnRlcnBvbGF0b3JzIiwicHJvZ3Jlc3MiLCJwaXZvdCIsInJhbkZpcnN0IiwiY2FuY2VsIiwibmVlZHNVcGRhdGUiLCJkZWVwRXF1YWxzIiwiZWFzZXIiLCJvcmlnaW4iLCJrZXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwic3RhcnRUaW1lIiwicmVuZGVyUHJvZ3Jlc3MiLCJhbmltYXRlIiwiY3VycmVudFRpbWUiLCJ0aW1lU2luY2VMYXN0RnJhbWUiLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJtaW4iLCJuZXdDdXJyZW50Iiwic2V0U3RhdGUiLCJyZW5kZXJlZENoaWxkcmVuIiwiY2hpbGRyZW4iLCJDaGlsZHJlbiIsIm9ubHkiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0lBQVlBLE07O0FBRVo7Ozs7Ozs7Ozs7Ozs7QUFEQTs7O0FBRUE7QUFDQSxJQUFNQyxhQUFhLE9BQU8sRUFBMUI7O0FBRUEsSUFBTUMsV0FBVztBQUNmQyxRQUFNLEVBRFM7QUFFZkMsVUFBUSxFQUZPO0FBR2ZDLFlBQVUsR0FISztBQUlmQyxVQUFRLGNBSk87QUFLZkMsVUFBUTtBQUFBLFdBQU0sSUFBTjtBQUFBLEdBTE87QUFNZkMsZ0JBQWMsS0FOQztBQU9mQyxhQUFXO0FBUEks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ImZpbGUiOiJBbmltYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IG5vdyBmcm9tICdwZXJmb3JtYW5jZS1ub3cnXG5pbXBvcnQgUkFGIGZyb20gJ3JhZidcbmltcG9ydCB7IGludGVycG9sYXRlIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnXG5pbXBvcnQgKiBhcyBFYXNpbmcgZnJvbSAnZDMtZWFzZSdcbi8vXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscydcbi8vXG5jb25zdCBtc1BlckZyYW1lID0gMTAwMCAvIDYwXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBkYXRhOiB7fSxcbiAgaWdub3JlOiBbXSxcbiAgZHVyYXRpb246IDUwMCxcbiAgZWFzaW5nOiAnZWFzZUN1YmljT3V0JyxcbiAgb25SZXN0OiAoKSA9PiBudWxsLFxuICBmbGV4RHVyYXRpb246IGZhbHNlLFxuICBpbW11dGFibGU6IHRydWUsXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgZGVmYXVsdFByb3BzID0gZGVmYXVsdHNcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIoKVxuICAgIGNvbnN0IHsgZGVmYXVsdDogZGVmYXVsdFN0YXRlLCBkYXRhIH0gPSBwcm9wc1xuICAgIHRoaXMuZGVzdGluYXRpb24gPSBkYXRhXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGN1cnJlbnQ6IGRlZmF1bHRTdGF0ZSB8fCBkYXRhLFxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxNb3VudCAoKSB7XG4gICAgdGhpcy53YXNBbmltYXRpbmcgPSBmYWxzZVxuICAgIHRoaXMuYW5pbWF0aW9uSUQgPSBudWxsXG4gICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IDBcbiAgICB0aGlzLmludGVycG9sYXRvcnMgPSB7fVxuICAgIHRoaXMucHJvZ3Jlc3MgPSAwXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5waXZvdCh0aGlzLnByb3BzKVxuICAgIHRoaXMucmFuRmlyc3QgPSB0cnVlXG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChwcm9wcykge1xuICAgIHRoaXMucGl2b3QocHJvcHMpXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uSUQgIT0gbnVsbCkge1xuICAgICAgUkFGLmNhbmNlbCh0aGlzLmFuaW1hdGlvbklEKVxuICAgICAgdGhpcy5hbmltYXRpb25JRCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBwaXZvdCAocHJvcHMpIHtcbiAgICBjb25zdCB7IGRhdGEsIGVhc2luZywgaWdub3JlLCBpbW11dGFibGUgfSA9IHByb3BzXG5cbiAgICAvLyBEZXRlY3Qgbm9uLWNoYW5nZSByZW5kZXJcbiAgICBsZXQgbmVlZHNVcGRhdGUgPSBpbW11dGFibGVcbiAgICAgID8gdGhpcy5wcm9wcy5kYXRhICE9PSBkYXRhXG4gICAgICA6ICFVdGlscy5kZWVwRXF1YWxzKHRoaXMucHJvcHMuZGF0YSwgZGF0YSlcblxuICAgIGlmICh0aGlzLnJhbkZpcnN0ICYmICFuZWVkc1VwZGF0ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBlYXNpbmcgZnVuY3Rpb25cbiAgICB0aGlzLmVhc2VyID1cbiAgICAgIHR5cGVvZiBlYXNpbmcgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBlYXNpbmdcbiAgICAgICAgOiBFYXNpbmdbZWFzaW5nXSB8fCBFYXNpbmdbZGVmYXVsdHMuZWFzaW5nXVxuXG4gICAgLy8gVXBkYXRlIHRoZSBvcmlnaW5zIGFuZCBkZXN0aW5hdGlvbnNcbiAgICB0aGlzLm9yaWdpbiA9IHRoaXMuc3RhdGUuY3VycmVudFxuICAgIHRoaXMuZGVzdGluYXRpb24gPSBkYXRhXG5cbiAgICAvLyBVcGRhdGUgdGhlIGludGVycG9sYXRvcnNcbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5kZXN0aW5hdGlvbikge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5kZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGlnbm9yZS5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICB0aGlzLmludGVycG9sYXRvcnNba2V5XSA9IG51bGxcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9yaWdpbltrZXldID09PSB0aGlzLmRlc3RpbmF0aW9uW2tleV0pIHtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0b3JzW2tleV0gPSBudWxsXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICB0aGlzLmludGVycG9sYXRvcnNba2V5XSA9IGludGVycG9sYXRlKFxuICAgICAgICB0aGlzLm9yaWdpbltrZXldLFxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uW2tleV1cbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBSZXNldCB0aGUgc3RhcnRUaW1lIGFuZCB0aGUgcHJvZ3Jlc3NcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG5vdygpXG4gICAgdGhpcy5wcm9ncmVzcyA9IDBcbiAgICBpZiAoIXRoaXMud2FzQW5pbWF0aW5nKSB7XG4gICAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gbm93KClcbiAgICB9XG5cbiAgICAvLyBCZSBzdXJlIHRvIHJlbmRlciB0aGUgb3JpZ2luIGZyYW1lXG4gICAgdGhpcy5yZW5kZXJQcm9ncmVzcygpXG5cbiAgICAvLyBBbmltYXRlIGlmIG5lZWRlZFxuICAgIHRoaXMuYW5pbWF0ZSgpXG4gIH1cblxuICBhbmltYXRlICgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JRCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBvblJlc3QsIGR1cmF0aW9uLCBmbGV4RHVyYXRpb24gfSA9IHRoaXMucHJvcHNcblxuICAgIHRoaXMuYW5pbWF0aW9uSUQgPSBSQUYoKCkgPT4ge1xuICAgICAgLy8gSWYgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgdGllIHVwIGFueSBsb29zZSBlbmRzLi4uXG4gICAgICBpZiAodGhpcy5wcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgIGlmICh0aGlzLndhc0FuaW1hdGluZykge1xuICAgICAgICAgIG9uUmVzdCgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBuZWVkIHRvIGNhbmNlbCBhbmltYXRpb25JRCBoZXJlIHNob3VsZG4ndCBoYXZlIGFueSBpbiBmbGlnaHRcbiAgICAgICAgdGhpcy5hbmltYXRpb25JRCA9IG51bGxcbiAgICAgICAgdGhpcy53YXNBbmltYXRpbmcgPSBmYWxzZVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gSXQncyB0aW1lIHRvIGFuaW1hdGUhXG4gICAgICB0aGlzLndhc0FuaW1hdGluZyA9IHRydWVcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aW1lXG4gICAgICBsZXQgY3VycmVudFRpbWUgPSBub3coKVxuICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEZyYW1lID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RSZW5kZXJUaW1lXG5cbiAgICAgIC8vIEFyZSB3ZSB1c2luZyBmbGV4RHVyYXRpb24/XG4gICAgICBpZiAoZmxleER1cmF0aW9uKSB7XG4gICAgICAgIC8vIEFkZCBob3dldmVyIG1hbnkgbWlsbGlzZWNvbmRzIGJlaGluZCB3ZSBhcmUgdG8gdGhlIHN0YXJ0VGltZSB0byBvZmZzZXRcbiAgICAgICAgLy8gYW55IGRyb3BwZWQgZnJhbWVzXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lICs9IE1hdGgubWF4KFxuICAgICAgICAgIE1hdGguZmxvb3IodGltZVNpbmNlTGFzdEZyYW1lIC0gbXNQZXJGcmFtZSksXG4gICAgICAgICAgMFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3NcbiAgICAgIHRoaXMucHJvZ3Jlc3MgPSBNYXRoLm1heChcbiAgICAgICAgTWF0aC5taW4oKGN1cnJlbnRUaW1lIC0gdGhpcy5zdGFydFRpbWUpIC8gZHVyYXRpb24sIDEpLFxuICAgICAgICAwXG4gICAgICApXG5cbiAgICAgIC8vIFJlbmRlciB0aGUgcHJvZ3Jlc3NcbiAgICAgIHRoaXMucmVuZGVyUHJvZ3Jlc3MoKVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIGxhc3RSZW5kZXJUaW1lXG4gICAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gY3VycmVudFRpbWVcblxuICAgICAgLy8gTWFyayB0aGUgZnJhbWUgYXMgZG9uZVxuICAgICAgdGhpcy5hbmltYXRpb25JRCA9IG51bGxcblxuICAgICAgLy8gVHJ5IHRvIGFuaW1hdGUgYWdhaW5cbiAgICAgIHRoaXMuYW5pbWF0ZSgpXG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlclByb2dyZXNzICgpIHtcbiAgICBjb25zdCB7IGRhdGEsIGR1cmF0aW9uIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCBuZXdDdXJyZW50ID0ge31cblxuICAgIC8vIFRoZW4gdXNlIHRoZSBwZXJjZW50YWdlIGFuZCBlYXNlciB0byBpbnRlcnBvbGF0ZSB0byB0aGUgZGVzdGluYXRpb25cbiAgICBmb3IgKGxldCBrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpZ25vcmVkIG9yIG5vIGNoYW5nZSBuZWVkZWQsIHNraXAgcmlnaHQgdG8gdGhlIHZhbHVlXG4gICAgICBpZiAodGhpcy5pbnRlcnBvbGF0b3JzW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgbmV3Q3VycmVudFtrZXldID0gZGF0YVtrZXldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGludGVycG9sYXRlIHdpdGggdGhlIHByb2dyZXNzXG4gICAgICAgIG5ld0N1cnJlbnRba2V5XSA9IGR1cmF0aW9uXG4gICAgICAgICAgPyB0aGlzLmludGVycG9sYXRvcnNba2V5XSh0aGlzLmVhc2VyKHRoaXMucHJvZ3Jlc3MpKVxuICAgICAgICAgIDogdGhpcy5pbnRlcnBvbGF0b3JzW2tleV0odGhpcy5wcm9ncmVzcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnQ6IG5ld0N1cnJlbnQsXG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zdGF0ZS5jdXJyZW50KVxuICAgIHJldHVybiByZW5kZXJlZENoaWxkcmVuICYmIFJlYWN0LkNoaWxkcmVuLm9ubHkocmVuZGVyZWRDaGlsZHJlbilcbiAgfVxufVxuXG5BbmltYXRlLmRlZmF1bHRzID0gZGVmYXVsdHNcbiJdfQ==