'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _performanceNow = require('performance-now');

var _performanceNow2 = _interopRequireDefault(_performanceNow);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _d3Interpolate = require('d3-interpolate');

var _d3Ease = require('d3-ease');

var Easing = _interopRequireWildcard(_d3Ease);

var _Utils = require('./Utils');

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


var msPerFrame = 1000 / 60;

var defaults = {
  data: [],
  ignore: [],
  duration: 500,
  easing: 'easeCubicOut',
  enter: function enter() {
    return null;
  },
  leave: function leave() {
    return null;
  },
  onRest: function onRest() {
    return null;
  },
  stagger: null,
  flexDuration: false,
  immutable: true,
  staggerGroups: true
};

// Used to make all the interpolators from origin to destination states
var makeInterpolators = function makeInterpolators(originState, destState, ignore) {
  // Make sure we interpolate new and old keys
  var allKeys = dedupe(Object.keys(originState), Object.keys(destState));
  var interpolators = {};
  allKeys.forEach(function (key) {
    if (ignore.indexOf(key) > -1) {
      interpolators[key] = null;
      return;
    }
    if (originState[key] === destState[key]) {
      interpolators[key] = null;
      return;
    }
    interpolators[key] = (0, _d3Interpolate.interpolate)(originState[key], destState[key]);
  });
  return interpolators;
};

var Transition = function (_Component) {
  _inherits(Transition, _Component);

  function Transition() {
    _classCallCheck(this, Transition);

    var _this = _possibleConstructorReturn(this, (Transition.__proto__ || Object.getPrototypeOf(Transition)).call(this));

    _this.items = [];
    _this.state = {
      items: []
    };
    return _this;
  }

  _createClass(Transition, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.unmounting = false;
      this.animationID = null;
      this.lastRenderTime = 0;
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.pivot(this.props);
      this.ranFirst = true;
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      this.pivot(props);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unmounting = true;
      if (this.animationID != null) {
        _raf2.default.cancel(this.animationID);
        this.animationID = null;
      }
    }
  }, {
    key: 'pivot',
    value: function pivot(props) {
      var _this2 = this;

      var getKey = props.getKey,
          data = props.data,
          easing = props.easing,
          duration = props.duration,
          getDuration = props.getDuration,
          getEasing = props.getEasing,
          enter = props.enter,
          update = props.update,
          leave = props.leave,
          immutable = props.immutable,
          stagger = props.stagger,
          staggerGroups = props.staggerGroups;

      // Detect if we need to animate

      var noChanges = immutable ? this.props.data === data : _Utils2.default.deepEquals(this.props.data, data);

      // If this is the first time, animate regardless
      if (this.ranFirst && noChanges) {
        return;
      }

      // Get the current items from the state (which is the visual
      // representation of our items)
      var currentItems = this.items;

      // Get the new items with their keys and data
      var newItems = data.map(function (d, i) {
        return {
          key: getKey(d, i),
          data: d,
          next: {}
        };
      });

      // Detect instant rendering
      if (!duration) {
        this.items = newItems;
        this.items.forEach(function (item) {
          item.progress = 1;
          item.originState = update(item.data, item.key);
          item.destState = _extends({}, item.originState);
        });
        this.renderProgress();
        return;
      }

      // Find items that are entering
      var enteringItems = newItems.filter(function (newItem) {
        return !currentItems.find(function (currentItem) {
          return currentItem.key === newItem.key;
        });
      });

      enteringItems.forEach(function (item, i) {
        item.willEnter = true;
      });

      // Find items that should leave
      var leavingItems = currentItems.filter(function (currentItem) {
        return !newItems.find(function (newItem) {
          return newItem.key === currentItem.key;
        });
      });

      leavingItems.forEach(function (item, i) {
        item.willLeave = true;
      });

      // Find items that are staying
      var stayingItems = currentItems.filter(function (currentItem) {
        return newItems.find(function (newItem) {
          return newItem.key === currentItem.key;
        });
      });

      stayingItems.forEach(function (item) {
        // If the item was leaving, and is now staying, update it
        if (item.leaving) {
          item.willUpdate = true;
        }
        // If the item's update function returns something new, update it
        var newDestState = update(item.data, item.key);
        if (!_Utils2.default.deepEquals(item.destState, newDestState)) {
          item.willUpdate = true;
        }
        item.willLeave = false;
        item.willEnter = false;
      });

      // Merge all of the items together and
      // give each item it's new origin/destination states
      // with corresponding interpolators
      this.items = mergeItems(currentItems, enteringItems);

      this.items.forEach(function (item, i) {
        // Queue an update either immediately or using a staggerOffset
        var staggerOffset = 0;
        // For staggering time based animations, we just need the index
        var staggerIndex = i + 1;
        // But if we are staggering by group, we will instead need the index of the
        // item relative to its predecessors who share the same entering/leaving group
        if (stagger && staggerGroups) {
          staggerIndex = 0;
          for (var ii = 0; ii < i; ii++) {
            var staggerItem = _this2.items[ii];
            if (staggerItem.willEnter === item.willEnter && staggerItem.willLeave === item.willLeave) {
              staggerIndex++;
            }
          }
        }

        if (stagger) {
          // If its staggered, we need base the progress off of
          // the staggered time, instead of the currentTime
          staggerOffset = stagger * staggerIndex;
        }

        // For every item that needs to be reset, set a new startTime
        if (item.willEnter || item.willLeave || item.willUpdate) {
          item.nextUpdate = staggerOffset ? (0, _performanceNow2.default)() + staggerOffset : true;
          item.duration = typeof getDuration === 'function' ? getDuration(item.data, item.key) : duration;
          item.easing = typeof getEasing === 'function' ? getEasing(item.data, item.key) : easing;

          // Update the easing function
          item.easer = typeof item.easing === 'function' ? item.easing : Easing[item.easing] || Easing[defaults.easing];
        }

        // Compile the possible states for each item
        item.next.update = update(item.data, item.key);
        item.next.enter = enter(item.data, item.key);
        item.next.leave = leave(item.data, item.key);

        // Since the underlying data could have changed for the currentItems
        // update them all
        var newItem = newItems.find(function (d) {
          return d.key === item.key;
        });
        item.data = newItem ? newItem.data : item.data;
      });

      // Be sure to render the origin frame
      this.renderProgress();

      // Animate if needed
      this.animate();
    }
  }, {
    key: 'animate',
    value: function animate() {
      var _this3 = this;

      // If we're unmounting, bail out.
      if (this.unmounting) {
        return;
      }

      // If we're already animated, bail out.
      if (this.animationID) {
        return;
      }

      var _props = this.props,
          flexDuration = _props.flexDuration,
          ignore = _props.ignore;


      this.animationID = (0, _raf2.default)(function () {
        // Double check that we are still mounted, since RAF can perform
        // asyncronously sometimes
        if (_this3.unmounting) {
          return;
        }

        // Keep track of time
        var currentTime = (0, _performanceNow2.default)();

        // this.items = this.items.filter(
        //   item => !(item.leaving && item.progress === 1)
        // )

        var needsAnimation = _this3.items.some(function (item) {
          return item.nextUpdate || item.progress < 1;
        });

        // If the animation is complete, tie up any loose ends...
        if (!needsAnimation) {
          _this3.animationID = null;
          _this3.wasAnimating = false;
          return;
        }

        // It's time to animate!
        _this3.wasAnimating = true;

        // If we using flexDuration, add however many milliseconds behind we are to the flexAmount to offset
        // any dropped frames
        var timeSinceLastFrame = currentTime - _this3.lastRenderTime;
        currentTime += flexDuration ? Math.max(Math.floor(timeSinceLastFrame - msPerFrame), 0) : 0;

        _this3.items.forEach(function (item, i) {
          // If the item is ready to be updated, do it now
          if (item.nextUpdate === true || item.nextUpdate && item.nextUpdate <= currentTime) {
            item.entering = false;
            item.leaving = false;
            item.updating = false;
            // Update leaving, entering, and changed items with their new origins,
            // destinations and interpolators
            if (item.willEnter) {
              item.willEnter = false;
              item.entering = true;
              item.originState = item.next.enter || item.next.update;
              item.destState = item.next.update;
              item.interpolators = makeInterpolators(item.originState, item.destState, ignore);
            } else if (item.willLeave) {
              item.willLeave = false;
              item.leaving = true;
              item.originState = item.state || item.next.update;
              item.destState = item.next.leave || item.next.update;
              item.interpolators = makeInterpolators(item.originState, item.destState, ignore);
            } else if (item.willUpdate) {
              item.willUpdate = false;
              item.updating = true;
              item.originState = item.state || item.next.update;
              item.destState = item.next.update;
              item.interpolators = makeInterpolators(item.originState, item.destState, ignore);
            }

            // For every item that needs to be reset, set a new startTime and durtaion
            item.startTime = (0, _performanceNow2.default)();
            item.nextUpdate = false;
          }

          // Set the progress
          var progress = item.startTime ? (currentTime - item.startTime) / item.duration : 0;

          // Make sure progress is between 0 and 1
          progress = Math.max(Math.min(progress, 1), 0);

          item.progress = progress;
        });

        // Render with the progress
        _this3.renderProgress();

        // Update the lastRenderTime
        _this3.lastRenderTime = currentTime;

        // Mark the frame as done
        _this3.animationID = null;

        _this3.animate();
      });
    }
  }, {
    key: 'renderProgress',
    value: function renderProgress() {
      var onRest = this.props.onRest;
      // Don't interpolate items that haven't entered yet

      var items = this.items.filter(function (item) {
        return !item.willEnter && item.originState && item.destState;
      });

      items.forEach(function (item) {
        item.state = {};
        var allKeys = dedupe(Object.keys(item.originState || {}), Object.keys(item.destState || {}));

        allKeys.forEach(function (key) {
          if (!item.progress) {
            // If at absolute 0, draw the origin state
            item.state[key] = item.originState[key];
          } else if (item.progress === 1 || !item.interpolators[key]) {
            // If ignored, skip right to the value
            item.state[key] = item.destState[key];
          } else {
            // Otherwise, interpolate with the progress
            item.state[key] = item.interpolators[key](item.easer(item.progress));
          }
        });
        if (item.progress === 1) {
          onRest(item.data, item.key);
        }
      });

      // Don't render items that haven't entered yet or have exited
      items = items.filter(function (item) {
        return !(item.willEnter || item.leaving && item.progress === 1);
      });

      // Remove items that have exited
      this.items = this.items.filter(function (item) {
        return !(item.leaving && item.progress === 1);
      });

      this.setState({ items: items });
    }
  }, {
    key: 'render',
    value: function render() {
      var renderedChildren = this.props.children(this.state.items);
      return renderedChildren && _react2.default.Children.only(renderedChildren);
    }
  }]);

  return Transition;
}(_react.Component);

// Taken from react-motion's mergeDiff (https://github.com/chenglou/react-motion/blob/446a8d0130072c4a59fec1ab788bfc2cc5c5b788/src/mergeDiff.js)


Transition.defaultProps = defaults;
exports.default = Transition;
function mergeItems(prev, next) {
  var prevKeyIndex = {};
  for (var i = 0; i < prev.length; i++) {
    prevKeyIndex[prev[i].key] = i;
  }
  var nextKeyIndex = {};
  for (var _i = 0; _i < next.length; _i++) {
    nextKeyIndex[next[_i].key] = _i;
  }
  // Merge the arrays
  var allItems = [];
  for (var _i2 = 0; _i2 < next.length; _i2++) {
    allItems[_i2] = next[_i2];
  }
  for (var _i3 = 0; _i3 < prev.length; _i3++) {
    if (!Object.prototype.hasOwnProperty.call(nextKeyIndex, prev[_i3].key)) {
      allItems.push(prev[_i3]);
    }
  }
  // now all the items all present. Core sorting logic to have the right order
  return allItems.sort(function (a, b) {
    var nextOrderA = nextKeyIndex[a.key];
    var nextOrderB = nextKeyIndex[b.key];
    var prevOrderA = prevKeyIndex[a.key];
    var prevOrderB = prevKeyIndex[b.key];
    if (nextOrderA != null && nextOrderB != null) {
      // both keys in next
      return nextKeyIndex[a.key] - nextKeyIndex[b.key];
    } else if (prevOrderA != null && prevOrderB != null) {
      // both keys in prev
      return prevKeyIndex[a.key] - prevKeyIndex[b.key];
    } else if (nextOrderA != null) {
      // key a in next, key b in prev
      // how to determine the order between a and b? We find a "pivot" (term
      // abuse), a key present in both prev and next, that is sandwiched between
      // a and b. In the context of our above example, if we're comparing a and
      // d, b's (the only) pivot
      for (var _i4 = 0; _i4 < next.length; _i4++) {
        var pivot = next[_i4].key;
        if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {
          continue;
        }
        if (nextOrderA < nextKeyIndex[pivot] && prevOrderB > prevKeyIndex[pivot]) {
          return -1;
        } else if (nextOrderA > nextKeyIndex[pivot] && prevOrderB < prevKeyIndex[pivot]) {
          return 1;
        }
      }
      // pluggable. default to: next bigger than prev
      return 1;
    }
    // prevOrderA, nextOrderB
    for (var _i5 = 0; _i5 < next.length; _i5++) {
      var _pivot = next[_i5].key;
      if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, _pivot)) {
        continue;
      }
      if (nextOrderB < nextKeyIndex[_pivot] && prevOrderA > prevKeyIndex[_pivot]) {
        return 1;
      } else if (nextOrderB > nextKeyIndex[_pivot] && prevOrderA < prevKeyIndex[_pivot]) {
        return -1;
      }
    }
    // pluggable. default to: next bigger than prev
    return -1;
  });
}

Transition.defaults = defaults;

function dedupe() {
  for (var _len = arguments.length, arrs = Array(_len), _key = 0; _key < _len; _key++) {
    arrs[_key] = arguments[_key];
  }

  var allItems = arrs.reduce(function (a, b) {
    return a.concat(b);
  }, []);
  for (var i = 0; i < allItems.length; ++i) {
    for (var j = i + 1; j < allItems.length; ++j) {
      if (allItems[i] === allItems[j]) {
        allItems.splice(j--, 1);
      }
    }
  }
  return allItems;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9UcmFuc2l0aW9uLmpzIl0sIm5hbWVzIjpbIkVhc2luZyIsIm1zUGVyRnJhbWUiLCJkZWZhdWx0cyIsImRhdGEiLCJpZ25vcmUiLCJkdXJhdGlvbiIsImVhc2luZyIsImVudGVyIiwibGVhdmUiLCJvblJlc3QiLCJzdGFnZ2VyIiwiZmxleER1cmF0aW9uIiwiaW1tdXRhYmxlIiwic3RhZ2dlckdyb3VwcyIsIm1ha2VJbnRlcnBvbGF0b3JzIiwib3JpZ2luU3RhdGUiLCJkZXN0U3RhdGUiLCJhbGxLZXlzIiwiZGVkdXBlIiwiT2JqZWN0Iiwia2V5cyIsImludGVycG9sYXRvcnMiLCJmb3JFYWNoIiwiaW5kZXhPZiIsImtleSIsIlRyYW5zaXRpb24iLCJpdGVtcyIsInN0YXRlIiwidW5tb3VudGluZyIsImFuaW1hdGlvbklEIiwibGFzdFJlbmRlclRpbWUiLCJwaXZvdCIsInByb3BzIiwicmFuRmlyc3QiLCJjYW5jZWwiLCJnZXRLZXkiLCJnZXREdXJhdGlvbiIsImdldEVhc2luZyIsInVwZGF0ZSIsIm5vQ2hhbmdlcyIsImRlZXBFcXVhbHMiLCJjdXJyZW50SXRlbXMiLCJuZXdJdGVtcyIsIm1hcCIsImQiLCJpIiwibmV4dCIsIml0ZW0iLCJwcm9ncmVzcyIsInJlbmRlclByb2dyZXNzIiwiZW50ZXJpbmdJdGVtcyIsImZpbHRlciIsImZpbmQiLCJjdXJyZW50SXRlbSIsIm5ld0l0ZW0iLCJ3aWxsRW50ZXIiLCJsZWF2aW5nSXRlbXMiLCJ3aWxsTGVhdmUiLCJzdGF5aW5nSXRlbXMiLCJsZWF2aW5nIiwid2lsbFVwZGF0ZSIsIm5ld0Rlc3RTdGF0ZSIsIm1lcmdlSXRlbXMiLCJzdGFnZ2VyT2Zmc2V0Iiwic3RhZ2dlckluZGV4IiwiaWkiLCJzdGFnZ2VySXRlbSIsIm5leHRVcGRhdGUiLCJlYXNlciIsImFuaW1hdGUiLCJjdXJyZW50VGltZSIsIm5lZWRzQW5pbWF0aW9uIiwic29tZSIsIndhc0FuaW1hdGluZyIsInRpbWVTaW5jZUxhc3RGcmFtZSIsIk1hdGgiLCJtYXgiLCJmbG9vciIsImVudGVyaW5nIiwidXBkYXRpbmciLCJzdGFydFRpbWUiLCJtaW4iLCJzZXRTdGF0ZSIsInJlbmRlcmVkQ2hpbGRyZW4iLCJjaGlsZHJlbiIsIkNoaWxkcmVuIiwib25seSIsImRlZmF1bHRQcm9wcyIsInByZXYiLCJwcmV2S2V5SW5kZXgiLCJsZW5ndGgiLCJuZXh0S2V5SW5kZXgiLCJhbGxJdGVtcyIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJuZXh0T3JkZXJBIiwibmV4dE9yZGVyQiIsInByZXZPcmRlckEiLCJwcmV2T3JkZXJCIiwiYXJycyIsInJlZHVjZSIsImNvbmNhdCIsImoiLCJzcGxpY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7SUFBWUEsTTs7QUFFWjs7Ozs7Ozs7Ozs7OztBQURBOzs7QUFHQSxJQUFNQyxhQUFhLE9BQU8sRUFBMUI7O0FBRUEsSUFBTUMsV0FBVztBQUNmQyxRQUFNLEVBRFM7QUFFZkMsVUFBUSxFQUZPO0FBR2ZDLFlBQVUsR0FISztBQUlmQyxVQUFRLGNBSk87QUFLZkMsU0FBTztBQUFBLFdBQU0sSUFBTjtBQUFBLEdBTFE7QUFNZkMsU0FBTztBQUFBLFdBQU0sSUFBTjtBQUFBLEdBTlE7QUFPZkMsVUFBUTtBQUFBLFdBQU0sSUFBTjtBQUFBLEdBUE87QUFRZkMsV0FBUyxJQVJNO0FBU2ZDLGdCQUFjLEtBVEM7QUFVZkMsYUFBVyxJQVZJO0FBV2ZDLGlCQUFlO0FBWEEsQ0FBakI7O0FBY0E7QUFDQSxJQUFNQyxvQkFBb0IsU0FBcEJBLGlCQUFvQixDQUFDQyxXQUFELEVBQWNDLFNBQWQsRUFBeUJaLE1BQXpCLEVBQW9DO0FBQzVEO0FBQ0EsTUFBTWEsVUFBVUMsT0FBT0MsT0FBT0MsSUFBUCxDQUFZTCxXQUFaLENBQVAsRUFBaUNJLE9BQU9DLElBQVAsQ0FBWUosU0FBWixDQUFqQyxDQUFoQjtB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QUl0RCxJQUFJLENBQWIsRUFBZ0JBLElBQUkrQyxTQUFTRixNQUE3QixFQUFxQyxFQUFFN0MsQ0FBdkMsRUFBMEM7QUFDeEMsU0FBSyxJQUFJOEQsSUFBSTlELElBQUksQ0FBakIsRUFBb0I4RCxJQUFJZixTQUFTRixNQUFqQyxFQUF5QyxFQUFFaUIsQ0FBM0MsRUFBOEM7QUFDNUMsVUFBSWYsU0FBUy9DLENBQVQsTUFBZ0IrQyxTQUFTZSxDQUFULENBQXBCLEVBQWlDO0FBQy9CZixpQkFBU2dCLE1BQVQsQ0FBZ0JELEdBQWhCLEVBQXFCLENBQXJCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBT2YsUUFBUDtBQUNEIiwiZmlsZSI6IlRyYW5zaXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgbm93IGZyb20gJ3BlcmZvcm1hbmNlLW5vdydcbmltcG9ydCBSQUYgZnJvbSAncmFmJ1xuaW1wb3J0IHsgaW50ZXJwb2xhdGUgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSdcbmltcG9ydCAqIGFzIEVhc2luZyBmcm9tICdkMy1lYXNlJ1xuLy9cbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJ1xuXG5jb25zdCBtc1BlckZyYW1lID0gMTAwMCAvIDYwXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBkYXRhOiBbXSxcbiAgaWdub3JlOiBbXSxcbiAgZHVyYXRpb246IDUwMCxcbiAgZWFzaW5nOiAnZWFzZUN1YmljT3V0JyxcbiAgZW50ZXI6ICgpID0+IG51bGwsXG4gIGxlYXZlOiAoKSA9PiBudWxsLFxuICBvblJlc3Q6ICgpID0+IG51bGwsXG4gIHN0YWdnZXI6IG51bGwsXG4gIGZsZXhEdXJhdGlvbjogZmFsc2UsXG4gIGltbXV0YWJsZTogdHJ1ZSxcbiAgc3RhZ2dlckdyb3VwczogdHJ1ZSxcbn1cblxuLy8gVXNlZCB0byBtYWtlIGFsbCB0aGUgaW50ZXJwb2xhdG9ycyBmcm9tIG9yaWdpbiB0byBkZXN0aW5hdGlvbiBzdGF0ZXNcbmNvbnN0IG1ha2VJbnRlcnBvbGF0b3JzID0gKG9yaWdpblN0YXRlLCBkZXN0U3RhdGUsIGlnbm9yZSkgPT4ge1xuICAvLyBNYWtlIHN1cmUgd2UgaW50ZXJwb2xhdGUgbmV3IGFuZCBvbGQga2V5c1xuICBjb25zdCBhbGxLZXlzID0gZGVkdXBlKE9iamVjdC5rZXlzKG9yaWdpblN0YXRlKSwgT2JqZWN0LmtleXMoZGVzdFN0YXRlKSlcbiAgY29uc3QgaW50ZXJwb2xhdG9ycyA9IHt9XG4gIGFsbEtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChpZ25vcmUuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgIGludGVycG9sYXRvcnNba2V5XSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAob3JpZ2luU3RhdGVba2V5XSA9PT0gZGVzdFN0YXRlW2tleV0pIHtcbiAgICAgIGludGVycG9sYXRvcnNba2V5XSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpbnRlcnBvbGF0b3JzW2tleV0gPSBpbnRlcnBvbGF0ZShvcmlnaW5TdGF0ZVtrZXldLCBkZXN0U3RhdGVba2V5XSlcbiAgfSlcbiAgcmV0dXJuIGludGVycG9sYXRvcnNcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNpdGlvbiBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0c1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5pdGVtcyA9IFtdXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGl0ZW1zOiBbXSxcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsTW91bnQgKCkge1xuICAgIHRoaXMudW5tb3VudGluZyA9IGZhbHNlXG4gICAgdGhpcy5hbmltYXRpb25JRCA9IG51bGxcbiAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gMFxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgIHRoaXMucGl2b3QodGhpcy5wcm9wcylcbiAgICB0aGlzLnJhbkZpcnN0ID0gdHJ1ZVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAocHJvcHMpIHtcbiAgICB0aGlzLnBpdm90KHByb3BzKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHRoaXMudW5tb3VudGluZyA9IHRydWVcbiAgICBpZiAodGhpcy5hbmltYXRpb25JRCAhPSBudWxsKSB7XG4gICAgICBSQUYuY2FuY2VsKHRoaXMuYW5pbWF0aW9uSUQpXG4gICAgICB0aGlzLmFuaW1hdGlvbklEID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHBpdm90IChwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGdldEtleSxcbiAgICAgIGRhdGEsXG4gICAgICBlYXNpbmcsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGdldER1cmF0aW9uLFxuICAgICAgZ2V0RWFzaW5nLFxuICAgICAgZW50ZXIsXG4gICAgICB1cGRhdGUsXG4gICAgICBsZWF2ZSxcbiAgICAgIGltbXV0YWJsZSxcbiAgICAgIHN0YWdnZXIsXG4gICAgICBzdGFnZ2VyR3JvdXBzLFxuICAgIH0gPSBwcm9wc1xuXG4gICAgLy8gRGV0ZWN0IGlmIHdlIG5lZWQgdG8gYW5pbWF0ZVxuICAgIGxldCBub0NoYW5nZXMgPSBpbW11dGFibGVcbiAgICAgID8gdGhpcy5wcm9wcy5kYXRhID09PSBkYXRhXG4gICAgICA6IFV0aWxzLmRlZXBFcXVhbHModGhpcy5wcm9wcy5kYXRhLCBkYXRhKVxuXG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSwgYW5pbWF0ZSByZWdhcmRsZXNzXG4gICAgaWYgKHRoaXMucmFuRmlyc3QgJiYgbm9DaGFuZ2VzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgaXRlbXMgZnJvbSB0aGUgc3RhdGUgKHdoaWNoIGlzIHRoZSB2aXN1YWxcbiAgICAvLyByZXByZXNlbnRhdGlvbiBvZiBvdXIgaXRlbXMpXG4gICAgY29uc3QgY3VycmVudEl0ZW1zID0gdGhpcy5pdGVtc1xuXG4gICAgLy8gR2V0IHRoZSBuZXcgaXRlbXMgd2l0aCB0aGVpciBrZXlzIGFuZCBkYXRhXG4gICAgbGV0IG5ld0l0ZW1zID0gZGF0YS5tYXAoKGQsIGkpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleTogZ2V0S2V5KGQsIGkpLFxuICAgICAgICBkYXRhOiBkLFxuICAgICAgICBuZXh0OiB7fSxcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gRGV0ZWN0IGluc3RhbnQgcmVuZGVyaW5nXG4gICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgdGhpcy5pdGVtcyA9IG5ld0l0ZW1zXG4gICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGl0ZW0ucHJvZ3Jlc3MgPSAxXG4gICAgICAgIGl0ZW0ub3JpZ2luU3RhdGUgPSB1cGRhdGUoaXRlbS5kYXRhLCBpdGVtLmtleSlcbiAgICAgICAgaXRlbS5kZXN0U3RhdGUgPSB7IC4uLml0ZW0ub3JpZ2luU3RhdGUgfVxuICAgICAgfSlcbiAgICAgIHRoaXMucmVuZGVyUHJvZ3Jlc3MoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRmluZCBpdGVtcyB0aGF0IGFyZSBlbnRlcmluZ1xuICAgIGNvbnN0IGVudGVyaW5nSXRlbXMgPSBuZXdJdGVtcy5maWx0ZXIoXG4gICAgICBuZXdJdGVtID0+XG4gICAgICAgICFjdXJyZW50SXRlbXMuZmluZChjdXJyZW50SXRlbSA9PiBjdXJyZW50SXRlbS5rZXkgPT09IG5ld0l0ZW0ua2V5KVxuICAgIClcblxuICAgIGVudGVyaW5nSXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgaXRlbS53aWxsRW50ZXIgPSB0cnVlXG4gICAgfSlcblxuICAgIC8vIEZpbmQgaXRlbXMgdGhhdCBzaG91bGQgbGVhdmVcbiAgICBjb25zdCBsZWF2aW5nSXRlbXMgPSBjdXJyZW50SXRlbXMuZmlsdGVyKFxuICAgICAgY3VycmVudEl0ZW0gPT4gIW5ld0l0ZW1zLmZpbmQobmV3SXRlbSA9PiBuZXdJdGVtLmtleSA9PT0gY3VycmVudEl0ZW0ua2V5KVxuICAgIClcblxuICAgIGxlYXZpbmdJdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICBpdGVtLndpbGxMZWF2ZSA9IHRydWVcbiAgICB9KVxuXG4gICAgLy8gRmluZCBpdGVtcyB0aGF0IGFyZSBzdGF5aW5nXG4gICAgY29uc3Qgc3RheWluZ0l0ZW1zID0gY3VycmVudEl0ZW1zLmZpbHRlcihjdXJyZW50SXRlbSA9PlxuICAgICAgbmV3SXRlbXMuZmluZChuZXdJdGVtID0+IG5ld0l0ZW0ua2V5ID09PSBjdXJyZW50SXRlbS5rZXkpXG4gICAgKVxuXG4gICAgc3RheWluZ0l0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAvLyBJZiB0aGUgaXRlbSB3YXMgbGVhdmluZywgYW5kIGlzIG5vdyBzdGF5aW5nLCB1cGRhdGUgaXRcbiAgICAgIGlmIChpdGVtLmxlYXZpbmcpIHtcbiAgICAgICAgaXRlbS53aWxsVXBkYXRlID0gdHJ1ZVxuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIGl0ZW0ncyB1cGRhdGUgZnVuY3Rpb24gcmV0dXJucyBzb21ldGhpbmcgbmV3LCB1cGRhdGUgaXRcbiAgICAgIGNvbnN0IG5ld0Rlc3RTdGF0ZSA9IHVwZGF0ZShpdGVtLmRhdGEsIGl0ZW0ua2V5KVxuICAgICAgaWYgKCFVdGlscy5kZWVwRXF1YWxzKGl0ZW0uZGVzdFN0YXRlLCBuZXdEZXN0U3RhdGUpKSB7XG4gICAgICAgIGl0ZW0ud2lsbFVwZGF0ZSA9IHRydWVcbiAgICAgIH1cbiAgICAgIGl0ZW0ud2lsbExlYXZlID0gZmFsc2VcbiAgICAgIGl0ZW0ud2lsbEVudGVyID0gZmFsc2VcbiAgICB9KVxuXG4gICAgLy8gTWVyZ2UgYWxsIG9mIHRoZSBpdGVtcyB0b2dldGhlciBhbmRcbiAgICAvLyBnaXZlIGVhY2ggaXRlbSBpdCdzIG5ldyBvcmlnaW4vZGVzdGluYXRpb24gc3RhdGVzXG4gICAgLy8gd2l0aCBjb3JyZXNwb25kaW5nIGludGVycG9sYXRvcnNcbiAgICB0aGlzLml0ZW1zID0gbWVyZ2VJdGVtcyhjdXJyZW50SXRlbXMsIGVudGVyaW5nSXRlbXMpXG5cbiAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgIC8vIFF1ZXVlIGFuIHVwZGF0ZSBlaXRoZXIgaW1tZWRpYXRlbHkgb3IgdXNpbmcgYSBzdGFnZ2VyT2Zmc2V0XG4gICAgICBsZXQgc3RhZ2dlck9mZnNldCA9IDBcbiAgICAgIC8vIEZvciBzdGFnZ2VyaW5nIHRpbWUgYmFzZWQgYW5pbWF0aW9ucywgd2UganVzdCBuZWVkIHRoZSBpbmRleFxuICAgICAgbGV0IHN0YWdnZXJJbmRleCA9IGkgKyAxXG4gICAgICAvLyBCdXQgaWYgd2UgYXJlIHN0YWdnZXJpbmcgYnkgZ3JvdXAsIHdlIHdpbGwgaW5zdGVhZCBuZWVkIHRoZSBpbmRleCBvZiB0aGVcbiAgICAgIC8vIGl0ZW0gcmVsYXRpdmUgdG8gaXRzIHByZWRlY2Vzc29ycyB3aG8gc2hhcmUgdGhlIHNhbWUgZW50ZXJpbmcvbGVhdmluZyBncm91cFxuICAgICAgaWYgKHN0YWdnZXIgJiYgc3RhZ2dlckdyb3Vwcykge1xuICAgICAgICBzdGFnZ2VySW5kZXggPSAwXG4gICAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBpOyBpaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc3RhZ2dlckl0ZW0gPSB0aGlzLml0ZW1zW2lpXVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHN0YWdnZXJJdGVtLndpbGxFbnRlciA9PT0gaXRlbS53aWxsRW50ZXIgJiZcbiAgICAgICAgICAgIHN0YWdnZXJJdGVtLndpbGxMZWF2ZSA9PT0gaXRlbS53aWxsTGVhdmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHN0YWdnZXJJbmRleCsrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFnZ2VyKSB7XG4gICAgICAgIC8vIElmIGl0cyBzdGFnZ2VyZWQsIHdlIG5lZWQgYmFzZSB0aGUgcHJvZ3Jlc3Mgb2ZmIG9mXG4gICAgICAgIC8vIHRoZSBzdGFnZ2VyZWQgdGltZSwgaW5zdGVhZCBvZiB0aGUgY3VycmVudFRpbWVcbiAgICAgICAgc3RhZ2dlck9mZnNldCA9IHN0YWdnZXIgKiBzdGFnZ2VySW5kZXhcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIGV2ZXJ5IGl0ZW0gdGhhdCBuZWVkcyB0byBiZSByZXNldCwgc2V0IGEgbmV3IHN0YXJ0VGltZVxuICAgICAgaWYgKGl0ZW0ud2lsbEVudGVyIHx8IGl0ZW0ud2lsbExlYXZlIHx8IGl0ZW0ud2lsbFVwZGF0ZSkge1xuICAgICAgICBpdGVtLm5leHRVcGRhdGUgPSBzdGFnZ2VyT2Zmc2V0ID8gbm93KCkgKyBzdGFnZ2VyT2Zmc2V0IDogdHJ1ZVxuICAgICAgICBpdGVtLmR1cmF0aW9uID1cbiAgICAgICAgICB0eXBlb2YgZ2V0RHVyYXRpb24gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gZ2V0RHVyYXRpb24oaXRlbS5kYXRhLCBpdGVtLmtleSlcbiAgICAgICAgICAgIDogZHVyYXRpb25cbiAgICAgICAgaXRlbS5lYXNpbmcgPVxuICAgICAgICAgIHR5cGVvZiBnZXRFYXNpbmcgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gZ2V0RWFzaW5nKGl0ZW0uZGF0YSwgaXRlbS5rZXkpXG4gICAgICAgICAgICA6IGVhc2luZ1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZWFzaW5nIGZ1bmN0aW9uXG4gICAgICAgIGl0ZW0uZWFzZXIgPVxuICAgICAgICAgIHR5cGVvZiBpdGVtLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpdGVtLmVhc2luZ1xuICAgICAgICAgICAgOiBFYXNpbmdbaXRlbS5lYXNpbmddIHx8IEVhc2luZ1tkZWZhdWx0cy5lYXNpbmddXG4gICAgICB9XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHBvc3NpYmxlIHN0YXRlcyBmb3IgZWFjaCBpdGVtXG4gICAgICBpdGVtLm5leHQudXBkYXRlID0gdXBkYXRlKGl0ZW0uZGF0YSwgaXRlbS5rZXkpXG4gICAgICBpdGVtLm5leHQuZW50ZXIgPSBlbnRlcihpdGVtLmRhdGEsIGl0ZW0ua2V5KVxuICAgICAgaXRlbS5uZXh0LmxlYXZlID0gbGVhdmUoaXRlbS5kYXRhLCBpdGVtLmtleSlcblxuICAgICAgLy8gU2luY2UgdGhlIHVuZGVybHlpbmcgZGF0YSBjb3VsZCBoYXZlIGNoYW5nZWQgZm9yIHRoZSBjdXJyZW50SXRlbXNcbiAgICAgIC8vIHVwZGF0ZSB0aGVtIGFsbFxuICAgICAgY29uc3QgbmV3SXRlbSA9IG5ld0l0ZW1zLmZpbmQoZCA9PiBkLmtleSA9PT0gaXRlbS5rZXkpXG4gICAgICBpdGVtLmRhdGEgPSBuZXdJdGVtID8gbmV3SXRlbS5kYXRhIDogaXRlbS5kYXRhXG4gICAgfSlcblxuICAgIC8vIEJlIHN1cmUgdG8gcmVuZGVyIHRoZSBvcmlnaW4gZnJhbWVcbiAgICB0aGlzLnJlbmRlclByb2dyZXNzKClcblxuICAgIC8vIEFuaW1hdGUgaWYgbmVlZGVkXG4gICAgdGhpcy5hbmltYXRlKClcbiAgfVxuXG4gIGFuaW1hdGUgKCkge1xuICAgIC8vIElmIHdlJ3JlIHVubW91bnRpbmcsIGJhaWwgb3V0LlxuICAgIGlmICh0aGlzLnVubW91bnRpbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgYW5pbWF0ZWQsIGJhaWwgb3V0LlxuICAgIGlmICh0aGlzLmFuaW1hdGlvbklEKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IGZsZXhEdXJhdGlvbiwgaWdub3JlIH0gPSB0aGlzLnByb3BzXG5cbiAgICB0aGlzLmFuaW1hdGlvbklEID0gUkFGKCgpID0+IHtcbiAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHdlIGFyZSBzdGlsbCBtb3VudGVkLCBzaW5jZSBSQUYgY2FuIHBlcmZvcm1cbiAgICAgIC8vIGFzeW5jcm9ub3VzbHkgc29tZXRpbWVzXG4gICAgICBpZiAodGhpcy51bm1vdW50aW5nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRpbWVcbiAgICAgIGxldCBjdXJyZW50VGltZSA9IG5vdygpXG5cbiAgICAgIC8vIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLmZpbHRlcihcbiAgICAgIC8vICAgaXRlbSA9PiAhKGl0ZW0ubGVhdmluZyAmJiBpdGVtLnByb2dyZXNzID09PSAxKVxuICAgICAgLy8gKVxuXG4gICAgICBjb25zdCBuZWVkc0FuaW1hdGlvbiA9IHRoaXMuaXRlbXMuc29tZShcbiAgICAgICAgaXRlbSA9PiBpdGVtLm5leHRVcGRhdGUgfHwgaXRlbS5wcm9ncmVzcyA8IDFcbiAgICAgIClcblxuICAgICAgLy8gSWYgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgdGllIHVwIGFueSBsb29zZSBlbmRzLi4uXG4gICAgICBpZiAoIW5lZWRzQW5pbWF0aW9uKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSUQgPSBudWxsXG4gICAgICAgIHRoaXMud2FzQW5pbWF0aW5nID0gZmFsc2VcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEl0J3MgdGltZSB0byBhbmltYXRlIVxuICAgICAgdGhpcy53YXNBbmltYXRpbmcgPSB0cnVlXG5cbiAgICAgIC8vIElmIHdlIHVzaW5nIGZsZXhEdXJhdGlvbiwgYWRkIGhvd2V2ZXIgbWFueSBtaWxsaXNlY29uZHMgYmVoaW5kIHdlIGFyZSB0byB0aGUgZmxleEFtb3VudCB0byBvZmZzZXRcbiAgICAgIC8vIGFueSBkcm9wcGVkIGZyYW1lc1xuICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEZyYW1lID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RSZW5kZXJUaW1lXG4gICAgICBjdXJyZW50VGltZSArPSBmbGV4RHVyYXRpb25cbiAgICAgICAgPyBNYXRoLm1heChNYXRoLmZsb29yKHRpbWVTaW5jZUxhc3RGcmFtZSAtIG1zUGVyRnJhbWUpLCAwKVxuICAgICAgICA6IDBcblxuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIC8vIElmIHRoZSBpdGVtIGlzIHJlYWR5IHRvIGJlIHVwZGF0ZWQsIGRvIGl0IG5vd1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXRlbS5uZXh0VXBkYXRlID09PSB0cnVlIHx8XG4gICAgICAgICAgKGl0ZW0ubmV4dFVwZGF0ZSAmJiBpdGVtLm5leHRVcGRhdGUgPD0gY3VycmVudFRpbWUpXG4gICAgICAgICkge1xuICAgICAgICAgIGl0ZW0uZW50ZXJpbmcgPSBmYWxzZVxuICAgICAgICAgIGl0ZW0ubGVhdmluZyA9IGZhbHNlXG4gICAgICAgICAgaXRlbS51cGRhdGluZyA9IGZhbHNlXG4gICAgICAgICAgLy8gVXBkYXRlIGxlYXZpbmcsIGVudGVyaW5nLCBhbmQgY2hhbmdlZCBpdGVtcyB3aXRoIHRoZWlyIG5ldyBvcmlnaW5zLFxuICAgICAgICAgIC8vIGRlc3RpbmF0aW9ucyBhbmQgaW50ZXJwb2xhdG9yc1xuICAgICAgICAgIGlmIChpdGVtLndpbGxFbnRlcikge1xuICAgICAgICAgICAgaXRlbS53aWxsRW50ZXIgPSBmYWxzZVxuICAgICAgICAgICAgaXRlbS5lbnRlcmluZyA9IHRydWVcbiAgICAgICAgICAgIGl0ZW0ub3JpZ2luU3RhdGUgPSBpdGVtLm5leHQuZW50ZXIgfHwgaXRlbS5uZXh0LnVwZGF0ZVxuICAgICAgICAgICAgaXRlbS5kZXN0U3RhdGUgPSBpdGVtLm5leHQudXBkYXRlXG4gICAgICAgICAgICBpdGVtLmludGVycG9sYXRvcnMgPSBtYWtlSW50ZXJwb2xhdG9ycyhcbiAgICAgICAgICAgICAgaXRlbS5vcmlnaW5TdGF0ZSxcbiAgICAgICAgICAgICAgaXRlbS5kZXN0U3RhdGUsXG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS53aWxsTGVhdmUpIHtcbiAgICAgICAgICAgIGl0ZW0ud2lsbExlYXZlID0gZmFsc2VcbiAgICAgICAgICAgIGl0ZW0ubGVhdmluZyA9IHRydWVcbiAgICAgICAgICAgIGl0ZW0ub3JpZ2luU3RhdGUgPSBpdGVtLnN0YXRlIHx8IGl0ZW0ubmV4dC51cGRhdGVcbiAgICAgICAgICAgIGl0ZW0uZGVzdFN0YXRlID0gaXRlbS5uZXh0LmxlYXZlIHx8IGl0ZW0ubmV4dC51cGRhdGVcbiAgICAgICAgICAgIGl0ZW0uaW50ZXJwb2xhdG9ycyA9IG1ha2VJbnRlcnBvbGF0b3JzKFxuICAgICAgICAgICAgICBpdGVtLm9yaWdpblN0YXRlLFxuICAgICAgICAgICAgICBpdGVtLmRlc3RTdGF0ZSxcbiAgICAgICAgICAgICAgaWdub3JlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLndpbGxVcGRhdGUpIHtcbiAgICAgICAgICAgIGl0ZW0ud2lsbFVwZGF0ZSA9IGZhbHNlXG4gICAgICAgICAgICBpdGVtLnVwZGF0aW5nID0gdHJ1ZVxuICAgICAgICAgICAgaXRlbS5vcmlnaW5TdGF0ZSA9IGl0ZW0uc3RhdGUgfHwgaXRlbS5uZXh0LnVwZGF0ZVxuICAgICAgICAgICAgaXRlbS5kZXN0U3RhdGUgPSBpdGVtLm5leHQudXBkYXRlXG4gICAgICAgICAgICBpdGVtLmludGVycG9sYXRvcnMgPSBtYWtlSW50ZXJwb2xhdG9ycyhcbiAgICAgICAgICAgICAgaXRlbS5vcmlnaW5TdGF0ZSxcbiAgICAgICAgICAgICAgaXRlbS5kZXN0U3RhdGUsXG4gICAgICAgICAgICAgIGlnbm9yZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZvciBldmVyeSBpdGVtIHRoYXQgbmVlZHMgdG8gYmUgcmVzZXQsIHNldCBhIG5ldyBzdGFydFRpbWUgYW5kIGR1cnRhaW9uXG4gICAgICAgICAgaXRlbS5zdGFydFRpbWUgPSBub3coKVxuICAgICAgICAgIGl0ZW0ubmV4dFVwZGF0ZSA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIHByb2dyZXNzXG4gICAgICAgIGxldCBwcm9ncmVzcyA9IGl0ZW0uc3RhcnRUaW1lXG4gICAgICAgICAgPyAoY3VycmVudFRpbWUgLSBpdGVtLnN0YXJ0VGltZSkgLyBpdGVtLmR1cmF0aW9uXG4gICAgICAgICAgOiAwXG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHByb2dyZXNzIGlzIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKHByb2dyZXNzLCAxKSwgMClcblxuICAgICAgICBpdGVtLnByb2dyZXNzID0gcHJvZ3Jlc3NcbiAgICAgIH0pXG5cbiAgICAgIC8vIFJlbmRlciB3aXRoIHRoZSBwcm9ncmVzc1xuICAgICAgdGhpcy5yZW5kZXJQcm9ncmVzcygpXG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdFJlbmRlclRpbWVcbiAgICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSBjdXJyZW50VGltZVxuXG4gICAgICAvLyBNYXJrIHRoZSBmcmFtZSBhcyBkb25lXG4gICAgICB0aGlzLmFuaW1hdGlvbklEID0gbnVsbFxuXG4gICAgICB0aGlzLmFuaW1hdGUoKVxuICAgIH0pXG4gIH1cblxuICByZW5kZXJQcm9ncmVzcyAoKSB7XG4gICAgY29uc3QgeyBvblJlc3QgfSA9IHRoaXMucHJvcHNcbiAgICAvLyBEb24ndCBpbnRlcnBvbGF0ZSBpdGVtcyB0aGF0IGhhdmVuJ3QgZW50ZXJlZCB5ZXRcbiAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zLmZpbHRlcihcbiAgICAgIGl0ZW0gPT4gIWl0ZW0ud2lsbEVudGVyICYmIGl0ZW0ub3JpZ2luU3RhdGUgJiYgaXRlbS5kZXN0U3RhdGVcbiAgICApXG5cbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaXRlbS5zdGF0ZSA9IHt9XG4gICAgICBjb25zdCBhbGxLZXlzID0gZGVkdXBlKFxuICAgICAgICBPYmplY3Qua2V5cyhpdGVtLm9yaWdpblN0YXRlIHx8IHt9KSxcbiAgICAgICAgT2JqZWN0LmtleXMoaXRlbS5kZXN0U3RhdGUgfHwge30pXG4gICAgICApXG5cbiAgICAgIGFsbEtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoIWl0ZW0ucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAvLyBJZiBhdCBhYnNvbHV0ZSAwLCBkcmF3IHRoZSBvcmlnaW4gc3RhdGVcbiAgICAgICAgICBpdGVtLnN0YXRlW2tleV0gPSBpdGVtLm9yaWdpblN0YXRlW2tleV1cbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnByb2dyZXNzID09PSAxIHx8ICFpdGVtLmludGVycG9sYXRvcnNba2V5XSkge1xuICAgICAgICAgIC8vIElmIGlnbm9yZWQsIHNraXAgcmlnaHQgdG8gdGhlIHZhbHVlXG4gICAgICAgICAgaXRlbS5zdGF0ZVtrZXldID0gaXRlbS5kZXN0U3RhdGVba2V5XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgd2l0aCB0aGUgcHJvZ3Jlc3NcbiAgICAgICAgICBpdGVtLnN0YXRlW2tleV0gPSBpdGVtLmludGVycG9sYXRvcnNba2V5XShpdGVtLmVhc2VyKGl0ZW0ucHJvZ3Jlc3MpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYgKGl0ZW0ucHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgICAgb25SZXN0KGl0ZW0uZGF0YSwgaXRlbS5rZXkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIERvbid0IHJlbmRlciBpdGVtcyB0aGF0IGhhdmVuJ3QgZW50ZXJlZCB5ZXQgb3IgaGF2ZSBleGl0ZWRcbiAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcihcbiAgICAgIGl0ZW0gPT4gIShpdGVtLndpbGxFbnRlciB8fCAoaXRlbS5sZWF2aW5nICYmIGl0ZW0ucHJvZ3Jlc3MgPT09IDEpKVxuICAgIClcblxuICAgIC8vIFJlbW92ZSBpdGVtcyB0aGF0IGhhdmUgZXhpdGVkXG4gICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMuZmlsdGVyKFxuICAgICAgaXRlbSA9PiAhKGl0ZW0ubGVhdmluZyAmJiBpdGVtLnByb2dyZXNzID09PSAxKVxuICAgIClcblxuICAgIHRoaXMuc2V0U3RhdGUoeyBpdGVtcyB9KVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnN0YXRlLml0ZW1zKVxuICAgIHJldHVybiByZW5kZXJlZENoaWxkcmVuICYmIFJlYWN0LkNoaWxkcmVuLm9ubHkocmVuZGVyZWRDaGlsZHJlbilcbiAgfVxufVxuXG4vLyBUYWtlbiBmcm9tIHJlYWN0LW1vdGlvbidzIG1lcmdlRGlmZiAoaHR0cHM6Ly9naXRodWIuY29tL2NoZW5nbG91L3JlYWN0LW1vdGlvbi9ibG9iLzQ0NmE4ZDAxMzAwNzJjNGE1OWZlYzFhYjc4OGJmYzJjYzVjNWI3ODgvc3JjL21lcmdlRGlmZi5qcylcbmZ1bmN0aW9uIG1lcmdlSXRlbXMgKHByZXYsIG5leHQpIHtcbiAgY29uc3QgcHJldktleUluZGV4ID0ge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Lmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldktleUluZGV4W3ByZXZbaV0ua2V5XSA9IGlcbiAgfVxuICBjb25zdCBuZXh0S2V5SW5kZXggPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICBuZXh0S2V5SW5kZXhbbmV4dFtpXS5rZXldID0gaVxuICB9XG4gIC8vIE1lcmdlIHRoZSBhcnJheXNcbiAgY29uc3QgYWxsSXRlbXMgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICBhbGxJdGVtc1tpXSA9IG5leHRbaV1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0S2V5SW5kZXgsIHByZXZbaV0ua2V5KSkge1xuICAgICAgYWxsSXRlbXMucHVzaChwcmV2W2ldKVxuICAgIH1cbiAgfVxuICAvLyBub3cgYWxsIHRoZSBpdGVtcyBhbGwgcHJlc2VudC4gQ29yZSBzb3J0aW5nIGxvZ2ljIHRvIGhhdmUgdGhlIHJpZ2h0IG9yZGVyXG4gIHJldHVybiBhbGxJdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgY29uc3QgbmV4dE9yZGVyQSA9IG5leHRLZXlJbmRleFthLmtleV1cbiAgICBjb25zdCBuZXh0T3JkZXJCID0gbmV4dEtleUluZGV4W2Iua2V5XVxuICAgIGNvbnN0IHByZXZPcmRlckEgPSBwcmV2S2V5SW5kZXhbYS5rZXldXG4gICAgY29uc3QgcHJldk9yZGVyQiA9IHByZXZLZXlJbmRleFtiLmtleV1cbiAgICBpZiAobmV4dE9yZGVyQSAhPSBudWxsICYmIG5leHRPcmRlckIgIT0gbnVsbCkge1xuICAgICAgLy8gYm90aCBrZXlzIGluIG5leHRcbiAgICAgIHJldHVybiBuZXh0S2V5SW5kZXhbYS5rZXldIC0gbmV4dEtleUluZGV4W2Iua2V5XVxuICAgIH0gZWxzZSBpZiAocHJldk9yZGVyQSAhPSBudWxsICYmIHByZXZPcmRlckIgIT0gbnVsbCkge1xuICAgICAgLy8gYm90aCBrZXlzIGluIHByZXZcbiAgICAgIHJldHVybiBwcmV2S2V5SW5kZXhbYS5rZXldIC0gcHJldktleUluZGV4W2Iua2V5XVxuICAgIH0gZWxzZSBpZiAobmV4dE9yZGVyQSAhPSBudWxsKSB7XG4gICAgICAvLyBrZXkgYSBpbiBuZXh0LCBrZXkgYiBpbiBwcmV2XG4gICAgICAvLyBob3cgdG8gZGV0ZXJtaW5lIHRoZSBvcmRlciBiZXR3ZWVuIGEgYW5kIGI/IFdlIGZpbmQgYSBcInBpdm90XCIgKHRlcm1cbiAgICAgIC8vIGFidXNlKSwgYSBrZXkgcHJlc2VudCBpbiBib3RoIHByZXYgYW5kIG5leHQsIHRoYXQgaXMgc2FuZHdpY2hlZCBiZXR3ZWVuXG4gICAgICAvLyBhIGFuZCBiLiBJbiB0aGUgY29udGV4dCBvZiBvdXIgYWJvdmUgZXhhbXBsZSwgaWYgd2UncmUgY29tcGFyaW5nIGEgYW5kXG4gICAgICAvLyBkLCBiJ3MgKHRoZSBvbmx5KSBwaXZvdFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBpdm90ID0gbmV4dFtpXS5rZXlcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJldktleUluZGV4LCBwaXZvdCkpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXh0T3JkZXJBIDwgbmV4dEtleUluZGV4W3Bpdm90XSAmJlxuICAgICAgICAgIHByZXZPcmRlckIgPiBwcmV2S2V5SW5kZXhbcGl2b3RdXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIG5leHRPcmRlckEgPiBuZXh0S2V5SW5kZXhbcGl2b3RdICYmXG4gICAgICAgICAgcHJldk9yZGVyQiA8IHByZXZLZXlJbmRleFtwaXZvdF1cbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcGx1Z2dhYmxlLiBkZWZhdWx0IHRvOiBuZXh0IGJpZ2dlciB0aGFuIHByZXZcbiAgICAgIHJldHVybiAxXG4gICAgfVxuICAgIC8vIHByZXZPcmRlckEsIG5leHRPcmRlckJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBpdm90ID0gbmV4dFtpXS5rZXlcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByZXZLZXlJbmRleCwgcGl2b3QpKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIG5leHRPcmRlckIgPCBuZXh0S2V5SW5kZXhbcGl2b3RdICYmXG4gICAgICAgIHByZXZPcmRlckEgPiBwcmV2S2V5SW5kZXhbcGl2b3RdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG5leHRPcmRlckIgPiBuZXh0S2V5SW5kZXhbcGl2b3RdICYmXG4gICAgICAgIHByZXZPcmRlckEgPCBwcmV2S2V5SW5kZXhbcGl2b3RdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBsdWdnYWJsZS4gZGVmYXVsdCB0bzogbmV4dCBiaWdnZXIgdGhhbiBwcmV2XG4gICAgcmV0dXJuIC0xXG4gIH0pXG59XG5cblRyYW5zaXRpb24uZGVmYXVsdHMgPSBkZWZhdWx0c1xuXG5mdW5jdGlvbiBkZWR1cGUgKC4uLmFycnMpIHtcbiAgY29uc3QgYWxsSXRlbXMgPSBhcnJzLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgYWxsSXRlbXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChhbGxJdGVtc1tpXSA9PT0gYWxsSXRlbXNbal0pIHtcbiAgICAgICAgYWxsSXRlbXMuc3BsaWNlKGotLSwgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbEl0ZW1zXG59XG4iXX0=