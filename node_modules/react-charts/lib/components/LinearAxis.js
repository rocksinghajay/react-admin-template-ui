'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.positionLeft = exports.positionBottom = exports.positionRight = exports.positionTop = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactState = require('react-state');

var _reactMove = require('react-move');

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

var _Axis = require('./Axis.measure');

var _Axis2 = _interopRequireDefault(_Axis);

var _Axis3 = require('./Axis.updateScale');

var _Axis4 = _interopRequireDefault(_Axis3);

var _Path = require('../primitives/Path');

var _Path2 = _interopRequireDefault(_Path);

var _Line = require('../primitives/Line');

var _Line2 = _interopRequireDefault(_Line);

var _Text = require('../primitives/Text');

var _Text2 = _interopRequireDefault(_Text);

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


var fontSize = 10;

var positionTop = exports.positionTop = 'top';
var positionRight = exports.positionRight = 'right';
var positionBottom = exports.positionBottom = 'bottom';
var positionLeft = exports.positionLeft = 'left';

var Axis = function (_PureComponent) {
  _inherits(Axis, _PureComponent);

  // Lifecycle
  function Axis() {
    _classCallCheck(this, Axis);

    var _this = _possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this));

    _this.rotation = 0;
    _this.measure = _Axis2.default.bind(_this);
    _this.updateScale = _Axis4.default.bind(_this);
    return _this;
  }

  _createClass(Axis, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      var oldProps = this.props;
      if (oldProps.axis !== newProps.axis && oldProps.axis) {
        this.prevAxis = oldProps.axis;
      }

      // If any of the following change,
      // we need to update the axis
      if (newProps.axes !== oldProps.axes || newProps.primary !== oldProps.primary || newProps.type !== oldProps.type || newProps.invert !== oldProps.invert || newProps.materializedData !== oldProps.materializedData || newProps.height !== oldProps.height || newProps.width !== oldProps.width || newProps.position !== oldProps.position) {
        this.updateScale(newProps);
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateScale(this.props);
      this.measure();
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(newProps) {
      if (newProps.axis !== this.props.axis) {
        return true;
      }
      return false;
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      var _this2 = this;

      (0, _raf2.default)(function () {
        if (!_this2.measure()) {
          window.setTimeout(function () {
            return _this2.componentDidUpdate();
          }, 1);
        }
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          type = _props.type,
          axis = _props.axis,
          position = _props.position,
          width = _props.width,
          height = _props.height,
          showGrid = _props.showGrid,
          tickSizeInner = _props.tickSizeInner,
          tickSizeOuter = _props.tickSizeOuter,
          display = _props.display;
      var rotation = this.rotation;

      // Render Dependencies

      if (!axis || !display) {
        return null;
      }

      var scale = axis.scale,
          max = axis.max,
          transform = axis.transform,
          vertical = axis.vertical,
          format = axis.format,
          ticks = axis.ticks,
          _axis$range = _slicedToArray(axis.range, 2),
          range0 = _axis$range[0],
          range1 = _axis$range[1],
          directionMultiplier = axis.directionMultiplier,
          tickOffset = axis.tickOffset,
          gridOffset = axis.gridOffset,
          spacing = axis.spacing;

      return _react2.default.createElement(
        _reactMove.Animate,
        {
          data: {
            width: width,
            height: height,
            max: max,
            range0: range0,
            range1: range1,
            directionMultiplier: directionMultiplier,
            tickSizeOuter: tickSizeOuter,
            tickOffset: tickOffset,
            gridOffset: gridOffset,
            spacing: spacing
          }
        },
        function (_ref) {
          var width = _ref.width,
              height = _ref.height,
              max = _ref.max,
              range0 = _ref.range0,
              range1 = _ref.range1,
              directionMultiplier = _ref.directionMultiplier,
              tickSizeOuter = _ref.tickSizeOuter,
              tickOffset = _ref.tickOffset,
              gridOffset = _ref.gridOffset,
              spacing = _ref.spacing;

          var axisPath = void 0;
          if (vertical) {
            if (position === positionLeft) {
              axisPath = '\n                M ' + -tickSizeOuter + ', ' + range0 + '\n                H 0\n                V ' + range1 + '\n                H ' + -tickSizeOuter + '\n              ';
            } else {
              axisPath = '\n                M ' + tickSizeOuter + ', ' + range0 + '\n                H 0\n                V ' + range1 + '\n                H ' + tickSizeOuter + '\n              ';
            }
          } else {
            if (position === positionBottom) {
              axisPath = '\n                M 0, ' + tickSizeOuter + '\n                V 0\n                H ' + range1 + '\n                V ' + tickSizeOuter + '\n              ';
            } else {
              axisPath = '\n                M 0, ' + -tickSizeOuter + '\n                V 0\n                H ' + range1 + '\n                V ' + -tickSizeOuter + '\n              ';
            }
          }

          return _react2.default.createElement(
            'g',
            {
              className: 'Axis',
              fill: 'black',
              fontSize: '10',
              fontFamily: 'sans-serif',
              transform: position === positionRight ? translateX(width) : position === positionBottom ? translateY(height) : undefined
            },
            _react2.default.createElement(_Path2.default, {
              className: 'domain',
              d: axisPath,
              style: {
                stroke: '#acacac',
                strokeWidth: '1',
                fill: 'transparent'
              }
            }),
            _react2.default.createElement(
              _reactMove.Transition,
              {
                data: ticks,
                getKey: function getKey(d, i) {
                  return String(d);
                },
                update: function update(d) {
                  return {
                    tick: scale(d),
                    visibility: 1,
                    measureable: 1,
                    rotation: rotation
                  };
                },
                enter: function enter(d) {
                  return {
                    tick: _this3.prevAxis.scale(d),
                    visibility: 0,
                    measureable: 1,
                    rotation: 0
                  };
                },
                leave: function leave(d) {
                  return {
                    tick: scale(d),
                    visibility: 0,
                    measureable: 0,
                    rotation: rotation
                  };
                },
                ignore: ['measureable'],
                duration: 500
              },
              function (inters) {
                var showGridLine = showGrid;

                // If ordinal and showGrid isn't explicit, hide it
                if (type === 'ordinal' && showGrid === 1) {
                  showGridLine = false;
                }

                return _react2.default.createElement(
                  'g',
                  {
                    className: 'ticks',
                    ref: function ref(el) {
                      _this3.el = el;
                    }
                  },
                  inters.map(function (inter, index) {
                    return _react2.default.createElement(
                      'g',
                      {
                        key: inter.key,
                        className: 'tick' + (inter.state.measureable ? ' -measureable' : ''),
                        transform: transform(inter.state.tick)
                      },
                      _react2.default.createElement(_Line2.default, {
                        x1: vertical ? 0 : tickOffset,
                        x2: vertical ? directionMultiplier * tickSizeInner : tickOffset,
                        y1: vertical ? tickOffset : 0,
                        y2: vertical ? tickOffset : directionMultiplier * tickSizeInner,
                        style: {
                          strokeWidth: 1
                        },
                        opacity: inter.state.visibility * 0.2
                      }),
                      showGridLine && _react2.default.createElement(_Line2.default, {
                        x1: vertical ? 0 : gridOffset,
                        x2: vertical ? max : gridOffset,
                        y1: vertical ? gridOffset : 0,
                        y2: vertical ? gridOffset : max,
                        style: {
                          strokeWidth: 1
                        },
                        opacity: inter.state.visibility * (index !== 0 && index !== inters.length - 1 && inter.data === 0 ? 0.5 : 0.2)
                      }),
                      _react2.default.createElement(
                        _Text2.default,
                        {
                          opacity: inter.state.visibility,
                          fontSize: fontSize,
                          transform: '\n                                translate(' + (vertical ? directionMultiplier * spacing : tickOffset) + ', ' + (vertical ? tickOffset : directionMultiplier * spacing) + ')\n                                rotate(' + -rotation + ')\n                              ',
                          dominantBaseline: rotation ? 'central' : position === positionBottom ? 'hanging' : position === positionTop ? 'alphabetic' : 'central',
                          textAnchor: rotation ? 'end' : position === positionRight ? 'start' : position === positionLeft ? 'end' : 'middle'
                        },
                        format(inter.data)
                      )
                    );
                  })
                );
              }
            )
          );
        }
      );
    }
  }]);

  return Axis;
}(_react.PureComponent);

Axis.defaultProps = {
  tickArguments: [],
  tickValues: null,
  tickFormat: null,
  tickSizeInner: 6,
  tickSizeOuter: 6,
  tickPadding: 3,
  maxLabelRotation: 50,
  innerPadding: 0.2,
  outerPadding: 0.1,
  showGrid: 1,
  display: true
};
exports.default = (0, _reactState.Connect)(function () {
  var selectors = {
    gridWidth: _Selectors2.default.gridWidth(),
    gridHeight: _Selectors2.default.gridHeight(),
    primaryAxis: _Selectors2.default.primaryAxis()
  };
  return function (state, props) {
    var type = props.type,
        position = props.position;


    var id = type + '_' + position;

    return {
      id: id,
      materializedData: state.materializedData,
      width: selectors.gridWidth(state),
      height: selectors.gridHeight(state),
      primaryAxis: selectors.primaryAxis(state),
      axis: state.axes && state.axes[id]
    };
  };
}, {
  filter: function filter(oldState, newState, meta) {
    return meta.type !== 'cursor';
  }
})(Axis);


function translateX(x) {
  return 'translate(' + x + ', 0)';
}

function translateY(y) {
  return 'translate(0, ' + y + ')';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0xpbmVhckF4aXMuanMiXSwibmFtZXMiOlsiZm9udFNpemUiLCJwb3NpdGlvblRvcCIsInBvc2l0aW9uUmlnaHQiLCJwb3NpdGlvbkJvdHRvbSIsInBvc2l0aW9uTGVmdCIsIkF4aXMiLCJyb3RhdGlvbiIsIm1lYXN1cmUiLCJiaW5kIiwidXBkYXRlU2NhbGUiLCJuZXdQcm9wcyIsIm9sZFByb3BzIiwicHJvcHMiLCJheGlzIiwicHJldkF4aXMiLCJheGVzIiwicHJpbWFyeSIsInR5cGUiLCJpbnZlcnQiLCJtYXRlcmlhbGl6ZWREYXRhIiwiaGVpZ2h0Iiwid2lkdGgiLCJwb3NpdGlvbiIsIndpbmRvdyIsInNldFRpbWVvdXQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJzaG93R3JpZCIsInRpY2tTaXplSW5uZXIiLCJ0aWNrU2l6ZU91dGVyIiwiZGlzcGxheSIsInNjYWxlIiwibWF4IiwidHJhbnNmb3JtIiwidmVydGljYWwiLCJmb3JtYXQiLCJ0aWNrcyIsInJhbmdlIiwicmFuZ2UwIiwicmFuZ2UxIiwiZGlyZWN0aW9uTXVsdGlwbGllciIsInRpY2tPZmZzZXQiLCJncmlkT2Zmc2V0Iiwic3BhY2luZyIsImF4aXNQYXRoIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJ1bmRlZmluZWQiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsImZpbGwiLCJkIiwiaSIsIlN0cmluZyIsInRpY2siLCJ2aXNpYmlsaXR5IiwibWVhc3VyZWFibGUiLCJzaG93R3JpZExpbmUiLCJlbCIsImludGVycyIsIm1hcCIsImludGVyIiwiaW5kZXgiLCJrZXkiLCJzdGF0ZSIsImxlbmd0aCIsImRhdGEiLCJkZWZhdWx0UHJvcHMiLCJ0aWNrQXJndW1lbnRzIiwidGlja1ZhbHVlcyIsInRpY2tGb3JtYXQiLCJ0aWNrUGFkZGluZyIsIm1heExhYmVsUm90YXRpb24iLCJpbm5lclBhZGRpbmciLCJvdXRlclBhZGRpbmciLCJzZWxlY3RvcnMiLCJncmlkV2lkdGgiLCJncmlkSGVpZ2h0IiwicHJpbWFyeUF4aXMiLCJpZCIsImZpbHRlciIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJtZXRhIiwieCIsInkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7Ozs7Ozs7QUFSQTs7O0FBVUEsSUFBTUEsV0FBVyxFQUFqQjs7QUFFTyxJQUFNQyxvQ0FBYyxLQUFwQjtBQUNBLElBQU1DLHdDQUFnQixPQUF0QjtBQUNBLElBQU1DLDBDQUFpQixRQUF2QjtBQUNBLElBQU1DLHNDQUFlLE1BQXJCOztJQUVEQyxJOzs7QUFjSjtBQUNBLGtCQUFjO0FBQUE7O0FBQUE7O0FBRVosVUFBS0MsUUFBTCxHQUFnQixDQUFoQjtBQUNBLFVBQUtDLE9BQUwsR0FBZSxlQUFRQyxJQUFSLE9BQWY7QUFDQSxVQUFLQyxXQUFMLEdBQW1CLGVBQVlELElBQVosT0FBbkI7QUFKWTtBQUtiOzs7OzhDQUN5QkUsUSxFQUFVO0FBQ2xDLFVBQU1DLFdBQVcsS0FBS0MsS0FBdEI7QUFDQSxVQUFJRCxTQUFTRSxJQUFULEtBQWtCSCxTQUFTRyxJQUEzQixJQUFtQ0YsU0FBU0UsSUFBaEQsRUFBc0Q7QUFDcEQsYUFBS0MsUUFBTCxHQUFnQkgsU0FBU0UsSUFBekI7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsVUFDRUgsU0FBU0ssSUFBVCxLQUFrQkosU0FBU0ksSUFBM0IsSUFDQUwsU0FBU00sT0FBVCxLQUFxQkwsU0FBU0ssT0FEOUIsSUFFQU4sU0FBU08sSUFBVCxLQUFrQk4sU0FBU00sSUFGM0IsSUFHQVAsU0FBU1EsTUFBVCxLQUFvQlAsU0FBU08sTUFIN0IsSUFJQVIsU0FBU1MsZ0JBQVQsS0FBOEJSLFNBQVNRLGdCQUp2QyxJQUtBVCxTQUFTVSxNQUFULEtBQW9CVCxTQUFTUyxNQUw3QixJQU1BVixTQUFTVyxLQUFULEtBQW1CVixTQUFTVSxLQU41QixJQU9B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QVN1QyxVQUFULENBQW9CdUMsQ0FBcEIsRUFBdUI7QUFDckIsU0FBTyxlQUFlQSxDQUFmLEdBQW1CLE1BQTFCO0FBQ0Q7O0FBRUQsU0FBU3RDLFVBQVQsQ0FBb0J1QyxDQUFwQixFQUF1QjtBQUNyQixTQUFPLGtCQUFrQkEsQ0FBbEIsR0FBc0IsR0FBN0I7QUFDRCIsImZpbGUiOiJMaW5lYXJBeGlzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IENvbm5lY3QgfSBmcm9tICdyZWFjdC1zdGF0ZSdcbmltcG9ydCB7IEFuaW1hdGUsIFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC1tb3ZlJ1xuaW1wb3J0IFJBRiBmcm9tICdyYWYnXG4vL1xuaW1wb3J0IG1lYXN1cmUgZnJvbSAnLi9BeGlzLm1lYXN1cmUnXG5pbXBvcnQgdXBkYXRlU2NhbGUgZnJvbSAnLi9BeGlzLnVwZGF0ZVNjYWxlJ1xuXG5pbXBvcnQgUGF0aCBmcm9tICcuLi9wcmltaXRpdmVzL1BhdGgnXG5pbXBvcnQgTGluZSBmcm9tICcuLi9wcmltaXRpdmVzL0xpbmUnXG5pbXBvcnQgVGV4dCBmcm9tICcuLi9wcmltaXRpdmVzL1RleHQnXG5cbmltcG9ydCBTZWxlY3RvcnMgZnJvbSAnLi4vdXRpbHMvU2VsZWN0b3JzJ1xuXG5jb25zdCBmb250U2l6ZSA9IDEwXG5cbmV4cG9ydCBjb25zdCBwb3NpdGlvblRvcCA9ICd0b3AnXG5leHBvcnQgY29uc3QgcG9zaXRpb25SaWdodCA9ICdyaWdodCdcbmV4cG9ydCBjb25zdCBwb3NpdGlvbkJvdHRvbSA9ICdib3R0b20nXG5leHBvcnQgY29uc3QgcG9zaXRpb25MZWZ0ID0gJ2xlZnQnXG5cbmNsYXNzIEF4aXMgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICB0aWNrQXJndW1lbnRzOiBbXSxcbiAgICB0aWNrVmFsdWVzOiBudWxsLFxuICAgIHRpY2tGb3JtYXQ6IG51bGwsXG4gICAgdGlja1NpemVJbm5lcjogNixcbiAgICB0aWNrU2l6ZU91dGVyOiA2LFxuICAgIHRpY2tQYWRkaW5nOiAzLFxuICAgIG1heExhYmVsUm90YXRpb246IDUwLFxuICAgIGlubmVyUGFkZGluZzogMC4yLFxuICAgIG91dGVyUGFkZGluZzogMC4xLFxuICAgIHNob3dHcmlkOiAxLFxuICAgIGRpc3BsYXk6IHRydWVcbiAgfVxuICAvLyBMaWZlY3ljbGVcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMucm90YXRpb24gPSAwXG4gICAgdGhpcy5tZWFzdXJlID0gbWVhc3VyZS5iaW5kKHRoaXMpXG4gICAgdGhpcy51cGRhdGVTY2FsZSA9IHVwZGF0ZVNjYWxlLmJpbmQodGhpcylcbiAgfVxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzKSB7XG4gICAgY29uc3Qgb2xkUHJvcHMgPSB0aGlzLnByb3BzXG4gICAgaWYgKG9sZFByb3BzLmF4aXMgIT09IG5ld1Byb3BzLmF4aXMgJiYgb2xkUHJvcHMuYXhpcykge1xuICAgICAgdGhpcy5wcmV2QXhpcyA9IG9sZFByb3BzLmF4aXNcbiAgICB9XG5cbiAgICAvLyBJZiBhbnkgb2YgdGhlIGZvbGxvd2luZyBjaGFuZ2UsXG4gICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgdGhlIGF4aXNcbiAgICBpZiAoXG4gICAgICBuZXdQcm9wcy5heGVzICE9PSBvbGRQcm9wcy5heGVzIHx8XG4gICAgICBuZXdQcm9wcy5wcmltYXJ5ICE9PSBvbGRQcm9wcy5wcmltYXJ5IHx8XG4gICAgICBuZXdQcm9wcy50eXBlICE9PSBvbGRQcm9wcy50eXBlIHx8XG4gICAgICBuZXdQcm9wcy5pbnZlcnQgIT09IG9sZFByb3BzLmludmVydCB8fFxuICAgICAgbmV3UHJvcHMubWF0ZXJpYWxpemVkRGF0YSAhPT0gb2xkUHJvcHMubWF0ZXJpYWxpemVkRGF0YSB8fFxuICAgICAgbmV3UHJvcHMuaGVpZ2h0ICE9PSBvbGRQcm9wcy5oZWlnaHQgfHxcbiAgICAgIG5ld1Byb3BzLndpZHRoICE9PSBvbGRQcm9wcy53aWR0aCB8fFxuICAgICAgbmV3UHJvcHMucG9zaXRpb24gIT09IG9sZFByb3BzLnBvc2l0aW9uXG4gICAgKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNjYWxlKG5ld1Byb3BzKVxuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVNjYWxlKHRoaXMucHJvcHMpXG4gICAgdGhpcy5tZWFzdXJlKClcbiAgfVxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMpIHtcbiAgICBpZiAobmV3UHJvcHMuYXhpcyAhPT0gdGhpcy5wcm9wcy5heGlzKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgUkFGKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5tZWFzdXJlKCkpIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5jb21wb25lbnREaWRVcGRhdGUoKSwgMSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgYXhpcyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBzaG93R3JpZCxcbiAgICAgIHRpY2tTaXplSW5uZXIsXG4gICAgICB0aWNrU2l6ZU91dGVyLFxuICAgICAgZGlzcGxheVxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB7IHJvdGF0aW9uIH0gPSB0aGlzXG5cbiAgICAvLyBSZW5kZXIgRGVwZW5kZW5jaWVzXG4gICAgaWYgKCFheGlzIHx8ICFkaXNwbGF5KSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHNjYWxlLFxuICAgICAgbWF4LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdmVydGljYWwsXG4gICAgICBmb3JtYXQsXG4gICAgICAvL1xuICAgICAgdGlja3MsXG4gICAgICByYW5nZTogW3JhbmdlMCwgcmFuZ2UxXSxcbiAgICAgIGRpcmVjdGlvbk11bHRpcGxpZXIsXG4gICAgICB0aWNrT2Zmc2V0LFxuICAgICAgZ3JpZE9mZnNldCxcbiAgICAgIHNwYWNpbmdcbiAgICB9ID0gYXhpc1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxBbmltYXRlXG4gICAgICAgIGRhdGE9e3tcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgbWF4LFxuICAgICAgICAgIHJhbmdlMCxcbiAgICAgICAgICByYW5nZTEsXG4gICAgICAgICAgZGlyZWN0aW9uTXVsdGlwbGllcixcbiAgICAgICAgICB0aWNrU2l6ZU91dGVyLFxuICAgICAgICAgIHRpY2tPZmZzZXQsXG4gICAgICAgICAgZ3JpZE9mZnNldCxcbiAgICAgICAgICBzcGFjaW5nXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHsoe1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBtYXgsXG4gICAgICAgICAgcmFuZ2UwLFxuICAgICAgICAgIHJhbmdlMSxcbiAgICAgICAgICBkaXJlY3Rpb25NdWx0aXBsaWVyLFxuICAgICAgICAgIHRpY2tTaXplT3V0ZXIsXG4gICAgICAgICAgdGlja09mZnNldCxcbiAgICAgICAgICBncmlkT2Zmc2V0LFxuICAgICAgICAgIHNwYWNpbmdcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgIGxldCBheGlzUGF0aFxuICAgICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBwb3NpdGlvbkxlZnQpIHtcbiAgICAgICAgICAgICAgYXhpc1BhdGggPSBgXG4gICAgICAgICAgICAgICAgTSAkey10aWNrU2l6ZU91dGVyfSwgJHtyYW5nZTB9XG4gICAgICAgICAgICAgICAgSCAwXG4gICAgICAgICAgICAgICAgViAke3JhbmdlMX1cbiAgICAgICAgICAgICAgICBIICR7LXRpY2tTaXplT3V0ZXJ9XG4gICAgICAgICAgICAgIGBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF4aXNQYXRoID0gYFxuICAgICAgICAgICAgICAgIE0gJHt0aWNrU2l6ZU91dGVyfSwgJHtyYW5nZTB9XG4gICAgICAgICAgICAgICAgSCAwXG4gICAgICAgICAgICAgICAgViAke3JhbmdlMX1cbiAgICAgICAgICAgICAgICBIICR7dGlja1NpemVPdXRlcn1cbiAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IHBvc2l0aW9uQm90dG9tKSB7XG4gICAgICAgICAgICAgIGF4aXNQYXRoID0gYFxuICAgICAgICAgICAgICAgIE0gMCwgJHt0aWNrU2l6ZU91dGVyfVxuICAgICAgICAgICAgICAgIFYgMFxuICAgICAgICAgICAgICAgIEggJHtyYW5nZTF9XG4gICAgICAgICAgICAgICAgViAke3RpY2tTaXplT3V0ZXJ9XG4gICAgICAgICAgICAgIGBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF4aXNQYXRoID0gYFxuICAgICAgICAgICAgICAgIE0gMCwgJHstdGlja1NpemVPdXRlcn1cbiAgICAgICAgICAgICAgICBWIDBcbiAgICAgICAgICAgICAgICBIICR7cmFuZ2UxfVxuICAgICAgICAgICAgICAgIFYgJHstdGlja1NpemVPdXRlcn1cbiAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8Z1xuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJBeGlzXCJcbiAgICAgICAgICAgICAgZmlsbD1cImJsYWNrXCJcbiAgICAgICAgICAgICAgZm9udFNpemU9XCIxMFwiXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk9XCJzYW5zLXNlcmlmXCJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtPXtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9PT0gcG9zaXRpb25SaWdodFxuICAgICAgICAgICAgICAgICAgPyB0cmFuc2xhdGVYKHdpZHRoKVxuICAgICAgICAgICAgICAgICAgOiBwb3NpdGlvbiA9PT0gcG9zaXRpb25Cb3R0b20gPyB0cmFuc2xhdGVZKGhlaWdodCkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8UGF0aFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImRvbWFpblwiXG4gICAgICAgICAgICAgICAgZD17YXhpc1BhdGh9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHN0cm9rZTogJyNhY2FjYWMnLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxJyxcbiAgICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8VHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIGRhdGE9e3RpY2tzfVxuICAgICAgICAgICAgICAgIGdldEtleT17KGQsIGkpID0+IFN0cmluZyhkKX1cbiAgICAgICAgICAgICAgICB1cGRhdGU9e2QgPT4gKHtcbiAgICAgICAgICAgICAgICAgIHRpY2s6IHNjYWxlKGQpLFxuICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogMSxcbiAgICAgICAgICAgICAgICAgIG1lYXN1cmVhYmxlOiAxLFxuICAgICAgICAgICAgICAgICAgcm90YXRpb25cbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICBlbnRlcj17ZCA9PiAoe1xuICAgICAgICAgICAgICAgICAgdGljazogdGhpcy5wcmV2QXhpcy5zY2FsZShkKSxcbiAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IDAsXG4gICAgICAgICAgICAgICAgICBtZWFzdXJlYWJsZTogMSxcbiAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiAwXG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgbGVhdmU9e2QgPT4gKHtcbiAgICAgICAgICAgICAgICAgIHRpY2s6IHNjYWxlKGQpLFxuICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogMCxcbiAgICAgICAgICAgICAgICAgIG1lYXN1cmVhYmxlOiAwLFxuICAgICAgICAgICAgICAgICAgcm90YXRpb25cbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICBpZ25vcmU9e1snbWVhc3VyZWFibGUnXX1cbiAgICAgICAgICAgICAgICBkdXJhdGlvbj17NTAwfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2ludGVycyA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgc2hvd0dyaWRMaW5lID0gc2hvd0dyaWRcblxuICAgICAgICAgICAgICAgICAgLy8gSWYgb3JkaW5hbCBhbmQgc2hvd0dyaWQgaXNuJ3QgZXhwbGljaXQsIGhpZGUgaXRcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnb3JkaW5hbCcgJiYgc2hvd0dyaWQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0dyaWRMaW5lID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPGdcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0aWNrc1wiXG4gICAgICAgICAgICAgICAgICAgICAgcmVmPXtlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsID0gZWxcbiAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAge2ludGVycy5tYXAoKGludGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2ludGVyLmtleX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2snICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGludGVyLnN0YXRlLm1lYXN1cmVhYmxlID8gJyAtbWVhc3VyZWFibGUnIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17dHJhbnNmb3JtKGludGVyLnN0YXRlLnRpY2spfVxuICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPExpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxPXt2ZXJ0aWNhbCA/IDAgOiB0aWNrT2Zmc2V0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDI9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGlyZWN0aW9uTXVsdGlwbGllciAqIHRpY2tTaXplSW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRpY2tPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxPXt2ZXJ0aWNhbCA/IHRpY2tPZmZzZXQgOiAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTI9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGlja09mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGlyZWN0aW9uTXVsdGlwbGllciAqIHRpY2tTaXplSW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eT17aW50ZXIuc3RhdGUudmlzaWJpbGl0eSAqIDAuMn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzaG93R3JpZExpbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxPXt2ZXJ0aWNhbCA/IDAgOiBncmlkT2Zmc2V0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Mj17dmVydGljYWwgPyBtYXggOiBncmlkT2Zmc2V0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MT17dmVydGljYWwgPyBncmlkT2Zmc2V0IDogMH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTI9e3ZlcnRpY2FsID8gZ3JpZE9mZnNldCA6IG1heH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5PXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlci5zdGF0ZS52aXNpYmlsaXR5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbmRleCAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCAhPT0gaW50ZXJzLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXIuZGF0YSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDAuNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDAuMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9e2ludGVyLnN0YXRlLnZpc2liaWxpdHl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZT17Zm9udFNpemV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm09e2BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlKCR7dmVydGljYWwgPyBkaXJlY3Rpb25NdWx0aXBsaWVyICogc3BhY2luZyA6IHRpY2tPZmZzZXR9LCAke3ZlcnRpY2FsID8gdGlja09mZnNldCA6IGRpcmVjdGlvbk11bHRpcGxpZXIgKiBzcGFjaW5nfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlKCR7LXJvdGF0aW9ufSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdjZW50cmFsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcG9zaXRpb24gPT09IHBvc2l0aW9uQm90dG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2hhbmdpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcG9zaXRpb24gPT09IHBvc2l0aW9uVG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdhbHBoYWJldGljJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnY2VudHJhbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2VuZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBvc2l0aW9uID09PSBwb3NpdGlvblJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3N0YXJ0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBvc2l0aW9uID09PSBwb3NpdGlvbkxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2VuZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Zm9ybWF0KGludGVyLmRhdGEpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPC9UcmFuc2l0aW9uPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgIDwvQW5pbWF0ZT5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29ubmVjdChcbiAgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9ycyA9IHtcbiAgICAgIGdyaWRXaWR0aDogU2VsZWN0b3JzLmdyaWRXaWR0aCgpLFxuICAgICAgZ3JpZEhlaWdodDogU2VsZWN0b3JzLmdyaWRIZWlnaHQoKSxcbiAgICAgIHByaW1hcnlBeGlzOiBTZWxlY3RvcnMucHJpbWFyeUF4aXMoKVxuICAgIH1cbiAgICByZXR1cm4gKHN0YXRlLCBwcm9wcykgPT4ge1xuICAgICAgY29uc3QgeyB0eXBlLCBwb3NpdGlvbiB9ID0gcHJvcHNcblxuICAgICAgY29uc3QgaWQgPSBgJHt0eXBlfV8ke3Bvc2l0aW9ufWBcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIG1hdGVyaWFsaXplZERhdGE6IHN0YXRlLm1hdGVyaWFsaXplZERhdGEsXG4gICAgICAgIHdpZHRoOiBzZWxlY3RvcnMuZ3JpZFdpZHRoKHN0YXRlKSxcbiAgICAgICAgaGVpZ2h0OiBzZWxlY3RvcnMuZ3JpZEhlaWdodChzdGF0ZSksXG4gICAgICAgIHByaW1hcnlBeGlzOiBzZWxlY3RvcnMucHJpbWFyeUF4aXMoc3RhdGUpLFxuICAgICAgICBheGlzOiBzdGF0ZS5heGVzICYmIHN0YXRlLmF4ZXNbaWRdXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB7XG4gICAgZmlsdGVyOiAob2xkU3RhdGUsIG5ld1N0YXRlLCBtZXRhKSA9PiB7XG4gICAgICByZXR1cm4gbWV0YS50eXBlICE9PSAnY3Vyc29yJ1xuICAgIH1cbiAgfVxuKShBeGlzKVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVYKHgpIHtcbiAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHggKyAnLCAwKSdcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlWSh5KSB7XG4gIHJldHVybiAndHJhbnNsYXRlKDAsICcgKyB5ICsgJyknXG59XG4iXX0=