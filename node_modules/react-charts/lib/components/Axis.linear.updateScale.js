'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = updateScale;

var _d3Scale = require('d3-scale');

var _Axis = require('./Axis');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
//


var scales = {
  linear: _d3Scale.scaleLinear,
  log: _d3Scale.scaleLog,
  time: _d3Scale.scaleTime,
  ordinal: _d3Scale.scaleBand
};

var detectVertical = function detectVertical(position) {
  return [_Axis.positionLeft, _Axis.positionRight].indexOf(position) > -1;
};
var detectRTL = function detectRTL(position) {
  return [_Axis.positionTop, _Axis.positionRight].indexOf(position) > -1;
};

function updateScale(props) {
  var id = props.id,
      type = props.type,
      position = props.position,
      invert = props.invert,
      primary = props.primary,
      stacked = props.stacked,
      innerPadding = props.innerPadding,
      outerPadding = props.outerPadding,
      tickArguments = props.tickArguments,
      tickValues = props.tickValues,
      tickFormat = props.tickFormat,
      tickPadding = props.tickPadding,
      tickSizeInner = props.tickSizeInner,
      materializedData = props.materializedData,
      width = props.width,
      height = props.height,
      primaryAxis = props.primaryAxis;

  // We need the data to proceed

  if (!materializedData) {
    return;
  }

  // If this axis is secondary, we need the primaryAxis to proceed
  if (!primary && !primaryAxis) {
    return;
  }

  // Detect some settings
  var valueKey = primary ? 'primary' : 'secondary';
  var groupKey = !primary && 'primary';
  var vertical = detectVertical(position);
  var RTL = primary && detectRTL(position); // Right to left OR top to bottom

  // TODO: Any sorting needs to happen here, else the min/max's might not line up correctly

  // First we need to find unique values, min/max values and negative/positive totals
  var uniqueVals = [];
  var min = 0;
  var max = 0;
  var datumValues = {};
  var negativeTotal = 0;
  var positiveTotal = 0;
  var domain = void 0;
  var total = void 0;

  if (type === 'ordinal') {
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d) {
        if (uniqueVals.indexOf(d) === -1) {
          uniqueVals.push(d);
        }
      });
    });
    domain = invert ? [].concat(uniqueVals).reverse() : uniqueVals;
  } else if (type === 'time') {
    var firstRow = materializedData[0].data[0] || {};
    min = max = firstRow[valueKey];
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return +d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.data[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      var seriesMin = Math.min.apply(Math, _toConsumableArray(seriesValues));
      var seriesMax = Math.max.apply(Math, _toConsumableArray(seriesValues));
      min = Math.min(min, seriesMin);
      max = Math.max(max, seriesMax);
    });
    domain = invert ? [max, min] : [min, max];
  } else {
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.data[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      var seriesMin = Math.min.apply(Math, _toConsumableArray(seriesValues));
      var seriesMax = Math.max.apply(Math, _toConsumableArray(seriesValues));
      min = Math.min(min, seriesMin);
      max = Math.max(max, seriesMax);
    });
    if (stacked) {
      // If we're stacking, calculate and use the max and min values for the largest stack
      ;
      var _Object$keys$map$redu = Object.keys(datumValues).map(function (d) {
        return datumValues[d];
      }).reduce(function (totals, vals) {
        var positive = vals.filter(function (d) {
          return d >= 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        var negative = vals.filter(function (d) {
          return d < 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        return [positive > totals[0] ? positive : totals[0], negative < totals[1] ? negative : totals[1]];
      }, [0, 0]);

      var _Object$keys$map$redu2 = _slicedToArray(_Object$keys$map$redu, 2);

      positiveTotal = _Object$keys$map$redu2[0];
      negativeTotal = _Object$keys$map$redu2[1];

      domain = invert ? [positiveTotal, negativeTotal] : [negativeTotal, positiveTotal];
    } else {
      // If we're not stacking, use the min and max values
      domain = invert ? [max, min] : [min, max];
    }
  }

  // Now we need to figure out the range
  var range = vertical ? invert ? [0, height] : [height, 0] // If the axis is inverted, swap the range, too
  : invert ? [width, 0] : [0, width];

  // var arc = d3.svg.arc()
  //   .outerRadius(radius - 10)
  //   .innerRadius(radius - 70);

  if (!primary) {
    // Secondary axes are usually dependent on primary axes for orientation, so if the
    // primaryAxis is in RTL mode, we need to reverse the range on this secondary axis
    // to match the origin of the primary axis
    if (primaryAxis.RTL) {
      range = range.reverse();
    }
  }

  // The the scale a home
  var scale = void 0;

  // If this is an ordinal or other primary axis, it needs to be able to display bars.
  var bandScale = void 0;
  var barSize = 1;
  var stepSize = 0;

  if (type === 'ordinal' || primary) {
    // Calculate a band axis that is similar and pass down the bandwidth
    // just in case.
    bandScale = (0, _d3Scale.scaleBand)().domain(materializedData.reduce(function (prev, current) {
      return current.data.length > prev.length ? current.data : prev;
    }, []).map(function (d) {
      return d.primary;
    })).rangeRound(range, 0.1).padding(0);

    if (type === 'ordinal') {
      bandScale.paddingOuter(outerPadding).paddingInner(innerPadding);
      barSize = bandScale.bandwidth();
    } else {
      barSize = bandScale.bandwidth();
    }

    stepSize = bandScale.step();
  }

  if (type === 'ordinal') {
    // If it's ordinal, just assign the bandScale we made
    scale = bandScale;
  } else {
    // Otherwise, create a new scale of the appropriate type
    scale = scales[type]();
  }

  // Set the domain
  scale.domain(domain);

  // Now set the range
  scale.range(range);

  // If we're not using an ordinal scale, round the ticks to "nice" values
  if (type !== 'ordinal') {
    scale.nice();
  }

  // Pass down the axis config (including the scale itself) for posterity
  var axis = {
    type: type,
    scale: scale,
    uniqueVals: uniqueVals,
    primary: primary,
    invert: invert,
    vertical: vertical,
    RTL: RTL,
    position: position,
    stacked: stacked,
    barSize: barSize,
    stepSize: stepSize,
    domain: domain,
    range: range,
    max: position === _Axis.positionBottom ? -height : position === _Axis.positionLeft ? width : position === _Axis.positionTop ? height : -width,
    directionMultiplier: position === _Axis.positionTop || position === _Axis.positionLeft ? -1 : 1,
    transform: !vertical ? translateX : translateY,
    ticks: this.ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
    format: tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity : tickFormat,
    spacing: Math.max(tickSizeInner, 0) + tickPadding
  };

  if (type === 'ordinal') {
    axis.gridOffset = -(axis.stepSize * innerPadding) / 2;
    axis.tickOffset = axis.barSize / 2;
    axis.barOffset = 0;
  } else {
    axis.tickOffset = 0;
    axis.barOffset = -axis.barSize / 2;
  }

  // Make sure we start with a prevAxis
  this.prevAxis = this.prevAxis || axis;

  this.props.dispatch(function (state) {
    return _extends({}, state, {
      axes: _extends({}, state.axes, _defineProperty({}, id, axis))
    });
  }, {
    type: 'axisUpdateScale'
  });
}

function identity(x) {
  return x;
}

function translateX(x) {
  return 'translate(' + x + ', 0)';
}

function translateY(y) {
  return 'translate(0, ' + y + ')';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0F4aXMubGluZWFyLnVwZGF0ZVNjYWxlLmpzIl0sIm5hbWVzIjpbInVwZGF0ZVNjYWxlIiwic2NhbGVzIiwibGluZWFyIiwibG9nIiwidGltZSIsIm9yZGluYWwiLCJkZXRlY3RWZXJ0aWNhbCIsImluZGV4T2YiLCJwb3NpdGlvbiIsImRldGVjdFJUTCIsInByb3BzIiwiaWQiLCJ0eXBlIiwiaW52ZXJ0IiwicHJpbWFyeSIsInN0YWNrZWQiLCJpbm5lclBhZGRpbmciLCJvdXRlclBhZGRpbmciLCJ0aWNrQXJndW1lbnRzIiwidGlja1ZhbHVlcyIsInRpY2tGb3JtYXQiLCJ0aWNrUGFkZGluZyIsInRpY2tTaXplSW5uZXIiLCJtYXRlcmlhbGl6ZWREYXRhIiwid2lkdGgiLCJoZWlnaHQiLCJwcmltYXJ5QXhpcyIsInZhbHVlS2V5IiwiZ3JvdXBLZXkiLCJ2ZXJ0aWNhbCIsIlJUTCIsInVuaXF1ZVZhbHMiLCJtaW4iLCJtYXgiLCJkYXR1bVZhbHVlcyIsIm5lZ2F0aXZlVG90YWwiLCJwb3NpdGl2ZVRvdGFsIiwiZG9tYWluIiwidG90YWwiLCJmb3JFYWNoIiwic2VyaWVzVmFsdWVzIiwic2VyaWVzIiwiZGF0YSIsIm1hcCIsImQiLCJwdXNoIiwicmV2ZXJzZSIsImZpcnN0Um93IiwiaSIsImtleSIsInNlcmllc01pbiIsIk1hdGgiLCJzZXJpZXNNYXgiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwidG90YWxzIiwidmFscyIsInBvc2l0aXZlIiwiZmlsdGVyIiwiZHMiLCJuZWdhdGl2ZSIsInJhbmdlIiwic2NhbGUiLCJiYW5kU2NhbGUiLCJiYXJTaXplIiwic3RlcFNpemUiLCJwcmV2IiwiY3VycmVudCIsImxlbmd0aCIsInJhbmdlUm91bmQiLCJwYWRkaW5nIiwicGFkZGluZ091dGVyIiwicGFkZGluZ0lubmVyIiwiYmFuZHdpZHRoIiwic3RlcCIsIm5pY2UiLCJheGlzIiwiZGlyZWN0aW9uTXVsdGlwbGllciIsInRyYW5zZm9ybSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwidGlja3MiLCJhcHBseSIsImZvcm1hdCIsImlkZW50aXR5Iiwic3BhY2luZyIsImdyaWRPZmZzZXQiLCJ0aWNrT2Zmc2V0IiwiYmFyT2Zmc2V0IiwicHJldkF4aXMiLCJkaXNwYXRjaCIsInN0YXRlIiwiYXhlcyIsIngiLCJ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O2tCQXFCd0JBLFc7O0FBckJ4Qjs7QUFFQTs7Ozs7QUFEQTs7O0FBUUEsSUFBTUMsU0FBUztBQUNiQyw4QkFEYTtBQUViQyx3QkFGYTtBQUdiQywwQkFIYTtBQUliQztBQUphLENBQWY7O0FBT0EsSUFBTUMsaUJBQWlCLFNBQWpCQSxjQUFpQjtBQUFBLFNBQ3JCLDBDQUE4QkMsT0FBOUIsQ0FBc0NDLFFBQXRDLElBQWtELENBQUMsQ0FEOUI7QUFBQSxDQUF2QjtBQUVBLElBQU1DLFlBQVksU0FBWkEsU0FBWTtBQUFBLFNBQ2hCLHlDQUE2QkYsT0FBN0IsQ0FBcUNDLFFBQXJDLElBQWlELENBQUMsQ0FEbEM7QUFBQSxDQUFsQjs7QUFHZSxTQUFTUixXQUFULENBQXFCVSxLQUFyQixFQUE0QjtBQUFBLE1BR3ZDQyxFQUh1QyxHQXNCckNELEtBdEJxQyxDQUd2Q0MsRUFIdUM7QUFBQSxNQUt2Q0MsSUFMdUMsR0FzQnJDRixLQXRCcUMsQ0FLdkNFLElBTHVDO0FBQUEsTUFNdkNKLFFBTnVDLEdBc0JyQ0UsS0F0QnFDLENBTXZDRixRQU51QztBQUFBLE1BT3ZDSyxNQVB1QyxHQXNCckNILEtBdEJxQyxDQU92Q0csTUFQdUM7QUFBQSxNQVF2Q0MsT0FSdUMsR0FzQnJDSixLQXRCcUMsQ0FRdkNJLE9BUnVDO0FBQUEsTUFTdkNDLE9BVHVDLEdBc0JyQ0wsS0F0QnFDLENBU3ZDSyxPQVR1QztBQUFBLE1BVXZDQyxZQVZ1QyxHQXNCckNOLEtBdEJxQyxDQVV2Q00sWUFWdUM7QUFBQSxNQVd2Q0MsWUFYdUMsR0FzQnJDUCxLQXRCcUMsQ0FXdkNPLFlBWHVDO0FBQUEsTUFZdkNDLGFB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LEdBQWI7O0FBa0NBLE1BQUlULFNBQVMsU0FBYixFQUF3QjtBQUN0QmlFLFNBQUtVLFVBQUwsR0FBa0IsRUFBRVYsS0FBS1gsUUFBTCxHQUFnQmxELFlBQWxCLElBQWtDLENBQXBEO0FBQ0E2RCxTQUFLVyxVQUFMLEdBQWtCWCxLQUFLWixPQUFMLEdBQWUsQ0FBakM7QUFDQVksU0FBS1ksU0FBTCxHQUFpQixDQUFqQjtBQUNELEdBSkQsTUFJTztBQUNMWixTQUFLVyxVQUFMLEdBQWtCLENBQWxCO0FBQ0FYLFNBQUtZLFNBQUwsR0FBaUIsQ0FBQ1osS0FBS1osT0FBTixHQUFnQixDQUFqQztBQUNEOztBQUVEO0FBQ0EsT0FBS3lCLFFBQUwsR0FBZ0IsS0FBS0EsUUFBTCxJQUFpQmIsSUFBakM7O0FBRUEsT0FBS25FLEtBQUwsQ0FBV2lGLFFBQVgsQ0FDRTtBQUFBLHdCQUNLQyxLQURMO0FBRUVDLHlCQUNLRCxNQUFNQyxJQURYLHNCQUVHbEYsRUFGSCxFQUVRa0UsSUFGUjtBQUZGO0FBQUEsR0FERixFQVFFO0FBQ0VqRSxVQUFNO0FBRFIsR0FSRjtBQVlEOztBQUVELFNBQVN5RSxRQUFULENBQWtCUyxDQUFsQixFQUFxQjtBQUNuQixTQUFPQSxDQUFQO0FBQ0Q7O0FBRUQsU0FBU2QsVUFBVCxDQUFvQmMsQ0FBcEIsRUFBdUI7QUFDckIsU0FBTyxlQUFlQSxDQUFmLEdBQW1CLE1BQTFCO0FBQ0Q7O0FBRUQsU0FBU2IsVUFBVCxDQUFvQmMsQ0FBcEIsRUFBdUI7QUFDckIsU0FBTyxrQkFBa0JBLENBQWxCLEdBQXNCLEdBQTdCO0FBQ0QiLCJmaWxlIjoiQXhpcy5saW5lYXIudXBkYXRlU2NhbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVMb2csIHNjYWxlVGltZSwgc2NhbGVCYW5kIH0gZnJvbSAnZDMtc2NhbGUnXG4vL1xuaW1wb3J0IHtcbiAgcG9zaXRpb25Ub3AsXG4gIHBvc2l0aW9uTGVmdCxcbiAgcG9zaXRpb25SaWdodCxcbiAgcG9zaXRpb25Cb3R0b20sXG59IGZyb20gJy4vQXhpcydcblxuY29uc3Qgc2NhbGVzID0ge1xuICBsaW5lYXI6IHNjYWxlTGluZWFyLFxuICBsb2c6IHNjYWxlTG9nLFxuICB0aW1lOiBzY2FsZVRpbWUsXG4gIG9yZGluYWw6IHNjYWxlQmFuZCxcbn1cblxuY29uc3QgZGV0ZWN0VmVydGljYWwgPSBwb3NpdGlvbiA9PlxuICBbcG9zaXRpb25MZWZ0LCBwb3NpdGlvblJpZ2h0XS5pbmRleE9mKHBvc2l0aW9uKSA+IC0xXG5jb25zdCBkZXRlY3RSVEwgPSBwb3NpdGlvbiA9PlxuICBbcG9zaXRpb25Ub3AsIHBvc2l0aW9uUmlnaHRdLmluZGV4T2YocG9zaXRpb24pID4gLTFcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlU2NhbGUocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIC8vIENvbXB1dGVkXG4gICAgaWQsXG4gICAgLy8gUHJvcHNcbiAgICB0eXBlLFxuICAgIHBvc2l0aW9uLFxuICAgIGludmVydCxcbiAgICBwcmltYXJ5LFxuICAgIHN0YWNrZWQsXG4gICAgaW5uZXJQYWRkaW5nLFxuICAgIG91dGVyUGFkZGluZyxcbiAgICB0aWNrQXJndW1lbnRzLFxuICAgIHRpY2tWYWx1ZXMsXG4gICAgdGlja0Zvcm1hdCxcbiAgICB0aWNrUGFkZGluZyxcbiAgICB0aWNrU2l6ZUlubmVyLFxuICAgIC8vIENvbnRleHRcbiAgICBtYXRlcmlhbGl6ZWREYXRhLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBwcmltYXJ5QXhpcyxcbiAgfSA9IHByb3BzXG5cbiAgLy8gV2UgbmVlZCB0aGUgZGF0YSB0byBwcm9jZWVkXG4gIGlmICghbWF0ZXJpYWxpemVkRGF0YSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gSWYgdGhpcyBheGlzIGlzIHNlY29uZGFyeSwgd2UgbmVlZCB0aGUgcHJpbWFyeUF4aXMgdG8gcHJvY2VlZFxuICBpZiAoIXByaW1hcnkgJiYgIXByaW1hcnlBeGlzKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBEZXRlY3Qgc29tZSBzZXR0aW5nc1xuICBjb25zdCB2YWx1ZUtleSA9IHByaW1hcnkgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5J1xuICBjb25zdCBncm91cEtleSA9ICFwcmltYXJ5ICYmICdwcmltYXJ5J1xuICBjb25zdCB2ZXJ0aWNhbCA9IGRldGVjdFZlcnRpY2FsKHBvc2l0aW9uKVxuICBjb25zdCBSVEwgPSBwcmltYXJ5ICYmIGRldGVjdFJUTChwb3NpdGlvbikgLy8gUmlnaHQgdG8gbGVmdCBPUiB0b3AgdG8gYm90dG9tXG5cbiAgLy8gVE9ETzogQW55IHNvcnRpbmcgbmVlZHMgdG8gaGFwcGVuIGhlcmUsIGVsc2UgdGhlIG1pbi9tYXgncyBtaWdodCBub3QgbGluZSB1cCBjb3JyZWN0bHlcblxuICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGZpbmQgdW5pcXVlIHZhbHVlcywgbWluL21heCB2YWx1ZXMgYW5kIG5lZ2F0aXZlL3Bvc2l0aXZlIHRvdGFsc1xuICBsZXQgdW5pcXVlVmFscyA9IFtdXG4gIGxldCBtaW4gPSAwXG4gIGxldCBtYXggPSAwXG4gIGxldCBkYXR1bVZhbHVlcyA9IHt9XG4gIGxldCBuZWdhdGl2ZVRvdGFsID0gMFxuICBsZXQgcG9zaXRpdmVUb3RhbCA9IDBcbiAgbGV0IGRvbWFpblxuICBsZXQgdG90YWxcblxuICBpZiAodHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgbWF0ZXJpYWxpemVkRGF0YS5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICBjb25zdCBzZXJpZXNWYWx1ZXMgPSBzZXJpZXMuZGF0YS5tYXAoZCA9PiBkW3ZhbHVlS2V5XSlcbiAgICAgIHNlcmllc1ZhbHVlcy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICBpZiAodW5pcXVlVmFscy5pbmRleE9mKGQpID09PSAtMSkge1xuICAgICAgICAgIHVuaXF1ZVZhbHMucHVzaChkKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gICAgZG9tYWluID0gaW52ZXJ0ID8gWy4uLnVuaXF1ZVZhbHNdLnJldmVyc2UoKSA6IHVuaXF1ZVZhbHNcbiAgfSBlbHNlIGlmICh0eXBlID09PSAndGltZScpIHtcbiAgICBjb25zdCBmaXJzdFJvdyA9IG1hdGVyaWFsaXplZERhdGFbMF0uZGF0YVswXSB8fCB7fVxuICAgIG1pbiA9IG1heCA9IGZpcnN0Um93W3ZhbHVlS2V5XVxuICAgIG1hdGVyaWFsaXplZERhdGEuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzVmFsdWVzID0gc2VyaWVzLmRhdGEubWFwKGQgPT4gK2RbdmFsdWVLZXldKVxuICAgICAgc2VyaWVzVmFsdWVzLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ3JvdXBLZXkgPyBzZXJpZXMuZGF0YVtpXVtncm91cEtleV0gOiBpXG4gICAgICAgIGRhdHVtVmFsdWVzW2tleV0gPSBbLi4uKGRhdHVtVmFsdWVzW2tleV0gfHwgW10pLCBkXVxuICAgICAgfSlcbiAgICAgIGNvbnN0IHNlcmllc01pbiA9IE1hdGgubWluKC4uLnNlcmllc1ZhbHVlcylcbiAgICAgIGNvbnN0IHNlcmllc01heCA9IE1hdGgubWF4KC4uLnNlcmllc1ZhbHVlcylcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgc2VyaWVzTWluKVxuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBzZXJpZXNNYXgpXG4gICAgfSlcbiAgICBkb21haW4gPSBpbnZlcnQgPyBbbWF4LCBtaW5dIDogW21pbiwgbWF4XVxuICB9IGVsc2Uge1xuICAgIG1hdGVyaWFsaXplZERhdGEuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzVmFsdWVzID0gc2VyaWVzLmRhdGEubWFwKGQgPT4gZFt2YWx1ZUtleV0pXG4gICAgICBzZXJpZXNWYWx1ZXMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBncm91cEtleSA/IHNlcmllcy5kYXRhW2ldW2dyb3VwS2V5XSA6IGlcbiAgICAgICAgZGF0dW1WYWx1ZXNba2V5XSA9IFsuLi4oZGF0dW1WYWx1ZXNba2V5XSB8fCBbXSksIGRdXG4gICAgICB9KVxuICAgICAgY29uc3Qgc2VyaWVzTWluID0gTWF0aC5taW4oLi4uc2VyaWVzVmFsdWVzKVxuICAgICAgY29uc3Qgc2VyaWVzTWF4ID0gTWF0aC5tYXgoLi4uc2VyaWVzVmFsdWVzKVxuICAgICAgbWluID0gTWF0aC5taW4obWluLCBzZXJpZXNNaW4pXG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIHNlcmllc01heClcbiAgICB9KVxuICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBzdGFja2luZywgY2FsY3VsYXRlIGFuZCB1c2UgdGhlIG1heCBhbmQgbWluIHZhbHVlcyBmb3IgdGhlIGxhcmdlc3Qgc3RhY2tcbiAgICAgIDtbcG9zaXRpdmVUb3RhbCwgbmVnYXRpdmVUb3RhbF0gPSBPYmplY3Qua2V5cyhkYXR1bVZhbHVlcylcbiAgICAgICAgLm1hcChkID0+IGRhdHVtVmFsdWVzW2RdKVxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgICh0b3RhbHMsIHZhbHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aXZlID0gdmFsc1xuICAgICAgICAgICAgICAuZmlsdGVyKGQgPT4gZCA+PSAwKVxuICAgICAgICAgICAgICAucmVkdWNlKChkcywgZCkgPT4gZHMgKyBkLCAwKVxuICAgICAgICAgICAgY29uc3QgbmVnYXRpdmUgPSB2YWxzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZCA9PiBkIDwgMClcbiAgICAgICAgICAgICAgLnJlZHVjZSgoZHMsIGQpID0+IGRzICsgZCwgMClcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIHBvc2l0aXZlID4gdG90YWxzWzBdID8gcG9zaXRpdmUgOiB0b3RhbHNbMF0sXG4gICAgICAgICAgICAgIG5lZ2F0aXZlIDwgdG90YWxzWzFdID8gbmVnYXRpdmUgOiB0b3RhbHNbMV0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbMCwgMF1cbiAgICAgICAgKVxuICAgICAgZG9tYWluID0gaW52ZXJ0XG4gICAgICAgID8gW3Bvc2l0aXZlVG90YWwsIG5lZ2F0aXZlVG90YWxdXG4gICAgICAgIDogW25lZ2F0aXZlVG90YWwsIHBvc2l0aXZlVG90YWxdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3JlIG5vdCBzdGFja2luZywgdXNlIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICAgIGRvbWFpbiA9IGludmVydCA/IFttYXgsIG1pbl0gOiBbbWluLCBtYXhdXG4gICAgfVxuICB9XG5cbiAgLy8gTm93IHdlIG5lZWQgdG8gZmlndXJlIG91dCB0aGUgcmFuZ2VcbiAgbGV0IHJhbmdlID0gdmVydGljYWxcbiAgICA/IGludmVydCA/IFswLCBoZWlnaHRdIDogW2hlaWdodCwgMF0gLy8gSWYgdGhlIGF4aXMgaXMgaW52ZXJ0ZWQsIHN3YXAgdGhlIHJhbmdlLCB0b29cbiAgICA6IGludmVydCA/IFt3aWR0aCwgMF0gOiBbMCwgd2lkdGhdXG5cbiAgLy8gdmFyIGFyYyA9IGQzLnN2Zy5hcmMoKVxuICAvLyAgIC5vdXRlclJhZGl1cyhyYWRpdXMgLSAxMClcbiAgLy8gICAuaW5uZXJSYWRpdXMocmFkaXVzIC0gNzApO1xuXG4gIGlmICghcHJpbWFyeSkge1xuICAgIC8vIFNlY29uZGFyeSBheGVzIGFyZSB1c3VhbGx5IGRlcGVuZGVudCBvbiBwcmltYXJ5IGF4ZXMgZm9yIG9yaWVudGF0aW9uLCBzbyBpZiB0aGVcbiAgICAvLyBwcmltYXJ5QXhpcyBpcyBpbiBSVEwgbW9kZSwgd2UgbmVlZCB0byByZXZlcnNlIHRoZSByYW5nZSBvbiB0aGlzIHNlY29uZGFyeSBheGlzXG4gICAgLy8gdG8gbWF0Y2ggdGhlIG9yaWdpbiBvZiB0aGUgcHJpbWFyeSBheGlzXG4gICAgaWYgKHByaW1hcnlBeGlzLlJUTCkge1xuICAgICAgcmFuZ2UgPSByYW5nZS5yZXZlcnNlKClcbiAgICB9XG4gIH1cblxuICAvLyBUaGUgdGhlIHNjYWxlIGEgaG9tZVxuICBsZXQgc2NhbGVcblxuICAvLyBJZiB0aGlzIGlzIGFuIG9yZGluYWwgb3Igb3RoZXIgcHJpbWFyeSBheGlzLCBpdCBuZWVkcyB0byBiZSBhYmxlIHRvIGRpc3BsYXkgYmFycy5cbiAgbGV0IGJhbmRTY2FsZVxuICBsZXQgYmFyU2l6ZSA9IDFcbiAgbGV0IHN0ZXBTaXplID0gMFxuXG4gIGlmICh0eXBlID09PSAnb3JkaW5hbCcgfHwgcHJpbWFyeSkge1xuICAgIC8vIENhbGN1bGF0ZSBhIGJhbmQgYXhpcyB0aGF0IGlzIHNpbWlsYXIgYW5kIHBhc3MgZG93biB0aGUgYmFuZHdpZHRoXG4gICAgLy8ganVzdCBpbiBjYXNlLlxuICAgIGJhbmRTY2FsZSA9IHNjYWxlQmFuZCgpXG4gICAgICAuZG9tYWluKFxuICAgICAgICBtYXRlcmlhbGl6ZWREYXRhXG4gICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgIChwcmV2LCBjdXJyZW50KSA9PlxuICAgICAgICAgICAgICBjdXJyZW50LmRhdGEubGVuZ3RoID4gcHJldi5sZW5ndGggPyBjdXJyZW50LmRhdGEgOiBwcmV2LFxuICAgICAgICAgICAgW11cbiAgICAgICAgICApXG4gICAgICAgICAgLm1hcChkID0+IGQucHJpbWFyeSlcbiAgICAgIClcbiAgICAgIC5yYW5nZVJvdW5kKHJhbmdlLCAwLjEpXG4gICAgICAucGFkZGluZygwKVxuXG4gICAgaWYgKHR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgYmFuZFNjYWxlLnBhZGRpbmdPdXRlcihvdXRlclBhZGRpbmcpLnBhZGRpbmdJbm5lcihpbm5lclBhZGRpbmcpXG4gICAgICBiYXJTaXplID0gYmFuZFNjYWxlLmJhbmR3aWR0aCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJhclNpemUgPSBiYW5kU2NhbGUuYmFuZHdpZHRoKClcbiAgICB9XG5cbiAgICBzdGVwU2l6ZSA9IGJhbmRTY2FsZS5zdGVwKClcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAvLyBJZiBpdCdzIG9yZGluYWwsIGp1c3QgYXNzaWduIHRoZSBiYW5kU2NhbGUgd2UgbWFkZVxuICAgIHNjYWxlID0gYmFuZFNjYWxlXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYSBuZXcgc2NhbGUgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGVcbiAgICBzY2FsZSA9IHNjYWxlc1t0eXBlXSgpXG4gIH1cblxuICAvLyBTZXQgdGhlIGRvbWFpblxuICBzY2FsZS5kb21haW4oZG9tYWluKVxuXG4gIC8vIE5vdyBzZXQgdGhlIHJhbmdlXG4gIHNjYWxlLnJhbmdlKHJhbmdlKVxuXG4gIC8vIElmIHdlJ3JlIG5vdCB1c2luZyBhbiBvcmRpbmFsIHNjYWxlLCByb3VuZCB0aGUgdGlja3MgdG8gXCJuaWNlXCIgdmFsdWVzXG4gIGlmICh0eXBlICE9PSAnb3JkaW5hbCcpIHtcbiAgICBzY2FsZS5uaWNlKClcbiAgfVxuXG4gIC8vIFBhc3MgZG93biB0aGUgYXhpcyBjb25maWcgKGluY2x1ZGluZyB0aGUgc2NhbGUgaXRzZWxmKSBmb3IgcG9zdGVyaXR5XG4gIGNvbnN0IGF4aXMgPSB7XG4gICAgdHlwZSxcbiAgICBzY2FsZSxcbiAgICB1bmlxdWVWYWxzLFxuICAgIHByaW1hcnksXG4gICAgaW52ZXJ0LFxuICAgIHZlcnRpY2FsLFxuICAgIFJUTCxcbiAgICBwb3NpdGlvbixcbiAgICBzdGFja2VkLFxuICAgIGJhclNpemUsXG4gICAgc3RlcFNpemUsXG4gICAgZG9tYWluLFxuICAgIHJhbmdlLFxuICAgIG1heDogcG9zaXRpb24gPT09IHBvc2l0aW9uQm90dG9tXG4gICAgICA/IC1oZWlnaHRcbiAgICAgIDogcG9zaXRpb24gPT09IHBvc2l0aW9uTGVmdFxuICAgICAgICAgID8gd2lkdGhcbiAgICAgICAgICA6IHBvc2l0aW9uID09PSBwb3NpdGlvblRvcCA/IGhlaWdodCA6IC13aWR0aCxcbiAgICBkaXJlY3Rpb25NdWx0aXBsaWVyOiBwb3NpdGlvbiA9PT0gcG9zaXRpb25Ub3AgfHwgcG9zaXRpb24gPT09IHBvc2l0aW9uTGVmdFxuICAgICAgPyAtMVxuICAgICAgOiAxLFxuICAgIHRyYW5zZm9ybTogIXZlcnRpY2FsID8gdHJhbnNsYXRlWCA6IHRyYW5zbGF0ZVksXG4gICAgdGlja3M6ICh0aGlzLnRpY2tzID0gdGlja1ZhbHVlcyA9PSBudWxsXG4gICAgICA/IHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogc2NhbGUuZG9tYWluKClcbiAgICAgIDogdGlja1ZhbHVlcyksXG4gICAgZm9ybWF0OiB0aWNrRm9ybWF0ID09IG51bGxcbiAgICAgID8gc2NhbGUudGlja0Zvcm1hdFxuICAgICAgICAgID8gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cylcbiAgICAgICAgICA6IGlkZW50aXR5XG4gICAgICA6IHRpY2tGb3JtYXQsXG4gICAgc3BhY2luZzogTWF0aC5tYXgodGlja1NpemVJbm5lciwgMCkgKyB0aWNrUGFkZGluZyxcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBheGlzLmdyaWRPZmZzZXQgPSAtKGF4aXMuc3RlcFNpemUgKiBpbm5lclBhZGRpbmcpIC8gMlxuICAgIGF4aXMudGlja09mZnNldCA9IGF4aXMuYmFyU2l6ZSAvIDJcbiAgICBheGlzLmJhck9mZnNldCA9IDBcbiAgfSBlbHNlIHtcbiAgICBheGlzLnRpY2tPZmZzZXQgPSAwXG4gICAgYXhpcy5iYXJPZmZzZXQgPSAtYXhpcy5iYXJTaXplIC8gMlxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIHN0YXJ0IHdpdGggYSBwcmV2QXhpc1xuICB0aGlzLnByZXZBeGlzID0gdGhpcy5wcmV2QXhpcyB8fCBheGlzXG5cbiAgdGhpcy5wcm9wcy5kaXNwYXRjaChcbiAgICBzdGF0ZSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBheGVzOiB7XG4gICAgICAgIC4uLnN0YXRlLmF4ZXMsXG4gICAgICAgIFtpZF06IGF4aXMsXG4gICAgICB9LFxuICAgIH0pLFxuICAgIHtcbiAgICAgIHR5cGU6ICdheGlzVXBkYXRlU2NhbGUnLFxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVgoeCkge1xuICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeCArICcsIDApJ1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVZKHkpIHtcbiAgcmV0dXJuICd0cmFuc2xhdGUoMCwgJyArIHkgKyAnKSdcbn1cbiJdfQ==