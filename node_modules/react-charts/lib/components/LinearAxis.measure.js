'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = measure;

var _Axis = require('./Axis');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var fontSize = 10;

var getPixel = function getPixel(d) {
  return d;
};
var radiansToDegrees = function radiansToDegrees(r) {
  return r * (180 / Math.PI);
};

function measure() {
  // Measure finds the amount of overflow this axis produces and
  // updates the margins to ensure that the axis is visibility
  // Unfortunately, this currently happens after a render, but potentially
  // could happen pre-render if we could reliably predict the size of the
  // labels before they render. Considering that ticks could be anything,
  // even a react component, this could get very tough.
  var _props = this.props,
      axis = _props.axis,
      tickSizeInner = _props.tickSizeInner,
      tickSizeOuter = _props.tickSizeOuter,
      tickPadding = _props.tickPadding,
      maxLabelRotation = _props.maxLabelRotation,
      position = _props.position,
      dispatch = _props.dispatch;
  var rotation = this.rotation,
      visibleLabelStep = this.visibleLabelStep;


  if (!this.el) {
    return;
  }

  var isHorizontal = position === _Axis.positionTop || position === _Axis.positionBottom;
  var labelDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick.-measureable text'))).map(function (el) {
    return el.getBoundingClientRect();
  });

  var smallestTickGap = 10000; // This is just a ridiculously large tick spacing that would never happen (hopefully)
  // If the axis is horizontal, we need to determine any necessary rotation and tick skipping
  if (isHorizontal) {
    var tickDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick.-measureable'))).map(function (el) {
      return el.getBoundingClientRect();
    });
    tickDims.reduce(function (prev, current) {
      if (prev) {
        var gap = current.left - prev.left - fontSize / 2;
        smallestTickGap = gap < smallestTickGap ? gap : smallestTickGap;
      }
      return current;
    }, false);
    var largestLabel = labelDims.reduce(function (prev, current) {
      current._overflow = current.width - smallestTickGap;
      if (current._overflow > 0 && current._overflow > prev._overflow) {
        return current;
      }
      return prev;
    }, { _overflow: 0 });

    var newRotation = Math.min(Math.max(Math.abs(radiansToDegrees(Math.acos(smallestTickGap / largestLabel.width))), 0), maxLabelRotation);
    newRotation = isNaN(newRotation) ? 0 : newRotation;

    if (Math.floor(rotation) !== Math.floor(newRotation)) {
      this.rotation = axis.position === 'top' ? -newRotation : newRotation;
    }
  }

  var newVisibleLabelStep = Math.ceil(fontSize / smallestTickGap);

  if (visibleLabelStep !== newVisibleLabelStep) {
    this.visibleLabelStep = newVisibleLabelStep;
  }

  if (!labelDims.length || labelDims.length !== this.ticks.length) {
    return false;
  }

  var width = 0;
  var height = 0;
  var top = 0;
  var bottom = 0;
  var left = 0;
  var right = 0;

  // Determine axis rotation before we measure

  if (isHorizontal) {
    // Add width overflow from the first and last ticks
    left = Math.ceil(getPixel(labelDims[0].width) / 2);
    right = Math.ceil(getPixel(labelDims[labelDims.length - 1].width) / 2);
    height = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.height));
    }))); // Add the height of the largest label
  } else {
    // Add height overflow from the first and last ticks
    top = Math.ceil(getPixel(labelDims[0].height) / 2);
    bottom = Math.ceil(getPixel(labelDims[labelDims.length - 1].height) / 2);
    width = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.width));
    }))); // Add the width of the largest label
  }

  dispatch(function (state) {
    return _extends({}, state, {
      axisDimensions: _extends({}, state.axisDimensions, _defineProperty({}, position, {
        width: width,
        height: height,
        top: top,
        bottom: bottom,
        left: left,
        right: right
      }))
    });
  }, {
    type: 'axisDimensions'
  });

  return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0xpbmVhckF4aXMubWVhc3VyZS5qcyJdLCJuYW1lcyI6WyJtZWFzdXJlIiwiZm9udFNpemUiLCJnZXRQaXhlbCIsImQiLCJyYWRpYW5zVG9EZWdyZWVzIiwiciIsIk1hdGgiLCJQSSIsInByb3BzIiwiYXhpcyIsInRpY2tTaXplSW5uZXIiLCJ0aWNrU2l6ZU91dGVyIiwidGlja1BhZGRpbmciLCJtYXhMYWJlbFJvdGF0aW9uIiwicG9zaXRpb24iLCJkaXNwYXRjaCIsInJvdGF0aW9uIiwidmlzaWJsZUxhYmVsU3RlcCIsImVsIiwiaXNIb3Jpem9udGFsIiwibGFiZWxEaW1zIiwiQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwibWFwIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic21hbGxlc3RUaWNrR2FwIiwidGlja0RpbXMiLCJyZWR1Y2UiLCJwcmV2IiwiY3VycmVudCIsImdhcCIsImxlZnQiLCJsYXJnZXN0TGFiZWwiLCJfb3ZlcmZsb3ciLCJ3aWR0aCIsIm5ld1JvdGF0aW9uIiwibWluIiwibWF4IiwiYWJzIiwiYWNvcyIsImlzTmFOIiwiZmxvb3IiLCJuZXdWaXNpYmxlTGFiZWxTdGVwIiwiY2VpbCIsImxlbmd0aCIsInRpY2tzIiwiaGVpZ2h0IiwidG9wIiwiYm90dG9tIiwicmlnaHQiLCJzdGF0ZSIsImF4aXNEaW1lbnNpb25zIiwidHlwZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7a0JBVXdCQSxPOztBQVZ4Qjs7Ozs7O0FBS0EsSUFBTUMsV0FBVyxFQUFqQjs7QUFFQSxJQUFNQyxXQUFXLFNBQVhBLFFBQVc7QUFBQSxTQUFLQyxDQUFMO0FBQUEsQ0FBakI7QUFDQSxJQUFNQyxtQkFBbUIsU0FBbkJBLGdCQUFtQjtBQUFBLFNBQUtDLEtBQUssTUFBTUMsS0FBS0MsRUFBaEIsQ0FBTDtBQUFBLENBQXpCOztBQUVlLFNBQVNQLE9BQVQsR0FBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTmlD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U0FBSytCLEdBQUwsZ0NBQVlqQixVQUFVRyxHQUFWLENBQWM7QUFBQSxhQUFLakIsS0FBS3FDLElBQUwsQ0FBVXpDLFNBQVNDLEVBQUUrQixLQUFYLENBQVYsQ0FBTDtBQUFBLEtBQWQsQ0FBWixFQUhGLENBSkssQ0FPMkQ7QUFDakU7O0FBRURuQixXQUFTO0FBQUEsd0JBQ0ptQyxLQURJO0FBRVBDLG1DQUNLRCxNQUFNQyxjQURYLHNCQUVHckMsUUFGSCxFQUVjO0FBQ1ZvQixvQkFEVTtBQUVWWSxzQkFGVTtBQUdWQyxnQkFIVTtBQUlWQyxzQkFKVTtBQUtWakIsa0JBTFU7QUFNVmtCO0FBTlUsT0FGZDtBQUZPO0FBQUEsR0FBVCxFQWFJO0FBQ0ZHLFVBQU07QUFESixHQWJKOztBQWlCQSxTQUFPLElBQVA7QUFDRCIsImZpbGUiOiJMaW5lYXJBeGlzLm1lYXN1cmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBwb3NpdGlvblRvcCxcbiAgcG9zaXRpb25Cb3R0b21cbn0gZnJvbSAnLi9BeGlzJ1xuXG5jb25zdCBmb250U2l6ZSA9IDEwXG5cbmNvbnN0IGdldFBpeGVsID0gZCA9PiBkXG5jb25zdCByYWRpYW5zVG9EZWdyZWVzID0gciA9PiByICogKDE4MCAvIE1hdGguUEkpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lYXN1cmUgKCkge1xuICAvLyBNZWFzdXJlIGZpbmRzIHRoZSBhbW91bnQgb2Ygb3ZlcmZsb3cgdGhpcyBheGlzIHByb2R1Y2VzIGFuZFxuICAvLyB1cGRhdGVzIHRoZSBtYXJnaW5zIHRvIGVuc3VyZSB0aGF0IHRoZSBheGlzIGlzIHZpc2liaWxpdHlcbiAgLy8gVW5mb3J0dW5hdGVseSwgdGhpcyBjdXJyZW50bHkgaGFwcGVucyBhZnRlciBhIHJlbmRlciwgYnV0IHBvdGVudGlhbGx5XG4gIC8vIGNvdWxkIGhhcHBlbiBwcmUtcmVuZGVyIGlmIHdlIGNvdWxkIHJlbGlhYmx5IHByZWRpY3QgdGhlIHNpemUgb2YgdGhlXG4gIC8vIGxhYmVscyBiZWZvcmUgdGhleSByZW5kZXIuIENvbnNpZGVyaW5nIHRoYXQgdGlja3MgY291bGQgYmUgYW55dGhpbmcsXG4gIC8vIGV2ZW4gYSByZWFjdCBjb21wb25lbnQsIHRoaXMgY291bGQgZ2V0IHZlcnkgdG91Z2guXG4gIGNvbnN0IHtcbiAgICBheGlzLFxuICAgIHRpY2tTaXplSW5uZXIsXG4gICAgdGlja1NpemVPdXRlcixcbiAgICB0aWNrUGFkZGluZyxcbiAgICBtYXhMYWJlbFJvdGF0aW9uLFxuICAgIHBvc2l0aW9uLFxuICAgIGRpc3BhdGNoXG4gIH0gPSB0aGlzLnByb3BzXG5cbiAgY29uc3Qge1xuICAgIHJvdGF0aW9uLFxuICAgIHZpc2libGVMYWJlbFN0ZXBcbiAgfSA9IHRoaXNcblxuICBpZiAoIXRoaXMuZWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHBvc2l0aW9uID09PSBwb3NpdGlvblRvcCB8fCBwb3NpdGlvbiA9PT0gcG9zaXRpb25Cb3R0b21cbiAgY29uc3QgbGFiZWxEaW1zID0gQXJyYXkoLi4udGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCcudGljay4tbWVhc3VyZWFibGUgdGV4dCcpKS5tYXAoZWwgPT4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpXG5cbiAgbGV0IHNtYWxsZXN0VGlja0dhcCA9IDEwMDAwIC8vIFRoaXMgaXMganVzdCBhIHJpZGljdWxvdXNseSBsYXJnZSB0aWNrIHNwYWNpbmcgdGhhdCB3b3VsZCBuZXZlciBoYXBwZW4gKGhvcGVmdWxseSlcbiAgLy8gSWYgdGhlIGF4aXMgaXMgaG9yaXpvbnRhbCwgd2UgbmVlZCB0byBkZXRlcm1pbmUgYW55IG5lY2Vzc2FyeSByb3RhdGlvbiBhbmQgdGljayBza2lwcGluZ1xuICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgY29uc3QgdGlja0RpbXMgPSBBcnJheSguLi50aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aWNrLi1tZWFzdXJlYWJsZScpKS5tYXAoZWwgPT4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpXG4gICAgdGlja0RpbXMucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBjb25zdCBnYXAgPSBjdXJyZW50LmxlZnQgLSBwcmV2LmxlZnQgLSAoZm9udFNpemUgLyAyKVxuICAgICAgICBzbWFsbGVzdFRpY2tHYXAgPSBnYXAgPCBzbWFsbGVzdFRpY2tHYXAgPyBnYXAgOiBzbWFsbGVzdFRpY2tHYXBcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50XG4gICAgfSwgZmFsc2UpXG4gICAgY29uc3QgbGFyZ2VzdExhYmVsID0gbGFiZWxEaW1zLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgY3VycmVudC5fb3ZlcmZsb3cgPSBjdXJyZW50LndpZHRoIC0gc21hbGxlc3RUaWNrR2FwXG4gICAgICBpZiAoY3VycmVudC5fb3ZlcmZsb3cgPiAwICYmIGN1cnJlbnQuX292ZXJmbG93ID4gcHJldi5fb3ZlcmZsb3cpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2XG4gICAgfSwge19vdmVyZmxvdzogMH0pXG5cbiAgICBsZXQgbmV3Um90YXRpb24gPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyhyYWRpYW5zVG9EZWdyZWVzKE1hdGguYWNvcyhzbWFsbGVzdFRpY2tHYXAgLyBsYXJnZXN0TGFiZWwud2lkdGgpKSksIDApLCBtYXhMYWJlbFJvdGF0aW9uKVxuICAgIG5ld1JvdGF0aW9uID0gaXNOYU4obmV3Um90YXRpb24pID8gMCA6IG5ld1JvdGF0aW9uXG5cbiAgICBpZiAoTWF0aC5mbG9vcihyb3RhdGlvbikgIT09IE1hdGguZmxvb3IobmV3Um90YXRpb24pKSB7XG4gICAgICB0aGlzLnJvdGF0aW9uID0gYXhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcgPyAtbmV3Um90YXRpb24gOiBuZXdSb3RhdGlvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5ld1Zpc2libGVMYWJlbFN0ZXAgPSBNYXRoLmNlaWwoZm9udFNpemUgLyBzbWFsbGVzdFRpY2tHYXApXG5cbiAgaWYgKHZpc2libGVMYWJlbFN0ZXAgIT09IG5ld1Zpc2libGVMYWJlbFN0ZXApIHtcbiAgICB0aGlzLnZpc2libGVMYWJlbFN0ZXAgPSBuZXdWaXNpYmxlTGFiZWxTdGVwXG4gIH1cblxuICBpZiAoIWxhYmVsRGltcy5sZW5ndGggfHwgbGFiZWxEaW1zLmxlbmd0aCAhPT0gdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGxldCB3aWR0aCA9IDBcbiAgbGV0IGhlaWdodCA9IDBcbiAgbGV0IHRvcCA9IDBcbiAgbGV0IGJvdHRvbSA9IDBcbiAgbGV0IGxlZnQgPSAwXG4gIGxldCByaWdodCA9IDBcblxuICAvLyBEZXRlcm1pbmUgYXhpcyByb3RhdGlvbiBiZWZvcmUgd2UgbWVhc3VyZVxuXG4gIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAvLyBBZGQgd2lkdGggb3ZlcmZsb3cgZnJvbSB0aGUgZmlyc3QgYW5kIGxhc3QgdGlja3NcbiAgICBsZWZ0ID0gTWF0aC5jZWlsKGdldFBpeGVsKGxhYmVsRGltc1swXS53aWR0aCkgLyAyKVxuICAgIHJpZ2h0ID0gTWF0aC5jZWlsKGdldFBpeGVsKGxhYmVsRGltc1tsYWJlbERpbXMubGVuZ3RoIC0gMV0ud2lkdGgpIC8gMilcbiAgICBoZWlnaHQgPVxuICAgICAgTWF0aC5tYXgodGlja1NpemVJbm5lciwgdGlja1NpemVPdXRlcikgKyAvLyBBZGQgdGljayBzaXplXG4gICAgICB0aWNrUGFkZGluZyArIC8vIEFkZCB0aWNrIHBhZGRpbmdcbiAgICAgIE1hdGgubWF4KC4uLmxhYmVsRGltcy5tYXAoZCA9PiBNYXRoLmNlaWwoZ2V0UGl4ZWwoZC5oZWlnaHQpKSkpIC8vIEFkZCB0aGUgaGVpZ2h0IG9mIHRoZSBsYXJnZXN0IGxhYmVsXG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkIGhlaWdodCBvdmVyZmxvdyBmcm9tIHRoZSBmaXJzdCBhbmQgbGFzdCB0aWNrc1xuICAgIHRvcCA9IE1hdGguY2VpbChnZXRQaXhlbChsYWJlbERpbXNbMF0uaGVpZ2h0KSAvIDIpXG4gICAgYm90dG9tID0gTWF0aC5jZWlsKGdldFBpeGVsKGxhYmVsRGltc1tsYWJlbERpbXMubGVuZ3RoIC0gMV0uaGVpZ2h0KSAvIDIpXG4gICAgd2lkdGggPVxuICAgICAgTWF0aC5tYXgodGlja1NpemVJbm5lciwgdGlja1NpemVPdXRlcikgKyAvLyBBZGQgdGljayBzaXplXG4gICAgICB0aWNrUGFkZGluZyArIC8vIEFkZCB0aWNrIHBhZGRpbmdcbiAgICAgIE1hdGgubWF4KC4uLmxhYmVsRGltcy5tYXAoZCA9PiBNYXRoLmNlaWwoZ2V0UGl4ZWwoZC53aWR0aCkpKSkgLy8gQWRkIHRoZSB3aWR0aCBvZiB0aGUgbGFyZ2VzdCBsYWJlbFxuICB9XG5cbiAgZGlzcGF0Y2goc3RhdGUgPT4gKHtcbiAgICAuLi5zdGF0ZSxcbiAgICBheGlzRGltZW5zaW9uczoge1xuICAgICAgLi4uc3RhdGUuYXhpc0RpbWVuc2lvbnMsXG4gICAgICBbcG9zaXRpb25dOiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodFxuICAgICAgfVxuICAgIH1cbiAgfSksIHtcbiAgICB0eXBlOiAnYXhpc0RpbWVuc2lvbnMnXG4gIH0pXG5cbiAgcmV0dXJuIHRydWVcbn1cbiJdfQ==