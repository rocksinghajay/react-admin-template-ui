'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactState = require('react-state');

var _d3Quadtree = require('d3-quadtree');

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

var _Utils = require('../utils/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

var _reactMove = require('react-move');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


var defaultColors = ['#4ab5eb', '#fc6868', '#DECF3F', '#60BD68', '#FAA43A', '#c63b89', '#1aaabe', '#734fe9', '#1828bd', '#cd82ad'];

var getType = function getType(type, data, i) {
  // Allow dynamic types
  var typeGetter = typeof type === 'function' && type.prototype.isReactComponent ? function () {
    return type;
  } : type;
  return typeGetter(data, i);
};

var Series = function (_PureComponent) {
  _inherits(Series, _PureComponent);

  function Series() {
    _classCallCheck(this, Series);

    return _possibleConstructorReturn(this, (Series.__proto__ || Object.getPrototypeOf(Series)).apply(this, arguments));
  }

  _createClass(Series, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateStackData(this.props);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      var oldProps = this.props;

      // If any of the following change,
      // we need to update the stack
      if (newProps.materializedData !== oldProps.materializedData || newProps.axes !== oldProps.axes || newProps.type !== oldProps.type || newProps.seriesKey !== oldProps.seriesKey || newProps.primaryAxis !== oldProps.primaryAxis || newProps.secondaryAxis !== oldProps.secondaryAxis) {
        this.updateStackData(newProps);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      if (nextProps.stackData !== this.props.stackData) {
        this.stackData = [].concat(_toConsumableArray(nextProps.stackData)).reverse(); // For proper svg stacking
        return true;
      }
      return false;
    }
  }, {
    key: 'updateStackData',
    value: function updateStackData(props) {
      var type = props.type,
          getStyles = props.getStyles,
          getDataStyles = props.getDataStyles,
          materializedData = props.materializedData,
          primaryAxis = props.primaryAxis,
          secondaryAxis = props.secondaryAxis;

      // We need materializedData to proceed

      if (!materializedData) {
        return;
      }

      // If the axes are not ready, just provide the materializedData
      if (!primaryAxis || !secondaryAxis) {
        return;
      }

      // If the axes are ready, let's decorate the materializedData for visual plotting
      var secondaryStacked = secondaryAxis.stacked;

      // Make sure we're mapping x and y to the correct axes
      var xKey = primaryAxis.vertical ? 'secondary' : 'primary';
      var yKey = primaryAxis.vertical ? 'primary' : 'secondary';
      var xAxis = primaryAxis.vertical ? secondaryAxis : primaryAxis;
      var yAxis = primaryAxis.vertical ? primaryAxis : secondaryAxis;
      var xScale = xAxis.scale;
      var yScale = yAxis.scale;

      // "totals" are kept and used for bases if secondaryAxis stacking is enabled
      var totals = {};
      if (secondaryStacked) {
        materializedData.forEach(function (series) {
          series.data.forEach(function (datum) {
            totals[datum.primary] = {
              negative: 0,
              positive: 0
            };
          });
        });
      }

      var stackData = materializedData.map(function (series, seriesIndex) {
        var SeriesComponent = getType(type, series, seriesIndex) || {};
        return _extends({}, series, {
          type: SeriesComponent.SeriesType,
          data: series.data.map(function (d, index) {
            var datum = _extends({}, d, {
              x: d[xKey],
              y: d[yKey],
              base: 0
            });
            if (secondaryStacked) {
              var start = totals[d.primary];
              // Stack the x or y values (according to axis positioning)
              if (primaryAxis.vertical) {
                // Should we use positive or negative base?
                var key = datum.x >= 0 ? 'positive' : 'negative';
                // Assign the base
                datum.base = start[key];
                // Add the value to the base
                datum.x = datum.base + datum.x;
                // Update the totals
                totals[d.primary][key] = datum.x;
              } else {
                // Should we use positive or negative base?
                var _key = datum.y >= 0 ? 'positive' : 'negative';
                // Assign the base
                datum.base = start[_key];
                // Add the value to the base
                datum.y = datum.base + datum.y;
                // Update the totals
                totals[d.primary][_key] = datum.y;
              }
            }
            return datum;
          })
        });
      });

      // Now, scale the datapoints to their axis coordinates
      // (mutation is okay here, since we have already made a materialized copy)
      stackData.forEach(function (series) {
        series.data.forEach(function (d, index) {
          // Data for cartesian charts
          if (series.type === 'Line' || series.type === 'Area' || series.type === 'Bar') {
            d.x = xScale(d.x);
            d.y = yScale(d.y);
            d.base = primaryAxis.vertical ? xScale(d.base) : yScale(d.base);
            // Adjust non-bar elements for ordinal scales
            if (series.type !== 'Bar') {
              if (xAxis.type === 'ordinal') {
                d.x += xAxis.tickOffset;
              }
              if (yAxis.type === 'ordinal') {
                d.y += yAxis.tickOffset;
              }
            }

            // Set the default focus point
            d.focus = {
              x: d.x,
              y: d.y
            };

            // Adjust the focus point for specific elements
            if (series.type === 'Bar') {
              if (!xAxis.vertical) {
                d.focus.x = d.x + xAxis.tickOffset;
              }
              if (!yAxis.vertical) {
                d.focus.y = d.y + yAxis.tickOffset;
              }
            }
          } else if (series.type === 'Pie') {
            // data for Radial charts
            d.focus = primaryAxis.scale(d);
            d.x = d.focus.x;
            d.y = d.focus.y;
          }
        });
      });

      // Not we need to precalculate all of the possible status styles by
      // calling the seemingly 'live' getStyles, and getDataStyles callbacks ;)
      stackData.forEach(function (series) {
        var defaults = series.type !== 'Pie' ? {
          // Pass some sane defaults
          color: defaultColors[series.index % (defaultColors.length - 1)]
        } : {};

        series.statusStyles = _Utils2.default.getStatusStyles(series, getStyles, defaults);

        // We also need to decorate each datum in the same fashion
        series.data.forEach(function (datum) {
          if (series.type === 'Pie') {
            defaults.color = defaultColors[datum.index % (defaultColors.length - 1)];
          }
          datum.statusStyles = _Utils2.default.getStatusStyles(datum, getDataStyles, _extends({}, defaults, series.statusStyles.default));
        });
      });

      var allPoints = [];

      stackData.forEach(function (s) {
        s.data.forEach(function (d) {
          allPoints.push(d);
        });
      });

      var quadTree = (0, _d3Quadtree.quadtree)().x(function (d) {
        return d.x;
      }).y(function (d) {
        return d.y;
      }).addAll(allPoints);

      this.props.dispatch(function (state) {
        return _extends({}, state, {
          stackData: stackData,
          quadTree: quadTree
        });
      }, {
        type: 'stackData'
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          type = _props.type,
          getStyles = _props.getStyles,
          getDataStyles = _props.getDataStyles,
          rest = _objectWithoutProperties(_props, ['type', 'getStyles', 'getDataStyles']);

      var stackData = this.stackData;


      if (!stackData) {
        return null;
      }

      return _react2.default.createElement(
        _reactMove.Transition,
        {
          data: stackData // The stack is reversed for proper z-index painting
          , getKey: function getKey(d, i) {
            return d.id;
          },
          update: function update(d) {
            return {
              visibility: 1
            };
          },
          enter: function enter(d, i) {
            return {
              visibility: 0
            };
          },
          leave: function leave(d) {
            return {
              visibility: 0
            };
          },
          ignore: ['visibility'],
          duration: 500
        },
        function (inters) {
          return _react2.default.createElement(
            'g',
            { className: 'Series' },
            inters.map(function (inter, i) {
              var StackCmp = getType(type, inter.data, inter.data.id);
              return _react2.default.createElement(StackCmp, _extends({}, rest, {
                key: inter.key,
                series: inter.data,
                stackData: stackData,
                visibility: inter.state.visibility
              }));
            })
          );
        }
      );
    }
  }]);

  return Series;
}(_react.PureComponent);

Series.defaultProps = {
  getStyles: function getStyles(d) {
    return {};
  },
  getDataStyles: function getDataStyles(d) {
    return {};
  }
};
exports.default = (0, _reactState.Connect)(function () {
  var selectors = {
    primaryAxis: _Selectors2.default.primaryAxis(),
    secondaryAxis: _Selectors2.default.secondaryAxis()
  };
  return function (state, props) {
    return {
      materializedData: state.materializedData,
      stackData: state.stackData,
      primaryAxis: selectors.primaryAxis(state),
      secondaryAxis: selectors.secondaryAxis(state),
      hovered: state.hovered,
      selected: state.selected
    };
  };
}, {
  filter: function filter(oldState, newState, meta) {
    return meta.type !== 'cursor';
  }
})(Series);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL1Nlcmllcy5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0Q29sb3JzIiwiZ2V0VHlwZSIsInR5cGUiLCJkYXRhIiwiaSIsInR5cGVHZXR0ZXIiLCJwcm90b3R5cGUiLCJpc1JlYWN0Q29tcG9uZW50IiwiU2VyaWVzIiwidXBkYXRlU3RhY2tEYXRhIiwicHJvcHMiLCJuZXdQcm9wcyIsIm9sZFByb3BzIiwibWF0ZXJpYWxpemVkRGF0YSIsImF4ZXMiLCJzZXJpZXNLZXkiLCJwcmltYXJ5QXhpcyIsInNlY29uZGFyeUF4aXMiLCJuZXh0UHJvcHMiLCJzdGFja0RhdGEiLCJyZXZlcnNlIiwiZ2V0U3R5bGVzIiwiZ2V0RGF0YVN0eWxlcyIsInNlY29uZGFyeVN0YWNrZWQiLCJzdGFja2VkIiwieEtleSIsInZlcnRpY2FsIiwieUtleSIsInhBeGlzIiwieUF4aXMiLCJ4U2NhbGUiLCJzY2FsZSIsInlTY2FsZSIsInRvdGFscyIsImZvckVhY2giLCJzZXJpZXMiLCJkYXR1bSIsInByaW1hcnkiLCJuZWdhdGl2ZSIsInBvc2l0aXZlIiwibWFwIiwic2VyaWVzSW5kZXgiLCJTZXJpZXNDb21wb25lbnQiLCJTZXJpZXNUeXBlIiwiZCIsImluZGV4IiwieCIsInkiLCJiYXNlIiwic3RhcnQiLCJrZXkiLCJ0aWNrT2Zmc2V0IiwiZm9jdXMiLCJkZWZhdWx0cyIsImNvbG9yIiwibGVuZ3RoIiwic3RhdHVzU3R5bGVzIiwiZ2V0U3RhdHVzU3R5bGVzIiwiZGVmYXVsdCIsImFsbFBvaW50cyIsInMiLCJwdXNoIiwicXVhZFRyZWUiLCJhZGRBbGwiLCJkaXNwYXRjaCIsInN0YXRlIiwicmVzdCIsImlkIiwidmlzaWJpbGl0eSIsImludGVycyIsImludGVyIiwiU3RhY2tDbXAiLCJkZWZhdWx0UHJvcHMiLCJzZWxlY3RvcnMiLCJob3ZlcmVkIiwic2VsZWN0ZWQiLCJmaWx0ZXIiLCJvbGRTdGF0ZSIsIm5ld1N0YXRlIiwibWV0YSJdLCJtYXBwaW5n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QkFBVUEsV0FBVixFQURHO0FBRWhCQyxtQkFBZSxvQkFBVUEsYUFBVjtBQUZDLEdBQWxCO0FBSUEsU0FBTyxVQUFDZ0QsS0FBRCxFQUFRdkQsS0FBUixFQUFrQjtBQUN2QixXQUFPO0FBQ0xHLHdCQUFrQm9ELE1BQU1wRCxnQkFEbkI7QUFFTE0saUJBQVc4QyxNQUFNOUMsU0FGWjtBQUdMSCxtQkFBYXlELFVBQVV6RCxXQUFWLENBQXNCaUQsS0FBdEIsQ0FIUjtBQUlMaEQscUJBQWV3RCxVQUFVeEQsYUFBVixDQUF3QmdELEtBQXhCLENBSlY7QUFLTFMsZUFBU1QsTUFBTVMsT0FMVjtBQU1MQyxnQkFBVVYsTUFBTVU7QUFOWCxLQUFQO0FBUUQsR0FURDtBQVVELENBaEJZLEVBaUJiO0FBQ0VDLFVBQVEsZ0JBQUNDLFFBQUQsRUFBV0MsUUFBWCxFQUFxQkMsSUFBckI7QUFBQSxXQUE4QkEsS0FBSzdFLElBQUwsS0FBYyxRQUE1QztBQUFBO0FBRFYsQ0FqQmEsRUFvQmJNLE1BcEJhLEMiLCJmaWxlIjoiU2VyaWVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IENvbm5lY3QgfSBmcm9tICdyZWFjdC1zdGF0ZSdcbmltcG9ydCB7IHF1YWR0cmVlIGFzIFF1YWRUcmVlIH0gZnJvbSAnZDMtcXVhZHRyZWUnXG4vL1xuaW1wb3J0IFNlbGVjdG9ycyBmcm9tICcuLi91dGlscy9TZWxlY3RvcnMnXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMvVXRpbHMnXG5cbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC1tb3ZlJ1xuXG5jb25zdCBkZWZhdWx0Q29sb3JzID0gW1xuICAnIzRhYjVlYicsXG4gICcjZmM2ODY4JyxcbiAgJyNERUNGM0YnLFxuICAnIzYwQkQ2OCcsXG4gICcjRkFBNDNBJyxcbiAgJyNjNjNiODknLFxuICAnIzFhYWFiZScsXG4gICcjNzM0ZmU5JyxcbiAgJyMxODI4YmQnLFxuICAnI2NkODJhZCcsXG5dXG5cbmNvbnN0IGdldFR5cGUgPSAodHlwZSwgZGF0YSwgaSkgPT4ge1xuICAvLyBBbGxvdyBkeW5hbWljIHR5cGVzXG4gIGNvbnN0IHR5cGVHZXR0ZXIgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnRcbiAgICA/ICgpID0+IHR5cGVcbiAgICA6IHR5cGVcbiAgcmV0dXJuIHR5cGVHZXR0ZXIoZGF0YSwgaSlcbn1cblxuY2xhc3MgU2VyaWVzIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgZ2V0U3R5bGVzOiBkID0+ICh7fSksXG4gICAgZ2V0RGF0YVN0eWxlczogZCA9PiAoe30pLFxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YWNrRGF0YSh0aGlzLnByb3BzKVxuICB9XG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG5ld1Byb3BzKSB7XG4gICAgY29uc3Qgb2xkUHJvcHMgPSB0aGlzLnByb3BzXG5cbiAgICAvLyBJZiBhbnkgb2YgdGhlIGZvbGxvd2luZyBjaGFuZ2UsXG4gICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgdGhlIHN0YWNrXG4gICAgaWYgKFxuICAgICAgbmV3UHJvcHMubWF0ZXJpYWxpemVkRGF0YSAhPT0gb2xkUHJvcHMubWF0ZXJpYWxpemVkRGF0YSB8fFxuICAgICAgbmV3UHJvcHMuYXhlcyAhPT0gb2xkUHJvcHMuYXhlcyB8fFxuICAgICAgbmV3UHJvcHMudHlwZSAhPT0gb2xkUHJvcHMudHlwZSB8fFxuICAgICAgbmV3UHJvcHMuc2VyaWVzS2V5ICE9PSBvbGRQcm9wcy5zZXJpZXNLZXkgfHxcbiAgICAgIG5ld1Byb3BzLnByaW1hcnlBeGlzICE9PSBvbGRQcm9wcy5wcmltYXJ5QXhpcyB8fFxuICAgICAgbmV3UHJvcHMuc2Vjb25kYXJ5QXhpcyAhPT0gb2xkUHJvcHMuc2Vjb25kYXJ5QXhpc1xuICAgICkge1xuICAgICAgdGhpcy51cGRhdGVTdGFja0RhdGEobmV3UHJvcHMpXG4gICAgfVxuICB9XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5zdGFja0RhdGEgIT09IHRoaXMucHJvcHMuc3RhY2tEYXRhKSB7XG4gICAgICB0aGlzLnN0YWNrRGF0YSA9IFsuLi5uZXh0UHJvcHMuc3RhY2tEYXRhXS5yZXZlcnNlKCkgLy8gRm9yIHByb3BlciBzdmcgc3RhY2tpbmdcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHVwZGF0ZVN0YWNrRGF0YSAocHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgZ2V0U3R5bGVzLFxuICAgICAgZ2V0RGF0YVN0eWxlcyxcbiAgICAgIC8vXG4gICAgICBtYXRlcmlhbGl6ZWREYXRhLFxuICAgICAgcHJpbWFyeUF4aXMsXG4gICAgICBzZWNvbmRhcnlBeGlzLFxuICAgIH0gPSBwcm9wc1xuXG4gICAgLy8gV2UgbmVlZCBtYXRlcmlhbGl6ZWREYXRhIHRvIHByb2NlZWRcbiAgICBpZiAoIW1hdGVyaWFsaXplZERhdGEpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBheGVzIGFyZSBub3QgcmVhZHksIGp1c3QgcHJvdmlkZSB0aGUgbWF0ZXJpYWxpemVkRGF0YVxuICAgIGlmICghcHJpbWFyeUF4aXMgfHwgIXNlY29uZGFyeUF4aXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBheGVzIGFyZSByZWFkeSwgbGV0J3MgZGVjb3JhdGUgdGhlIG1hdGVyaWFsaXplZERhdGEgZm9yIHZpc3VhbCBwbG90dGluZ1xuICAgIGNvbnN0IHNlY29uZGFyeVN0YWNrZWQgPSBzZWNvbmRhcnlBeGlzLnN0YWNrZWRcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBtYXBwaW5nIHggYW5kIHkgdG8gdGhlIGNvcnJlY3QgYXhlc1xuICAgIGNvbnN0IHhLZXkgPSBwcmltYXJ5QXhpcy52ZXJ0aWNhbCA/ICdzZWNvbmRhcnknIDogJ3ByaW1hcnknXG4gICAgY29uc3QgeUtleSA9IHByaW1hcnlBeGlzLnZlcnRpY2FsID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSdcbiAgICBjb25zdCB4QXhpcyA9IHByaW1hcnlBeGlzLnZlcnRpY2FsID8gc2Vjb25kYXJ5QXhpcyA6IHByaW1hcnlBeGlzXG4gICAgY29uc3QgeUF4aXMgPSBwcmltYXJ5QXhpcy52ZXJ0aWNhbCA/IHByaW1hcnlBeGlzIDogc2Vjb25kYXJ5QXhpc1xuICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlXG4gICAgY29uc3QgeVNjYWxlID0geUF4aXMuc2NhbGVcblxuICAgIC8vIFwidG90YWxzXCIgYXJlIGtlcHQgYW5kIHVzZWQgZm9yIGJhc2VzIGlmIHNlY29uZGFyeUF4aXMgc3RhY2tpbmcgaXMgZW5hYmxlZFxuICAgIGNvbnN0IHRvdGFscyA9IHt9XG4gICAgaWYgKHNlY29uZGFyeVN0YWNrZWQpIHtcbiAgICAgIG1hdGVyaWFsaXplZERhdGEuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgICBzZXJpZXMuZGF0YS5mb3JFYWNoKGRhdHVtID0+IHtcbiAgICAgICAgICB0b3RhbHNbZGF0dW0ucHJpbWFyeV0gPSB7XG4gICAgICAgICAgICBuZWdhdGl2ZTogMCxcbiAgICAgICAgICAgIHBvc2l0aXZlOiAwLFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgbGV0IHN0YWNrRGF0YSA9IG1hdGVyaWFsaXplZERhdGEubWFwKChzZXJpZXMsIHNlcmllc0luZGV4KSA9PiB7XG4gICAgICBjb25zdCBTZXJpZXNDb21wb25lbnQgPSBnZXRUeXBlKHR5cGUsIHNlcmllcywgc2VyaWVzSW5kZXgpIHx8IHt9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zZXJpZXMsXG4gICAgICAgIHR5cGU6IFNlcmllc0NvbXBvbmVudC5TZXJpZXNUeXBlLFxuICAgICAgICBkYXRhOiBzZXJpZXMuZGF0YS5tYXAoKGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0dW0gPSB7XG4gICAgICAgICAgICAuLi5kLFxuICAgICAgICAgICAgeDogZFt4S2V5XSxcbiAgICAgICAgICAgIHk6IGRbeUtleV0sXG4gICAgICAgICAgICBiYXNlOiAwLFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vjb25kYXJ5U3RhY2tlZCkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdG90YWxzW2QucHJpbWFyeV1cbiAgICAgICAgICAgIC8vIFN0YWNrIHRoZSB4IG9yIHkgdmFsdWVzIChhY2NvcmRpbmcgdG8gYXhpcyBwb3NpdGlvbmluZylcbiAgICAgICAgICAgIGlmIChwcmltYXJ5QXhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAvLyBTaG91bGQgd2UgdXNlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGJhc2U/XG4gICAgICAgICAgICAgIGxldCBrZXkgPSBkYXR1bS54ID49IDAgPyAncG9zaXRpdmUnIDogJ25lZ2F0aXZlJ1xuICAgICAgICAgICAgICAvLyBBc3NpZ24gdGhlIGJhc2VcbiAgICAgICAgICAgICAgZGF0dW0uYmFzZSA9IHN0YXJ0W2tleV1cbiAgICAgICAgICAgICAgLy8gQWRkIHRoZSB2YWx1ZSB0byB0aGUgYmFzZVxuICAgICAgICAgICAgICBkYXR1bS54ID0gZGF0dW0uYmFzZSArIGRhdHVtLnhcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0b3RhbHNcbiAgICAgICAgICAgICAgdG90YWxzW2QucHJpbWFyeV1ba2V5XSA9IGRhdHVtLnhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNob3VsZCB3ZSB1c2UgcG9zaXRpdmUgb3IgbmVnYXRpdmUgYmFzZT9cbiAgICAgICAgICAgICAgbGV0IGtleSA9IGRhdHVtLnkgPj0gMCA/ICdwb3NpdGl2ZScgOiAnbmVnYXRpdmUnXG4gICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGUgYmFzZVxuICAgICAgICAgICAgICBkYXR1bS5iYXNlID0gc3RhcnRba2V5XVxuICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZhbHVlIHRvIHRoZSBiYXNlXG4gICAgICAgICAgICAgIGRhdHVtLnkgPSBkYXR1bS5iYXNlICsgZGF0dW0ueVxuICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRvdGFsc1xuICAgICAgICAgICAgICB0b3RhbHNbZC5wcmltYXJ5XVtrZXldID0gZGF0dW0ueVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0dW1cbiAgICAgICAgfSksXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIE5vdywgc2NhbGUgdGhlIGRhdGFwb2ludHMgdG8gdGhlaXIgYXhpcyBjb29yZGluYXRlc1xuICAgIC8vIChtdXRhdGlvbiBpcyBva2F5IGhlcmUsIHNpbmNlIHdlIGhhdmUgYWxyZWFkeSBtYWRlIGEgbWF0ZXJpYWxpemVkIGNvcHkpXG4gICAgc3RhY2tEYXRhLmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgIHNlcmllcy5kYXRhLmZvckVhY2goKGQsIGluZGV4KSA9PiB7XG4gICAgICAgIC8vIERhdGEgZm9yIGNhcnRlc2lhbiBjaGFydHNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHNlcmllcy50eXBlID09PSAnTGluZScgfHxcbiAgICAgICAgICBzZXJpZXMudHlwZSA9PT0gJ0FyZWEnIHx8XG4gICAgICAgICAgc2VyaWVzLnR5cGUgPT09ICdCYXInXG4gICAgICAgICkge1xuICAgICAgICAgIGQueCA9IHhTY2FsZShkLngpXG4gICAgICAgICAgZC55ID0geVNjYWxlKGQueSlcbiAgICAgICAgICBkLmJhc2UgPSBwcmltYXJ5QXhpcy52ZXJ0aWNhbCA/IHhTY2FsZShkLmJhc2UpIDogeVNjYWxlKGQuYmFzZSlcbiAgICAgICAgICAvLyBBZGp1c3Qgbm9uLWJhciBlbGVtZW50cyBmb3Igb3JkaW5hbCBzY2FsZXNcbiAgICAgICAgICBpZiAoc2VyaWVzLnR5cGUgIT09ICdCYXInKSB7XG4gICAgICAgICAgICBpZiAoeEF4aXMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICAgIGQueCArPSB4QXhpcy50aWNrT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeUF4aXMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICAgIGQueSArPSB5QXhpcy50aWNrT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IGZvY3VzIHBvaW50XG4gICAgICAgICAgZC5mb2N1cyA9IHtcbiAgICAgICAgICAgIHg6IGQueCxcbiAgICAgICAgICAgIHk6IGQueSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGp1c3QgdGhlIGZvY3VzIHBvaW50IGZvciBzcGVjaWZpYyBlbGVtZW50c1xuICAgICAgICAgIGlmIChzZXJpZXMudHlwZSA9PT0gJ0JhcicpIHtcbiAgICAgICAgICAgIGlmICgheEF4aXMudmVydGljYWwpIHtcbiAgICAgICAgICAgICAgZC5mb2N1cy54ID0gZC54ICsgeEF4aXMudGlja09mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF5QXhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICBkLmZvY3VzLnkgPSBkLnkgKyB5QXhpcy50aWNrT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlcmllcy50eXBlID09PSAnUGllJykge1xuICAgICAgICAgIC8vIGRhdGEgZm9yIFJhZGlhbCBjaGFydHNcbiAgICAgICAgICBkLmZvY3VzID0gcHJpbWFyeUF4aXMuc2NhbGUoZClcbiAgICAgICAgICBkLnggPSBkLmZvY3VzLnhcbiAgICAgICAgICBkLnkgPSBkLmZvY3VzLnlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgLy8gTm90IHdlIG5lZWQgdG8gcHJlY2FsY3VsYXRlIGFsbCBvZiB0aGUgcG9zc2libGUgc3RhdHVzIHN0eWxlcyBieVxuICAgIC8vIGNhbGxpbmcgdGhlIHNlZW1pbmdseSAnbGl2ZScgZ2V0U3R5bGVzLCBhbmQgZ2V0RGF0YVN0eWxlcyBjYWxsYmFja3MgOylcbiAgICBzdGFja0RhdGEuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSBzZXJpZXMudHlwZSAhPT0gJ1BpZSdcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAvLyBQYXNzIHNvbWUgc2FuZSBkZWZhdWx0c1xuICAgICAgICAgIGNvbG9yOiBkZWZhdWx0Q29sb3JzW3Nlcmllcy5pbmRleCAlIChkZWZhdWx0Q29sb3JzLmxlbmd0aCAtIDEpXSxcbiAgICAgICAgfVxuICAgICAgICA6IHt9XG5cbiAgICAgIHNlcmllcy5zdGF0dXNTdHlsZXMgPSBVdGlscy5nZXRTdGF0dXNTdHlsZXMoc2VyaWVzLCBnZXRTdHlsZXMsIGRlZmF1bHRzKVxuXG4gICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gZGVjb3JhdGUgZWFjaCBkYXR1bSBpbiB0aGUgc2FtZSBmYXNoaW9uXG4gICAgICBzZXJpZXMuZGF0YS5mb3JFYWNoKGRhdHVtID0+IHtcbiAgICAgICAgaWYgKHNlcmllcy50eXBlID09PSAnUGllJykge1xuICAgICAgICAgIGRlZmF1bHRzLmNvbG9yID1cbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcnNbZGF0dW0uaW5kZXggJSAoZGVmYXVsdENvbG9ycy5sZW5ndGggLSAxKV1cbiAgICAgICAgfVxuICAgICAgICBkYXR1bS5zdGF0dXNTdHlsZXMgPSBVdGlscy5nZXRTdGF0dXNTdHlsZXMoZGF0dW0sIGdldERhdGFTdHlsZXMsIHtcbiAgICAgICAgICAuLi5kZWZhdWx0cyxcbiAgICAgICAgICAuLi5zZXJpZXMuc3RhdHVzU3R5bGVzLmRlZmF1bHQsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCBhbGxQb2ludHMgPSBbXVxuXG4gICAgc3RhY2tEYXRhLmZvckVhY2gocyA9PiB7XG4gICAgICBzLmRhdGEuZm9yRWFjaChkID0+IHtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goZClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IHF1YWRUcmVlID0gUXVhZFRyZWUoKS54KGQgPT4gZC54KS55KGQgPT4gZC55KS5hZGRBbGwoYWxsUG9pbnRzKVxuXG4gICAgdGhpcy5wcm9wcy5kaXNwYXRjaChcbiAgICAgIHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBzdGFja0RhdGEsXG4gICAgICAgIHF1YWRUcmVlLFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdzdGFja0RhdGEnLFxuICAgICAgfVxuICAgIClcbiAgfVxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHsgdHlwZSwgZ2V0U3R5bGVzLCBnZXREYXRhU3R5bGVzLCAuLi5yZXN0IH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBzdGFja0RhdGEgfSA9IHRoaXNcblxuICAgIGlmICghc3RhY2tEYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8VHJhbnNpdGlvblxuICAgICAgICBkYXRhPXtzdGFja0RhdGF9IC8vIFRoZSBzdGFjayBpcyByZXZlcnNlZCBmb3IgcHJvcGVyIHotaW5kZXggcGFpbnRpbmdcbiAgICAgICAgZ2V0S2V5PXsoZCwgaSkgPT4gZC5pZH1cbiAgICAgICAgdXBkYXRlPXtkID0+ICh7XG4gICAgICAgICAgdmlzaWJpbGl0eTogMSxcbiAgICAgICAgfSl9XG4gICAgICAgIGVudGVyPXsoZCwgaSkgPT4gKHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiAwLFxuICAgICAgICB9KX1cbiAgICAgICAgbGVhdmU9e2QgPT4gKHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiAwLFxuICAgICAgICB9KX1cbiAgICAgICAgaWdub3JlPXtbJ3Zpc2liaWxpdHknXX1cbiAgICAgICAgZHVyYXRpb249ezUwMH1cbiAgICAgID5cbiAgICAgICAge2ludGVycyA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxnIGNsYXNzTmFtZT0nU2VyaWVzJz5cbiAgICAgICAgICAgICAge2ludGVycy5tYXAoKGludGVyLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgU3RhY2tDbXAgPSBnZXRUeXBlKHR5cGUsIGludGVyLmRhdGEsIGludGVyLmRhdGEuaWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIDxTdGFja0NtcFxuICAgICAgICAgICAgICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgICAgICAgICAgICAga2V5PXtpbnRlci5rZXl9XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcz17aW50ZXIuZGF0YX1cbiAgICAgICAgICAgICAgICAgICAgc3RhY2tEYXRhPXtzdGFja0RhdGF9XG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk9e2ludGVyLnN0YXRlLnZpc2liaWxpdHl9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgICAgKVxuICAgICAgICB9fVxuICAgICAgPC9UcmFuc2l0aW9uPlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25uZWN0KFxuICAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3JzID0ge1xuICAgICAgcHJpbWFyeUF4aXM6IFNlbGVjdG9ycy5wcmltYXJ5QXhpcygpLFxuICAgICAgc2Vjb25kYXJ5QXhpczogU2VsZWN0b3JzLnNlY29uZGFyeUF4aXMoKSxcbiAgICB9XG4gICAgcmV0dXJuIChzdGF0ZSwgcHJvcHMpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGVyaWFsaXplZERhdGE6IHN0YXRlLm1hdGVyaWFsaXplZERhdGEsXG4gICAgICAgIHN0YWNrRGF0YTogc3RhdGUuc3RhY2tEYXRhLFxuICAgICAgICBwcmltYXJ5QXhpczogc2VsZWN0b3JzLnByaW1hcnlBeGlzKHN0YXRlKSxcbiAgICAgICAgc2Vjb25kYXJ5QXhpczogc2VsZWN0b3JzLnNlY29uZGFyeUF4aXMoc3RhdGUpLFxuICAgICAgICBob3ZlcmVkOiBzdGF0ZS5ob3ZlcmVkLFxuICAgICAgICBzZWxlY3RlZDogc3RhdGUuc2VsZWN0ZWQsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB7XG4gICAgZmlsdGVyOiAob2xkU3RhdGUsIG5ld1N0YXRlLCBtZXRhKSA9PiBtZXRhLnR5cGUgIT09ICdjdXJzb3InLFxuICB9XG4pKFNlcmllcylcbiJdfQ==