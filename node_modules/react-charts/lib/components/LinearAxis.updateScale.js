'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = updateScale;

var _d3Scale = require('d3-scale');

var _Axis = require('./Axis');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
//


var scales = {
  linear: _d3Scale.scaleLinear,
  log: _d3Scale.scaleLog,
  time: _d3Scale.scaleTime,
  ordinal: _d3Scale.scaleBand
};

var detectVertical = function detectVertical(position) {
  return [_Axis.positionLeft, _Axis.positionRight].indexOf(position) > -1;
};
var detectRTL = function detectRTL(position) {
  return [_Axis.positionTop, _Axis.positionRight].indexOf(position) > -1;
};

function updateScale(props) {
  var id = props.id,
      type = props.type,
      position = props.position,
      invert = props.invert,
      primary = props.primary,
      stacked = props.stacked,
      innerPadding = props.innerPadding,
      outerPadding = props.outerPadding,
      tickArguments = props.tickArguments,
      tickValues = props.tickValues,
      tickFormat = props.tickFormat,
      tickPadding = props.tickPadding,
      tickSizeInner = props.tickSizeInner,
      materializedData = props.materializedData,
      width = props.width,
      height = props.height,
      primaryAxis = props.primaryAxis;

  // We need the data to proceed

  if (!materializedData) {
    return;
  }

  // If this axis is secondary, we need the primaryAxis to proceed
  if (!primary && !primaryAxis) {
    return;
  }

  // Detect some settings
  var valueKey = primary ? 'primary' : 'secondary';
  var groupKey = !primary && 'primary';
  var vertical = detectVertical(position);
  var RTL = primary && detectRTL(position); // Right to left OR top to bottom

  // TODO: Any sorting needs to happen here, else the min/max's might not line up correctly

  // First we need to find unique values, min/max values and negative/positive totals
  var uniqueVals = [];
  var min = 0;
  var max = 0;
  var datumValues = {};
  var negativeTotal = 0;
  var positiveTotal = 0;
  var domain = void 0;
  var total = void 0;

  if (type === 'ordinal') {
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d) {
        if (uniqueVals.indexOf(d) === -1) {
          uniqueVals.push(d);
        }
      });
    });
    domain = invert ? [].concat(uniqueVals).reverse() : uniqueVals;
  } else if (type === 'time') {
    var firstRow = materializedData[0].data[0] || {};
    min = max = firstRow[valueKey];
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return +d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.data[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      var seriesMin = Math.min.apply(Math, _toConsumableArray(seriesValues));
      var seriesMax = Math.max.apply(Math, _toConsumableArray(seriesValues));
      min = Math.min(min, seriesMin);
      max = Math.max(max, seriesMax);
    });
    domain = invert ? [max, min] : [min, max];
  } else {
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.data[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      var seriesMin = Math.min.apply(Math, _toConsumableArray(seriesValues));
      var seriesMax = Math.max.apply(Math, _toConsumableArray(seriesValues));
      min = Math.min(min, seriesMin);
      max = Math.max(max, seriesMax);
    });
    if (stacked) {
      // If we're stacking, calculate and use the max and min values for the largest stack
      ;
      var _Object$keys$map$redu = Object.keys(datumValues).map(function (d) {
        return datumValues[d];
      }).reduce(function (totals, vals) {
        var positive = vals.filter(function (d) {
          return d >= 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        var negative = vals.filter(function (d) {
          return d < 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        return [positive > totals[0] ? positive : totals[0], negative < totals[1] ? negative : totals[1]];
      }, [0, 0]);

      var _Object$keys$map$redu2 = _slicedToArray(_Object$keys$map$redu, 2);

      positiveTotal = _Object$keys$map$redu2[0];
      negativeTotal = _Object$keys$map$redu2[1];

      domain = invert ? [positiveTotal, negativeTotal] : [negativeTotal, positiveTotal];
    } else {
      // If we're not stacking, use the min and max values
      domain = invert ? [max, min] : [min, max];
    }
  }

  // Now we need to figure out the range
  var range = vertical ? invert ? [0, height] : [height, 0] // If the axis is inverted, swap the range, too
  : invert ? [width, 0] : [0, width];

  // var arc = d3.svg.arc()
  //   .outerRadius(radius - 10)
  //   .innerRadius(radius - 70);

  if (!primary) {
    // Secondary axes are usually dependent on primary axes for orientation, so if the
    // primaryAxis is in RTL mode, we need to reverse the range on this secondary axis
    // to match the origin of the primary axis
    if (primaryAxis.RTL) {
      range = range.reverse();
    }
  }

  // The the scale a home
  var scale = void 0;

  // If this is an ordinal or other primary axis, it needs to be able to display bars.
  var bandScale = void 0;
  var barSize = 1;
  var stepSize = 0;

  if (type === 'ordinal' || primary) {
    // Calculate a band axis that is similar and pass down the bandwidth
    // just in case.
    bandScale = (0, _d3Scale.scaleBand)().domain(materializedData.reduce(function (prev, current) {
      return current.data.length > prev.length ? current.data : prev;
    }, []).map(function (d) {
      return d.primary;
    })).rangeRound(range, 0.1).padding(0);

    if (type === 'ordinal') {
      bandScale.paddingOuter(outerPadding).paddingInner(innerPadding);
      barSize = bandScale.bandwidth();
    } else {
      barSize = bandScale.bandwidth();
    }

    stepSize = bandScale.step();
  }

  if (type === 'ordinal') {
    // If it's ordinal, just assign the bandScale we made
    scale = bandScale;
  } else {
    // Otherwise, create a new scale of the appropriate type
    scale = scales[type]();
  }

  // Set the domain
  scale.domain(domain);

  // Now set the range
  scale.range(range);

  // If we're not using an ordinal scale, round the ticks to "nice" values
  if (type !== 'ordinal') {
    scale.nice();
  }

  // Pass down the axis config (including the scale itself) for posterity
  var axis = {
    type: type,
    scale: scale,
    uniqueVals: uniqueVals,
    primary: primary,
    invert: invert,
    vertical: vertical,
    RTL: RTL,
    position: position,
    stacked: stacked,
    barSize: barSize,
    stepSize: stepSize,
    domain: domain,
    range: range,
    max: position === _Axis.positionBottom ? -height : position === _Axis.positionLeft ? width : position === _Axis.positionTop ? height : -width,
    directionMultiplier: position === _Axis.positionTop || position === _Axis.positionLeft ? -1 : 1,
    transform: !vertical ? translateX : translateY,
    ticks: this.ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
    format: tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity : tickFormat,
    spacing: Math.max(tickSizeInner, 0) + tickPadding
  };

  if (type === 'ordinal') {
    axis.gridOffset = -(axis.stepSize * innerPadding) / 2;
    axis.tickOffset = axis.barSize / 2;
    axis.barOffset = 0;
  } else {
    axis.tickOffset = 0;
    axis.barOffset = -axis.barSize / 2;
  }

  // Make sure we start with a prevAxis
  this.prevAxis = this.prevAxis || axis;

  this.props.dispatch(function (state) {
    return _extends({}, state, {
      axes: _extends({}, state.axes, _defineProperty({}, id, axis))
    });
  }, {
    type: 'axisUpdateScale'
  });
}

function identity(x) {
  return x;
}

function translateX(x) {
  return 'translate(' + x + ', 0)';
}

function translateY(y) {
  return 'translate(0, ' + y + ')';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0xpbmVhckF4aXMudXBkYXRlU2NhbGUuanMiXSwibmFtZXMiOlsidXBkYXRlU2NhbGUiLCJzY2FsZXMiLCJsaW5lYXIiLCJsb2ciLCJ0aW1lIiwib3JkaW5hbCIsImRldGVjdFZlcnRpY2FsIiwiaW5kZXhPZiIsInBvc2l0aW9uIiwiZGV0ZWN0UlRMIiwicHJvcHMiLCJpZCIsInR5cGUiLCJpbnZlcnQiLCJwcmltYXJ5Iiwic3RhY2tlZCIsImlubmVyUGFkZGluZyIsIm91dGVyUGFkZGluZyIsInRpY2tBcmd1bWVudHMiLCJ0aWNrVmFsdWVzIiwidGlja0Zvcm1hdCIsInRpY2tQYWRkaW5nIiwidGlja1NpemVJbm5lciIsIm1hdGVyaWFsaXplZERhdGEiLCJ3aWR0aCIsImhlaWdodCIsInByaW1hcnlBeGlzIiwidmFsdWVLZXkiLCJncm91cEtleSIsInZlcnRpY2FsIiwiUlRMIiwidW5pcXVlVmFscyIsIm1pbiIsIm1heCIsImRhdHVtVmFsdWVzIiwibmVnYXRpdmVUb3RhbCIsInBvc2l0aXZlVG90YWwiLCJkb21haW4iLCJ0b3RhbCIsImZvckVhY2giLCJzZXJpZXNWYWx1ZXMiLCJzZXJpZXMiLCJkYXRhIiwibWFwIiwiZCIsInB1c2giLCJyZXZlcnNlIiwiZmlyc3RSb3ciLCJpIiwia2V5Iiwic2VyaWVzTWluIiwiTWF0aCIsInNlcmllc01heCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJ0b3RhbHMiLCJ2YWxzIiwicG9zaXRpdmUiLCJmaWx0ZXIiLCJkcyIsIm5lZ2F0aXZlIiwicmFuZ2UiLCJzY2FsZSIsImJhbmRTY2FsZSIsImJhclNpemUiLCJzdGVwU2l6ZSIsInByZXYiLCJjdXJyZW50IiwibGVuZ3RoIiwicmFuZ2VSb3VuZCIsInBhZGRpbmciLCJwYWRkaW5nT3V0ZXIiLCJwYWRkaW5nSW5uZXIiLCJiYW5kd2lkdGgiLCJzdGVwIiwibmljZSIsImF4aXMiLCJkaXJlY3Rpb25NdWx0aXBsaWVyIiwidHJhbnNmb3JtIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJ0aWNrcyIsImFwcGx5IiwiZm9ybWF0IiwiaWRlbnRpdHkiLCJzcGFjaW5nIiwiZ3JpZE9mZnNldCIsInRpY2tPZmZzZXQiLCJiYXJPZmZzZXQiLCJwcmV2QXhpcyIsImRpc3BhdGNoIiwic3RhdGUiLCJheGVzIiwieCIsInkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7a0JBcUJ3QkEsVzs7QUFyQnhCOztBQUVBOzs7OztBQURBOzs7QUFRQSxJQUFNQyxTQUFTO0FBQ2JDLDhCQURhO0FBRWJDLHdCQUZhO0FBR2JDLDBCQUhhO0FBSWJDO0FBSmEsQ0FBZjs7QUFPQSxJQUFNQyxpQkFBaUIsU0FBakJBLGNBQWlCO0FBQUEsU0FDckIsMENBQThCQyxPQUE5QixDQUFzQ0MsUUFBdEMsSUFBa0QsQ0FBQyxDQUQ5QjtBQUFBLENBQXZCO0FBRUEsSUFBTUMsWUFBWSxTQUFaQSxTQUFZO0FBQUEsU0FDaEIseUNBQTZCRixPQUE3QixDQUFxQ0MsUUFBckMsSUFBaUQsQ0FBQyxDQURsQztBQUFBLENBQWxCOztBQUdlLFNBQVNSLFdBQVQsQ0FBcUJVLEtBQXJCLEVBQTRCO0FBQUEsTUFHdkNDLEVBSHVDLEdBc0JyQ0QsS0F0QnFDLENBR3ZDQyxFQUh1QztBQUFBLE1BS3ZDQyxJQUx1QyxHQXNCckNGLEtBdEJxQyxDQUt2Q0UsSUFMdUM7QUFBQSxNQU12Q0osUUFOdUMsR0FzQnJDRSxLQXRCcUMsQ0FNdkNGLFFBTnVDO0FBQUEsTUFPdkNLLE1BUHVDLEdBc0JyQ0gsS0F0QnFDLENBT3ZDRyxNQVB1QztBQUFBLE1BUXZDQyxPQVJ1QyxHQXNCckNKLEtBdEJxQyxDQVF2Q0ksT0FSdUM7QUFBQSxNQVN2Q0MsT0FUdUMsR0FzQnJDTCxLQXRCcUMsQ0FTdkNLLE9BVHVDO0FBQUEsTUFVdkNDLFlBVnVDLEdBc0JyQ04sS0F0QnFDLENBVXZDTSxZQVZ1QztBQUFBLE1BV3ZDQyxZQVh1QyxHQXNCckNQLEtBdEJxQyxDQVd2Q08sWUFYdUM7QUFBQSxNQVl2Q0MsYUFa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R0FBYjs7QUFrQ0EsTUFBSVQsU0FBUyxTQUFiLEVBQXdCO0FBQ3RCaUUsU0FBS1UsVUFBTCxHQUFrQixFQUFFVixLQUFLWCxRQUFMLEdBQWdCbEQsWUFBbEIsSUFBa0MsQ0FBcEQ7QUFDQTZELFNBQUtXLFVBQUwsR0FBa0JYLEtBQUtaLE9BQUwsR0FBZSxDQUFqQztBQUNBWSxTQUFLWSxTQUFMLEdBQWlCLENBQWpCO0FBQ0QsR0FKRCxNQUlPO0FBQ0xaLFNBQUtXLFVBQUwsR0FBa0IsQ0FBbEI7QUFDQVgsU0FBS1ksU0FBTCxHQUFpQixDQUFDWixLQUFLWixPQUFOLEdBQWdCLENBQWpDO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFLeUIsUUFBTCxHQUFnQixLQUFLQSxRQUFMLElBQWlCYixJQUFqQzs7QUFFQSxPQUFLbkUsS0FBTCxDQUFXaUYsUUFBWCxDQUNFO0FBQUEsd0JBQ0tDLEtBREw7QUFFRUMseUJBQ0tELE1BQU1DLElBRFgsc0JBRUdsRixFQUZILEVBRVFrRSxJQUZSO0FBRkY7QUFBQSxHQURGLEVBUUU7QUFDRWpFLFVBQU07QUFEUixHQVJGO0FBWUQ7O0FBRUQsU0FBU3lFLFFBQVQsQ0FBa0JTLENBQWxCLEVBQXFCO0FBQ25CLFNBQU9BLENBQVA7QUFDRDs7QUFFRCxTQUFTZCxVQUFULENBQW9CYyxDQUFwQixFQUF1QjtBQUNyQixTQUFPLGVBQWVBLENBQWYsR0FBbUIsTUFBMUI7QUFDRDs7QUFFRCxTQUFTYixVQUFULENBQW9CYyxDQUFwQixFQUF1QjtBQUNyQixTQUFPLGtCQUFrQkEsQ0FBbEIsR0FBc0IsR0FBN0I7QUFDRCIsImZpbGUiOiJMaW5lYXJBeGlzLnVwZGF0ZVNjYWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2NhbGVMaW5lYXIsIHNjYWxlTG9nLCBzY2FsZVRpbWUsIHNjYWxlQmFuZCB9IGZyb20gJ2QzLXNjYWxlJ1xuLy9cbmltcG9ydCB7XG4gIHBvc2l0aW9uVG9wLFxuICBwb3NpdGlvbkxlZnQsXG4gIHBvc2l0aW9uUmlnaHQsXG4gIHBvc2l0aW9uQm90dG9tLFxufSBmcm9tICcuL0F4aXMnXG5cbmNvbnN0IHNjYWxlcyA9IHtcbiAgbGluZWFyOiBzY2FsZUxpbmVhcixcbiAgbG9nOiBzY2FsZUxvZyxcbiAgdGltZTogc2NhbGVUaW1lLFxuICBvcmRpbmFsOiBzY2FsZUJhbmQsXG59XG5cbmNvbnN0IGRldGVjdFZlcnRpY2FsID0gcG9zaXRpb24gPT5cbiAgW3Bvc2l0aW9uTGVmdCwgcG9zaXRpb25SaWdodF0uaW5kZXhPZihwb3NpdGlvbikgPiAtMVxuY29uc3QgZGV0ZWN0UlRMID0gcG9zaXRpb24gPT5cbiAgW3Bvc2l0aW9uVG9wLCBwb3NpdGlvblJpZ2h0XS5pbmRleE9mKHBvc2l0aW9uKSA+IC0xXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVwZGF0ZVNjYWxlKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICAvLyBDb21wdXRlZFxuICAgIGlkLFxuICAgIC8vIFByb3BzXG4gICAgdHlwZSxcbiAgICBwb3NpdGlvbixcbiAgICBpbnZlcnQsXG4gICAgcHJpbWFyeSxcbiAgICBzdGFja2VkLFxuICAgIGlubmVyUGFkZGluZyxcbiAgICBvdXRlclBhZGRpbmcsXG4gICAgdGlja0FyZ3VtZW50cyxcbiAgICB0aWNrVmFsdWVzLFxuICAgIHRpY2tGb3JtYXQsXG4gICAgdGlja1BhZGRpbmcsXG4gICAgdGlja1NpemVJbm5lcixcbiAgICAvLyBDb250ZXh0XG4gICAgbWF0ZXJpYWxpemVkRGF0YSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgcHJpbWFyeUF4aXMsXG4gIH0gPSBwcm9wc1xuXG4gIC8vIFdlIG5lZWQgdGhlIGRhdGEgdG8gcHJvY2VlZFxuICBpZiAoIW1hdGVyaWFsaXplZERhdGEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIElmIHRoaXMgYXhpcyBpcyBzZWNvbmRhcnksIHdlIG5lZWQgdGhlIHByaW1hcnlBeGlzIHRvIHByb2NlZWRcbiAgaWYgKCFwcmltYXJ5ICYmICFwcmltYXJ5QXhpcykge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gRGV0ZWN0IHNvbWUgc2V0dGluZ3NcbiAgY29uc3QgdmFsdWVLZXkgPSBwcmltYXJ5ID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSdcbiAgY29uc3QgZ3JvdXBLZXkgPSAhcHJpbWFyeSAmJiAncHJpbWFyeSdcbiAgY29uc3QgdmVydGljYWwgPSBkZXRlY3RWZXJ0aWNhbChwb3NpdGlvbilcbiAgY29uc3QgUlRMID0gcHJpbWFyeSAmJiBkZXRlY3RSVEwocG9zaXRpb24pIC8vIFJpZ2h0IHRvIGxlZnQgT1IgdG9wIHRvIGJvdHRvbVxuXG4gIC8vIFRPRE86IEFueSBzb3J0aW5nIG5lZWRzIHRvIGhhcHBlbiBoZXJlLCBlbHNlIHRoZSBtaW4vbWF4J3MgbWlnaHQgbm90IGxpbmUgdXAgY29ycmVjdGx5XG5cbiAgLy8gRmlyc3Qgd2UgbmVlZCB0byBmaW5kIHVuaXF1ZSB2YWx1ZXMsIG1pbi9tYXggdmFsdWVzIGFuZCBuZWdhdGl2ZS9wb3NpdGl2ZSB0b3RhbHNcbiAgbGV0IHVuaXF1ZVZhbHMgPSBbXVxuICBsZXQgbWluID0gMFxuICBsZXQgbWF4ID0gMFxuICBsZXQgZGF0dW1WYWx1ZXMgPSB7fVxuICBsZXQgbmVnYXRpdmVUb3RhbCA9IDBcbiAgbGV0IHBvc2l0aXZlVG90YWwgPSAwXG4gIGxldCBkb21haW5cbiAgbGV0IHRvdGFsXG5cbiAgaWYgKHR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgIG1hdGVyaWFsaXplZERhdGEuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzVmFsdWVzID0gc2VyaWVzLmRhdGEubWFwKGQgPT4gZFt2YWx1ZUtleV0pXG4gICAgICBzZXJpZXNWYWx1ZXMuZm9yRWFjaChkID0+IHtcbiAgICAgICAgaWYgKHVuaXF1ZVZhbHMuaW5kZXhPZihkKSA9PT0gLTEpIHtcbiAgICAgICAgICB1bmlxdWVWYWxzLnB1c2goZClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIGRvbWFpbiA9IGludmVydCA/IFsuLi51bmlxdWVWYWxzXS5yZXZlcnNlKCkgOiB1bmlxdWVWYWxzXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgY29uc3QgZmlyc3RSb3cgPSBtYXRlcmlhbGl6ZWREYXRhWzBdLmRhdGFbMF0gfHwge31cbiAgICBtaW4gPSBtYXggPSBmaXJzdFJvd1t2YWx1ZUtleV1cbiAgICBtYXRlcmlhbGl6ZWREYXRhLmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc1ZhbHVlcyA9IHNlcmllcy5kYXRhLm1hcChkID0+ICtkW3ZhbHVlS2V5XSlcbiAgICAgIHNlcmllc1ZhbHVlcy5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdyb3VwS2V5ID8gc2VyaWVzLmRhdGFbaV1bZ3JvdXBLZXldIDogaVxuICAgICAgICBkYXR1bVZhbHVlc1trZXldID0gWy4uLihkYXR1bVZhbHVlc1trZXldIHx8IFtdKSwgZF1cbiAgICAgIH0pXG4gICAgICBjb25zdCBzZXJpZXNNaW4gPSBNYXRoLm1pbiguLi5zZXJpZXNWYWx1ZXMpXG4gICAgICBjb25zdCBzZXJpZXNNYXggPSBNYXRoLm1heCguLi5zZXJpZXNWYWx1ZXMpXG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHNlcmllc01pbilcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgc2VyaWVzTWF4KVxuICAgIH0pXG4gICAgZG9tYWluID0gaW52ZXJ0ID8gW21heCwgbWluXSA6IFttaW4sIG1heF1cbiAgfSBlbHNlIHtcbiAgICBtYXRlcmlhbGl6ZWREYXRhLmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc1ZhbHVlcyA9IHNlcmllcy5kYXRhLm1hcChkID0+IGRbdmFsdWVLZXldKVxuICAgICAgc2VyaWVzVmFsdWVzLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ3JvdXBLZXkgPyBzZXJpZXMuZGF0YVtpXVtncm91cEtleV0gOiBpXG4gICAgICAgIGRhdHVtVmFsdWVzW2tleV0gPSBbLi4uKGRhdHVtVmFsdWVzW2tleV0gfHwgW10pLCBkXVxuICAgICAgfSlcbiAgICAgIGNvbnN0IHNlcmllc01pbiA9IE1hdGgubWluKC4uLnNlcmllc1ZhbHVlcylcbiAgICAgIGNvbnN0IHNlcmllc01heCA9IE1hdGgubWF4KC4uLnNlcmllc1ZhbHVlcylcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgc2VyaWVzTWluKVxuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBzZXJpZXNNYXgpXG4gICAgfSlcbiAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgLy8gSWYgd2UncmUgc3RhY2tpbmcsIGNhbGN1bGF0ZSBhbmQgdXNlIHRoZSBtYXggYW5kIG1pbiB2YWx1ZXMgZm9yIHRoZSBsYXJnZXN0IHN0YWNrXG4gICAgICA7W3Bvc2l0aXZlVG90YWwsIG5lZ2F0aXZlVG90YWxdID0gT2JqZWN0LmtleXMoZGF0dW1WYWx1ZXMpXG4gICAgICAgIC5tYXAoZCA9PiBkYXR1bVZhbHVlc1tkXSlcbiAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAodG90YWxzLCB2YWxzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGl2ZSA9IHZhbHNcbiAgICAgICAgICAgICAgLmZpbHRlcihkID0+IGQgPj0gMClcbiAgICAgICAgICAgICAgLnJlZHVjZSgoZHMsIGQpID0+IGRzICsgZCwgMClcbiAgICAgICAgICAgIGNvbnN0IG5lZ2F0aXZlID0gdmFsc1xuICAgICAgICAgICAgICAuZmlsdGVyKGQgPT4gZCA8IDApXG4gICAgICAgICAgICAgIC5yZWR1Y2UoKGRzLCBkKSA9PiBkcyArIGQsIDApXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBwb3NpdGl2ZSA+IHRvdGFsc1swXSA/IHBvc2l0aXZlIDogdG90YWxzWzBdLFxuICAgICAgICAgICAgICBuZWdhdGl2ZSA8IHRvdGFsc1sxXSA/IG5lZ2F0aXZlIDogdG90YWxzWzFdLFxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgWzAsIDBdXG4gICAgICAgIClcbiAgICAgIGRvbWFpbiA9IGludmVydFxuICAgICAgICA/IFtwb3NpdGl2ZVRvdGFsLCBuZWdhdGl2ZVRvdGFsXVxuICAgICAgICA6IFtuZWdhdGl2ZVRvdGFsLCBwb3NpdGl2ZVRvdGFsXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgc3RhY2tpbmcsIHVzZSB0aGUgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgICBkb21haW4gPSBpbnZlcnQgPyBbbWF4LCBtaW5dIDogW21pbiwgbWF4XVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgdGhlIHJhbmdlXG4gIGxldCByYW5nZSA9IHZlcnRpY2FsXG4gICAgPyBpbnZlcnQgPyBbMCwgaGVpZ2h0XSA6IFtoZWlnaHQsIDBdIC8vIElmIHRoZSBheGlzIGlzIGludmVydGVkLCBzd2FwIHRoZSByYW5nZSwgdG9vXG4gICAgOiBpbnZlcnQgPyBbd2lkdGgsIDBdIDogWzAsIHdpZHRoXVxuXG4gIC8vIHZhciBhcmMgPSBkMy5zdmcuYXJjKClcbiAgLy8gICAub3V0ZXJSYWRpdXMocmFkaXVzIC0gMTApXG4gIC8vICAgLmlubmVyUmFkaXVzKHJhZGl1cyAtIDcwKTtcblxuICBpZiAoIXByaW1hcnkpIHtcbiAgICAvLyBTZWNvbmRhcnkgYXhlcyBhcmUgdXN1YWxseSBkZXBlbmRlbnQgb24gcHJpbWFyeSBheGVzIGZvciBvcmllbnRhdGlvbiwgc28gaWYgdGhlXG4gICAgLy8gcHJpbWFyeUF4aXMgaXMgaW4gUlRMIG1vZGUsIHdlIG5lZWQgdG8gcmV2ZXJzZSB0aGUgcmFuZ2Ugb24gdGhpcyBzZWNvbmRhcnkgYXhpc1xuICAgIC8vIHRvIG1hdGNoIHRoZSBvcmlnaW4gb2YgdGhlIHByaW1hcnkgYXhpc1xuICAgIGlmIChwcmltYXJ5QXhpcy5SVEwpIHtcbiAgICAgIHJhbmdlID0gcmFuZ2UucmV2ZXJzZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIHRoZSBzY2FsZSBhIGhvbWVcbiAgbGV0IHNjYWxlXG5cbiAgLy8gSWYgdGhpcyBpcyBhbiBvcmRpbmFsIG9yIG90aGVyIHByaW1hcnkgYXhpcywgaXQgbmVlZHMgdG8gYmUgYWJsZSB0byBkaXNwbGF5IGJhcnMuXG4gIGxldCBiYW5kU2NhbGVcbiAgbGV0IGJhclNpemUgPSAxXG4gIGxldCBzdGVwU2l6ZSA9IDBcblxuICBpZiAodHlwZSA9PT0gJ29yZGluYWwnIHx8IHByaW1hcnkpIHtcbiAgICAvLyBDYWxjdWxhdGUgYSBiYW5kIGF4aXMgdGhhdCBpcyBzaW1pbGFyIGFuZCBwYXNzIGRvd24gdGhlIGJhbmR3aWR0aFxuICAgIC8vIGp1c3QgaW4gY2FzZS5cbiAgICBiYW5kU2NhbGUgPSBzY2FsZUJhbmQoKVxuICAgICAgLmRvbWFpbihcbiAgICAgICAgbWF0ZXJpYWxpemVkRGF0YVxuICAgICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgICAocHJldiwgY3VycmVudCkgPT5cbiAgICAgICAgICAgICAgY3VycmVudC5kYXRhLmxlbmd0aCA+IHByZXYubGVuZ3RoID8gY3VycmVudC5kYXRhIDogcHJldixcbiAgICAgICAgICAgIFtdXG4gICAgICAgICAgKVxuICAgICAgICAgIC5tYXAoZCA9PiBkLnByaW1hcnkpXG4gICAgICApXG4gICAgICAucmFuZ2VSb3VuZChyYW5nZSwgMC4xKVxuICAgICAgLnBhZGRpbmcoMClcblxuICAgIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgIGJhbmRTY2FsZS5wYWRkaW5nT3V0ZXIob3V0ZXJQYWRkaW5nKS5wYWRkaW5nSW5uZXIoaW5uZXJQYWRkaW5nKVxuICAgICAgYmFyU2l6ZSA9IGJhbmRTY2FsZS5iYW5kd2lkdGgoKVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXJTaXplID0gYmFuZFNjYWxlLmJhbmR3aWR0aCgpXG4gICAgfVxuXG4gICAgc3RlcFNpemUgPSBiYW5kU2NhbGUuc3RlcCgpXG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgLy8gSWYgaXQncyBvcmRpbmFsLCBqdXN0IGFzc2lnbiB0aGUgYmFuZFNjYWxlIHdlIG1hZGVcbiAgICBzY2FsZSA9IGJhbmRTY2FsZVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGEgbmV3IHNjYWxlIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlXG4gICAgc2NhbGUgPSBzY2FsZXNbdHlwZV0oKVxuICB9XG5cbiAgLy8gU2V0IHRoZSBkb21haW5cbiAgc2NhbGUuZG9tYWluKGRvbWFpbilcblxuICAvLyBOb3cgc2V0IHRoZSByYW5nZVxuICBzY2FsZS5yYW5nZShyYW5nZSlcblxuICAvLyBJZiB3ZSdyZSBub3QgdXNpbmcgYW4gb3JkaW5hbCBzY2FsZSwgcm91bmQgdGhlIHRpY2tzIHRvIFwibmljZVwiIHZhbHVlc1xuICBpZiAodHlwZSAhPT0gJ29yZGluYWwnKSB7XG4gICAgc2NhbGUubmljZSgpXG4gIH1cblxuICAvLyBQYXNzIGRvd24gdGhlIGF4aXMgY29uZmlnIChpbmNsdWRpbmcgdGhlIHNjYWxlIGl0c2VsZikgZm9yIHBvc3Rlcml0eVxuICBjb25zdCBheGlzID0ge1xuICAgIHR5cGUsXG4gICAgc2NhbGUsXG4gICAgdW5pcXVlVmFscyxcbiAgICBwcmltYXJ5LFxuICAgIGludmVydCxcbiAgICB2ZXJ0aWNhbCxcbiAgICBSVEwsXG4gICAgcG9zaXRpb24sXG4gICAgc3RhY2tlZCxcbiAgICBiYXJTaXplLFxuICAgIHN0ZXBTaXplLFxuICAgIGRvbWFpbixcbiAgICByYW5nZSxcbiAgICBtYXg6IHBvc2l0aW9uID09PSBwb3NpdGlvbkJvdHRvbVxuICAgICAgPyAtaGVpZ2h0XG4gICAgICA6IHBvc2l0aW9uID09PSBwb3NpdGlvbkxlZnRcbiAgICAgICAgICA/IHdpZHRoXG4gICAgICAgICAgOiBwb3NpdGlvbiA9PT0gcG9zaXRpb25Ub3AgPyBoZWlnaHQgOiAtd2lkdGgsXG4gICAgZGlyZWN0aW9uTXVsdGlwbGllcjogcG9zaXRpb24gPT09IHBvc2l0aW9uVG9wIHx8IHBvc2l0aW9uID09PSBwb3NpdGlvbkxlZnRcbiAgICAgID8gLTFcbiAgICAgIDogMSxcbiAgICB0cmFuc2Zvcm06ICF2ZXJ0aWNhbCA/IHRyYW5zbGF0ZVggOiB0cmFuc2xhdGVZLFxuICAgIHRpY2tzOiAodGhpcy50aWNrcyA9IHRpY2tWYWx1ZXMgPT0gbnVsbFxuICAgICAgPyBzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpXG4gICAgICA6IHRpY2tWYWx1ZXMpLFxuICAgIGZvcm1hdDogdGlja0Zvcm1hdCA9PSBudWxsXG4gICAgICA/IHNjYWxlLnRpY2tGb3JtYXRcbiAgICAgICAgICA/IHNjYWxlLnRpY2tGb3JtYXQuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpXG4gICAgICAgICAgOiBpZGVudGl0eVxuICAgICAgOiB0aWNrRm9ybWF0LFxuICAgIHNwYWNpbmc6IE1hdGgubWF4KHRpY2tTaXplSW5uZXIsIDApICsgdGlja1BhZGRpbmcsXG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgYXhpcy5ncmlkT2Zmc2V0ID0gLShheGlzLnN0ZXBTaXplICogaW5uZXJQYWRkaW5nKSAvIDJcbiAgICBheGlzLnRpY2tPZmZzZXQgPSBheGlzLmJhclNpemUgLyAyXG4gICAgYXhpcy5iYXJPZmZzZXQgPSAwXG4gIH0gZWxzZSB7XG4gICAgYXhpcy50aWNrT2Zmc2V0ID0gMFxuICAgIGF4aXMuYmFyT2Zmc2V0ID0gLWF4aXMuYmFyU2l6ZSAvIDJcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBzdGFydCB3aXRoIGEgcHJldkF4aXNcbiAgdGhpcy5wcmV2QXhpcyA9IHRoaXMucHJldkF4aXMgfHwgYXhpc1xuXG4gIHRoaXMucHJvcHMuZGlzcGF0Y2goXG4gICAgc3RhdGUgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgYXhlczoge1xuICAgICAgICAuLi5zdGF0ZS5heGVzLFxuICAgICAgICBbaWRdOiBheGlzLFxuICAgICAgfSxcbiAgICB9KSxcbiAgICB7XG4gICAgICB0eXBlOiAnYXhpc1VwZGF0ZVNjYWxlJyxcbiAgICB9XG4gIClcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geFxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVYKHgpIHtcbiAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHggKyAnLCAwKSdcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlWSh5KSB7XG4gIHJldHVybiAndHJhbnNsYXRlKDAsICcgKyB5ICsgJyknXG59XG4iXX0=