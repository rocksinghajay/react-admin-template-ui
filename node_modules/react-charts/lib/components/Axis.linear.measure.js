'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = measure;

var _Axis = require('./Axis');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var fontSize = 10;

var getPixel = function getPixel(d) {
  return d;
};
var radiansToDegrees = function radiansToDegrees(r) {
  return r * (180 / Math.PI);
};

function measure() {
  // Measure finds the amount of overflow this axis produces and
  // updates the margins to ensure that the axis is visibility
  // Unfortunately, this currently happens after a render, but potentially
  // could happen pre-render if we could reliably predict the size of the
  // labels before they render. Considering that ticks could be anything,
  // even a react component, this could get very tough.
  var _props = this.props,
      axis = _props.axis,
      tickSizeInner = _props.tickSizeInner,
      tickSizeOuter = _props.tickSizeOuter,
      tickPadding = _props.tickPadding,
      maxLabelRotation = _props.maxLabelRotation,
      position = _props.position,
      dispatch = _props.dispatch;
  var rotation = this.rotation,
      visibleLabelStep = this.visibleLabelStep;


  if (!this.el) {
    return;
  }

  var isHorizontal = position === _Axis.positionTop || position === _Axis.positionBottom;
  var labelDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick.-measureable text'))).map(function (el) {
    return el.getBoundingClientRect();
  });

  var smallestTickGap = 10000; // This is just a ridiculously large tick spacing that would never happen (hopefully)
  // If the axis is horizontal, we need to determine any necessary rotation and tick skipping
  if (isHorizontal) {
    var tickDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick.-measureable'))).map(function (el) {
      return el.getBoundingClientRect();
    });
    tickDims.reduce(function (prev, current) {
      if (prev) {
        var gap = current.left - prev.left - fontSize / 2;
        smallestTickGap = gap < smallestTickGap ? gap : smallestTickGap;
      }
      return current;
    }, false);
    var largestLabel = labelDims.reduce(function (prev, current) {
      current._overflow = current.width - smallestTickGap;
      if (current._overflow > 0 && current._overflow > prev._overflow) {
        return current;
      }
      return prev;
    }, { _overflow: 0 });

    var newRotation = Math.min(Math.max(Math.abs(radiansToDegrees(Math.acos(smallestTickGap / largestLabel.width))), 0), maxLabelRotation);
    newRotation = isNaN(newRotation) ? 0 : newRotation;

    if (Math.floor(rotation) !== Math.floor(newRotation)) {
      this.rotation = axis.position === 'top' ? -newRotation : newRotation;
    }
  }

  var newVisibleLabelStep = Math.ceil(fontSize / smallestTickGap);

  if (visibleLabelStep !== newVisibleLabelStep) {
    this.visibleLabelStep = newVisibleLabelStep;
  }

  if (!labelDims.length || labelDims.length !== this.ticks.length) {
    return false;
  }

  var width = 0;
  var height = 0;
  var top = 0;
  var bottom = 0;
  var left = 0;
  var right = 0;

  // Determine axis rotation before we measure

  if (isHorizontal) {
    // Add width overflow from the first and last ticks
    left = Math.ceil(getPixel(labelDims[0].width) / 2);
    right = Math.ceil(getPixel(labelDims[labelDims.length - 1].width) / 2);
    height = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.height));
    }))); // Add the height of the largest label
  } else {
    // Add height overflow from the first and last ticks
    top = Math.ceil(getPixel(labelDims[0].height) / 2);
    bottom = Math.ceil(getPixel(labelDims[labelDims.length - 1].height) / 2);
    width = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.width));
    }))); // Add the width of the largest label
  }

  dispatch(function (state) {
    return _extends({}, state, {
      axisDimensions: _extends({}, state.axisDimensions, _defineProperty({}, position, {
        width: width,
        height: height,
        top: top,
        bottom: bottom,
        left: left,
        right: right
      }))
    });
  }, {
    type: 'axisDimensions'
  });

  return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0F4aXMubGluZWFyLm1lYXN1cmUuanMiXSwibmFtZXMiOlsibWVhc3VyZSIsImZvbnRTaXplIiwiZ2V0UGl4ZWwiLCJkIiwicmFkaWFuc1RvRGVncmVlcyIsInIiLCJNYXRoIiwiUEkiLCJwcm9wcyIsImF4aXMiLCJ0aWNrU2l6ZUlubmVyIiwidGlja1NpemVPdXRlciIsInRpY2tQYWRkaW5nIiwibWF4TGFiZWxSb3RhdGlvbiIsInBvc2l0aW9uIiwiZGlzcGF0Y2giLCJyb3RhdGlvbiIsInZpc2libGVMYWJlbFN0ZXAiLCJlbCIsImlzSG9yaXpvbnRhbCIsImxhYmVsRGltcyIsIkFycmF5IiwicXVlcnlTZWxlY3RvckFsbCIsIm1hcCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNtYWxsZXN0VGlja0dhcCIsInRpY2tEaW1zIiwicmVkdWNlIiwicHJldiIsImN1cnJlbnQiLCJnYXAiLCJsZWZ0IiwibGFyZ2VzdExhYmVsIiwiX292ZXJmbG93Iiwid2lkdGgiLCJuZXdSb3RhdGlvbiIsIm1pbiIsIm1heCIsImFicyIsImFjb3MiLCJpc05hTiIsImZsb29yIiwibmV3VmlzaWJsZUxhYmVsU3RlcCIsImNlaWwiLCJsZW5ndGgiLCJ0aWNrcyIsImhlaWdodCIsInRvcCIsImJvdHRvbSIsInJpZ2h0Iiwic3RhdGUiLCJheGlzRGltZW5zaW9ucyIsInR5cGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O2tCQVV3QkEsTzs7QUFWeEI7Ozs7OztBQUtBLElBQU1DLFdBQVcsRUFBakI7O0FBRUEsSUFBTUMsV0FBVyxTQUFYQSxRQUFXO0FBQUEsU0FBS0MsQ0FBTDtBQUFBLENBQWpCO0FBQ0EsSUFBTUMsbUJBQW1CLFNBQW5CQSxnQkFBbUI7QUFBQSxTQUFLQyxLQUFLLE1BQU1DLEtBQUtDLEVBQWhCLENBQUw7QUFBQSxDQUF6Qjs7QUFFZSxTQUFTUCxPQUFULEdBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5p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LFNBQUsrQixHQUFMLGdDQUFZakIsVUFBVUcsR0FBVixDQUFjO0FBQUEsYUFBS2pCLEtBQUtxQyxJQUFMLENBQVV6QyxTQUFTQyxFQUFFK0IsS0FBWCxDQUFWLENBQUw7QUFBQSxLQUFkLENBQVosRUFIRixDQUpLLENBTzJEO0FBQ2pFOztBQUVEbkIsV0FBUztBQUFBLHdCQUNKbUMsS0FESTtBQUVQQyxtQ0FDS0QsTUFBTUMsY0FEWCxzQkFFR3JDLFFBRkgsRUFFYztBQUNWb0Isb0JBRFU7QUFFVlksc0JBRlU7QUFHVkMsZ0JBSFU7QUFJVkMsc0JBSlU7QUFLVmpCLGtCQUxVO0FBTVZrQjtBQU5VLE9BRmQ7QUFGTztBQUFBLEdBQVQsRUFhSTtBQUNGRyxVQUFNO0FBREosR0FiSjs7QUFpQkEsU0FBTyxJQUFQO0FBQ0QiLCJmaWxlIjoiQXhpcy5saW5lYXIubWVhc3VyZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHBvc2l0aW9uVG9wLFxuICBwb3NpdGlvbkJvdHRvbVxufSBmcm9tICcuL0F4aXMnXG5cbmNvbnN0IGZvbnRTaXplID0gMTBcblxuY29uc3QgZ2V0UGl4ZWwgPSBkID0+IGRcbmNvbnN0IHJhZGlhbnNUb0RlZ3JlZXMgPSByID0+IHIgKiAoMTgwIC8gTWF0aC5QSSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVhc3VyZSAoKSB7XG4gIC8vIE1lYXN1cmUgZmluZHMgdGhlIGFtb3VudCBvZiBvdmVyZmxvdyB0aGlzIGF4aXMgcHJvZHVjZXMgYW5kXG4gIC8vIHVwZGF0ZXMgdGhlIG1hcmdpbnMgdG8gZW5zdXJlIHRoYXQgdGhlIGF4aXMgaXMgdmlzaWJpbGl0eVxuICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGlzIGN1cnJlbnRseSBoYXBwZW5zIGFmdGVyIGEgcmVuZGVyLCBidXQgcG90ZW50aWFsbHlcbiAgLy8gY291bGQgaGFwcGVuIHByZS1yZW5kZXIgaWYgd2UgY291bGQgcmVsaWFibHkgcHJlZGljdCB0aGUgc2l6ZSBvZiB0aGVcbiAgLy8gbGFiZWxzIGJlZm9yZSB0aGV5IHJlbmRlci4gQ29uc2lkZXJpbmcgdGhhdCB0aWNrcyBjb3VsZCBiZSBhbnl0aGluZyxcbiAgLy8gZXZlbiBhIHJlYWN0IGNvbXBvbmVudCwgdGhpcyBjb3VsZCBnZXQgdmVyeSB0b3VnaC5cbiAgY29uc3Qge1xuICAgIGF4aXMsXG4gICAgdGlja1NpemVJbm5lcixcbiAgICB0aWNrU2l6ZU91dGVyLFxuICAgIHRpY2tQYWRkaW5nLFxuICAgIG1heExhYmVsUm90YXRpb24sXG4gICAgcG9zaXRpb24sXG4gICAgZGlzcGF0Y2hcbiAgfSA9IHRoaXMucHJvcHNcblxuICBjb25zdCB7XG4gICAgcm90YXRpb24sXG4gICAgdmlzaWJsZUxhYmVsU3RlcFxuICB9ID0gdGhpc1xuXG4gIGlmICghdGhpcy5lbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgaXNIb3Jpem9udGFsID0gcG9zaXRpb24gPT09IHBvc2l0aW9uVG9wIHx8IHBvc2l0aW9uID09PSBwb3NpdGlvbkJvdHRvbVxuICBjb25zdCBsYWJlbERpbXMgPSBBcnJheSguLi50aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aWNrLi1tZWFzdXJlYWJsZSB0ZXh0JykpLm1hcChlbCA9PiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSlcblxuICBsZXQgc21hbGxlc3RUaWNrR2FwID0gMTAwMDAgLy8gVGhpcyBpcyBqdXN0IGEgcmlkaWN1bG91c2x5IGxhcmdlIHRpY2sgc3BhY2luZyB0aGF0IHdvdWxkIG5ldmVyIGhhcHBlbiAoaG9wZWZ1bGx5KVxuICAvLyBJZiB0aGUgYXhpcyBpcyBob3Jpem9udGFsLCB3ZSBuZWVkIHRvIGRldGVybWluZSBhbnkgbmVjZXNzYXJ5IHJvdGF0aW9uIGFuZCB0aWNrIHNraXBwaW5nXG4gIGlmIChpc0hvcml6b250YWwpIHtcbiAgICBjb25zdCB0aWNrRGltcyA9IEFycmF5KC4uLnRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnLnRpY2suLW1lYXN1cmVhYmxlJykpLm1hcChlbCA9PiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSlcbiAgICB0aWNrRGltcy5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIGNvbnN0IGdhcCA9IGN1cnJlbnQubGVmdCAtIHByZXYubGVmdCAtIChmb250U2l6ZSAvIDIpXG4gICAgICAgIHNtYWxsZXN0VGlja0dhcCA9IGdhcCA8IHNtYWxsZXN0VGlja0dhcCA/IGdhcCA6IHNtYWxsZXN0VGlja0dhcFxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnRcbiAgICB9LCBmYWxzZSlcbiAgICBjb25zdCBsYXJnZXN0TGFiZWwgPSBsYWJlbERpbXMucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICBjdXJyZW50Ll9vdmVyZmxvdyA9IGN1cnJlbnQud2lkdGggLSBzbWFsbGVzdFRpY2tHYXBcbiAgICAgIGlmIChjdXJyZW50Ll9vdmVyZmxvdyA+IDAgJiYgY3VycmVudC5fb3ZlcmZsb3cgPiBwcmV2Ll9vdmVyZmxvdykge1xuICAgICAgICByZXR1cm4gY3VycmVudFxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZcbiAgICB9LCB7X292ZXJmbG93OiAwfSlcblxuICAgIGxldCBuZXdSb3RhdGlvbiA9IE1hdGgubWluKE1hdGgubWF4KE1hdGguYWJzKHJhZGlhbnNUb0RlZ3JlZXMoTWF0aC5hY29zKHNtYWxsZXN0VGlja0dhcCAvIGxhcmdlc3RMYWJlbC53aWR0aCkpKSwgMCksIG1heExhYmVsUm90YXRpb24pXG4gICAgbmV3Um90YXRpb24gPSBpc05hTihuZXdSb3RhdGlvbikgPyAwIDogbmV3Um90YXRpb25cblxuICAgIGlmIChNYXRoLmZsb29yKHJvdGF0aW9uKSAhPT0gTWF0aC5mbG9vcihuZXdSb3RhdGlvbikpIHtcbiAgICAgIHRoaXMucm90YXRpb24gPSBheGlzLnBvc2l0aW9uID09PSAndG9wJyA/IC1uZXdSb3RhdGlvbiA6IG5ld1JvdGF0aW9uXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmV3VmlzaWJsZUxhYmVsU3RlcCA9IE1hdGguY2VpbChmb250U2l6ZSAvIHNtYWxsZXN0VGlja0dhcClcblxuICBpZiAodmlzaWJsZUxhYmVsU3RlcCAhPT0gbmV3VmlzaWJsZUxhYmVsU3RlcCkge1xuICAgIHRoaXMudmlzaWJsZUxhYmVsU3RlcCA9IG5ld1Zpc2libGVMYWJlbFN0ZXBcbiAgfVxuXG4gIGlmICghbGFiZWxEaW1zLmxlbmd0aCB8fCBsYWJlbERpbXMubGVuZ3RoICE9PSB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgbGV0IHdpZHRoID0gMFxuICBsZXQgaGVpZ2h0ID0gMFxuICBsZXQgdG9wID0gMFxuICBsZXQgYm90dG9tID0gMFxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuXG4gIC8vIERldGVybWluZSBheGlzIHJvdGF0aW9uIGJlZm9yZSB3ZSBtZWFzdXJlXG5cbiAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgIC8vIEFkZCB3aWR0aCBvdmVyZmxvdyBmcm9tIHRoZSBmaXJzdCBhbmQgbGFzdCB0aWNrc1xuICAgIGxlZnQgPSBNYXRoLmNlaWwoZ2V0UGl4ZWwobGFiZWxEaW1zWzBdLndpZHRoKSAvIDIpXG4gICAgcmlnaHQgPSBNYXRoLmNlaWwoZ2V0UGl4ZWwobGFiZWxEaW1zW2xhYmVsRGltcy5sZW5ndGggLSAxXS53aWR0aCkgLyAyKVxuICAgIGhlaWdodCA9XG4gICAgICBNYXRoLm1heCh0aWNrU2l6ZUlubmVyLCB0aWNrU2l6ZU91dGVyKSArIC8vIEFkZCB0aWNrIHNpemVcbiAgICAgIHRpY2tQYWRkaW5nICsgLy8gQWRkIHRpY2sgcGFkZGluZ1xuICAgICAgTWF0aC5tYXgoLi4ubGFiZWxEaW1zLm1hcChkID0+IE1hdGguY2VpbChnZXRQaXhlbChkLmhlaWdodCkpKSkgLy8gQWRkIHRoZSBoZWlnaHQgb2YgdGhlIGxhcmdlc3QgbGFiZWxcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGQgaGVpZ2h0IG92ZXJmbG93IGZyb20gdGhlIGZpcnN0IGFuZCBsYXN0IHRpY2tzXG4gICAgdG9wID0gTWF0aC5jZWlsKGdldFBpeGVsKGxhYmVsRGltc1swXS5oZWlnaHQpIC8gMilcbiAgICBib3R0b20gPSBNYXRoLmNlaWwoZ2V0UGl4ZWwobGFiZWxEaW1zW2xhYmVsRGltcy5sZW5ndGggLSAxXS5oZWlnaHQpIC8gMilcbiAgICB3aWR0aCA9XG4gICAgICBNYXRoLm1heCh0aWNrU2l6ZUlubmVyLCB0aWNrU2l6ZU91dGVyKSArIC8vIEFkZCB0aWNrIHNpemVcbiAgICAgIHRpY2tQYWRkaW5nICsgLy8gQWRkIHRpY2sgcGFkZGluZ1xuICAgICAgTWF0aC5tYXgoLi4ubGFiZWxEaW1zLm1hcChkID0+IE1hdGguY2VpbChnZXRQaXhlbChkLndpZHRoKSkpKSAvLyBBZGQgdGhlIHdpZHRoIG9mIHRoZSBsYXJnZXN0IGxhYmVsXG4gIH1cblxuICBkaXNwYXRjaChzdGF0ZSA9PiAoe1xuICAgIC4uLnN0YXRlLFxuICAgIGF4aXNEaW1lbnNpb25zOiB7XG4gICAgICAuLi5zdGF0ZS5heGlzRGltZW5zaW9ucyxcbiAgICAgIFtwb3NpdGlvbl06IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBib3R0b20sXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgICB9XG4gICAgfVxuICB9KSwge1xuICAgIHR5cGU6ICdheGlzRGltZW5zaW9ucydcbiAgfSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIl19