'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = updateScale;

var _d3Scale = require('d3-scale');

var _Axis = require('./Axis');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
//


var scales = {
  linear: _d3Scale.scaleLinear,
  log: _d3Scale.scaleLog,
  time: _d3Scale.scaleTime,
  ordinal: _d3Scale.scaleBand
};

var detectVertical = function detectVertical(position) {
  return [_Axis.positionLeft, _Axis.positionRight].indexOf(position) > -1;
};
var detectRTL = function detectRTL(position) {
  return [_Axis.positionTop, _Axis.positionRight].indexOf(position) > -1;
};

function updateScale(props) {
  var id = props.id,
      type = props.type,
      position = props.position,
      invert = props.invert,
      primary = props.primary,
      stacked = props.stacked,
      innerPadding = props.innerPadding,
      outerPadding = props.outerPadding,
      tickArguments = props.tickArguments,
      tickValues = props.tickValues,
      tickFormat = props.tickFormat,
      tickPadding = props.tickPadding,
      tickSizeInner = props.tickSizeInner,
      materializedData = props.materializedData,
      width = props.width,
      height = props.height,
      primaryAxis = props.primaryAxis;

  // We need the data to proceed

  if (!materializedData) {
    return;
  }

  // If this axis is secondary, we need the primaryAxis to proceed
  if (!primary && !primaryAxis) {
    return;
  }

  // Detect some settings
  var valueKey = primary ? 'primary' : 'secondary';
  var groupKey = !primary && 'primary';
  var vertical = detectVertical(position);
  var RTL = primary && detectRTL(position); // Right to left OR top to bottom

  // TODO: Any sorting needs to happen here, else the min/max's might not line up correctly

  // First we need to find unique values, min/max values and negative/positive totals
  var uniqueVals = [];
  var min = 0;
  var max = 0;
  var datumValues = {};
  var negativeTotal = 0;
  var positiveTotal = 0;
  var domain = void 0;

  if (type === 'ordinal') {
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d) {
        if (uniqueVals.indexOf(d) === -1) {
          uniqueVals.push(d);
        }
      });
    });
    domain = invert ? [].concat(uniqueVals).reverse() : uniqueVals;
  } else if (type === 'time') {
    var firstRow = materializedData[0].data[0] || {};
    min = max = firstRow[valueKey];
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return +d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.data[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      var seriesMin = Math.min.apply(Math, _toConsumableArray(seriesValues));
      var seriesMax = Math.max.apply(Math, _toConsumableArray(seriesValues));
      min = Math.min(min, seriesMin);
      max = Math.max(max, seriesMax);
    });
    domain = invert ? [max, min] : [min, max];
  } else {
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.data[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      var seriesMin = Math.min.apply(Math, _toConsumableArray(seriesValues));
      var seriesMax = Math.max.apply(Math, _toConsumableArray(seriesValues));
      min = Math.min(min, seriesMin);
      max = Math.max(max, seriesMax);
    });
    if (stacked) {
      var _Object$keys$map$redu = Object.keys(datumValues).map(function (d) {
        return datumValues[d];
      }).reduce(function (totals, vals) {
        var positive = vals.filter(function (d) {
          return d >= 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        var negative = vals.filter(function (d) {
          return d < 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        return [positive > totals[0] ? positive : totals[0], negative < totals[1] ? negative : totals[1]];
      }, [0, 0]);
      // If we're stacking, calculate and use the max and min values for the largest stack


      var _Object$keys$map$redu2 = _slicedToArray(_Object$keys$map$redu, 2);

      positiveTotal = _Object$keys$map$redu2[0];
      negativeTotal = _Object$keys$map$redu2[1];

      domain = invert ? [positiveTotal, negativeTotal] : [negativeTotal, positiveTotal];
    } else {
      // If we're not stacking, use the min and max values
      domain = invert ? [max, min] : [min, max];
    }
  }

  // Now we need to figure out the range
  var range = vertical ? invert ? [0, height] : [height, 0] // If the axis is inverted, swap the range, too
  : invert ? [width, 0] : [0, width];

  if (!primary) {
    // Secondary axes are usually dependent on primary axes for orientation, so if the
    // primaryAxis is in RTL mode, we need to reverse the range on this secondary axis
    // to match the origin of the primary axis
    if (primaryAxis.RTL) {
      range = range.reverse();
    }
  }

  // The the scale a home
  var scale = void 0;

  // If this is an ordinal or other primary axis, it needs to be able to display bars.
  var bandScale = void 0;
  var barSize = 1;
  var stepSize = 0;

  if (type === 'ordinal' || primary) {
    // Calculate a band axis that is similar and pass down the bandwidth
    // just in case.
    bandScale = (0, _d3Scale.scaleBand)().domain(materializedData.reduce(function (prev, current) {
      return current.data.length > prev.length ? current.data : prev;
    }, []).map(function (d) {
      return d.primary;
    })).rangeRound(range, 0.1).padding(0);

    if (type === 'ordinal') {
      bandScale.paddingOuter(outerPadding).paddingInner(innerPadding);
      barSize = bandScale.bandwidth();
    } else {
      barSize = bandScale.bandwidth();
    }

    stepSize = bandScale.step();
  }

  if (type === 'ordinal') {
    // If it's ordinal, just assign the bandScale we made
    scale = bandScale;
  } else {
    // Otherwise, create a new scale of the appropriate type
    scale = scales[type]();
  }

  // Set the domain
  scale.domain(domain);

  // Now set the range
  scale.range(range);

  // If we're not using an ordinal scale, round the ticks to "nice" values
  if (type !== 'ordinal') {
    scale.nice();
  }

  // Pass down the axis config (including the scale itself) for posterity
  var axis = {
    type: type,
    scale: scale,
    uniqueVals: uniqueVals,
    primary: primary,
    invert: invert,
    vertical: vertical,
    RTL: RTL,
    position: position,
    stacked: stacked,
    barSize: barSize,
    stepSize: stepSize,
    domain: domain,
    range: range,
    max: position === _Axis.positionBottom ? -height : position === _Axis.positionLeft ? width : position === _Axis.positionTop ? height : -width,
    directionMultiplier: position === _Axis.positionTop || position === _Axis.positionLeft ? -1 : 1,
    transform: !vertical ? translateX : translateY,
    ticks: this.ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
    format: tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity : tickFormat,
    spacing: Math.max(tickSizeInner, 0) + tickPadding
  };

  if (type === 'ordinal') {
    axis.gridOffset = -(axis.stepSize * innerPadding) / 2;
    axis.tickOffset = axis.barSize / 2;
    axis.barOffset = 0;
  } else {
    axis.tickOffset = 0;
    axis.barOffset = -axis.barSize / 2;
  }

  // Make sure we start with a prevAxis
  this.prevAxis = this.prevAxis || axis;

  this.props.dispatch(function (state) {
    return _extends({}, state, {
      axes: _extends({}, state.axes, _defineProperty({}, id, axis))
    });
  }, {
    type: 'axisUpdateScale'
  });
}

function identity(x) {
  return x;
}

function translateX(x) {
  return 'translate(' + x + ', 0)';
}

function translateY(y) {
  return 'translate(0, ' + y + ')';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0F4aXMudXBkYXRlU2NhbGUuanMiXSwibmFtZXMiOlsidXBkYXRlU2NhbGUiLCJzY2FsZXMiLCJsaW5lYXIiLCJsb2ciLCJ0aW1lIiwib3JkaW5hbCIsImRldGVjdFZlcnRpY2FsIiwiaW5kZXhPZiIsInBvc2l0aW9uIiwiZGV0ZWN0UlRMIiwicHJvcHMiLCJpZCIsInR5cGUiLCJpbnZlcnQiLCJwcmltYXJ5Iiwic3RhY2tlZCIsImlubmVyUGFkZGluZyIsIm91dGVyUGFkZGluZyIsInRpY2tBcmd1bWVudHMiLCJ0aWNrVmFsdWVzIiwidGlja0Zvcm1hdCIsInRpY2tQYWRkaW5nIiwidGlja1NpemVJbm5lciIsIm1hdGVyaWFsaXplZERhdGEiLCJ3aWR0aCIsImhlaWdodCIsInByaW1hcnlBeGlzIiwidmFsdWVLZXkiLCJncm91cEtleSIsInZlcnRpY2FsIiwiUlRMIiwidW5pcXVlVmFscyIsIm1pbiIsIm1heCIsImRhdHVtVmFsdWVzIiwibmVnYXRpdmVUb3RhbCIsInBvc2l0aXZlVG90YWwiLCJkb21haW4iLCJmb3JFYWNoIiwic2VyaWVzVmFsdWVzIiwic2VyaWVzIiwiZGF0YSIsIm1hcCIsImQiLCJwdXNoIiwicmV2ZXJzZSIsImZpcnN0Um93IiwiaSIsImtleSIsInNlcmllc01pbiIsIk1hdGgiLCJzZXJpZXNNYXgiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwidG90YWxzIiwidmFscyIsInBvc2l0aXZlIiwiZmlsdGVyIiwiZHMiLCJuZWdhdGl2ZSIsInJhbmdlIiwic2NhbGUiLCJiYW5kU2NhbGUiLCJiYXJTaXplIiwic3RlcFNpemUiLCJwcmV2IiwiY3VycmVudCIsImxlbmd0aCIsInJhbmdlUm91bmQiLCJwYWRkaW5nIiwicGFkZGluZ091dGVyIiwicGFkZGluZ0lubmVyIiwiYmFuZHdpZHRoIiwic3RlcCIsIm5pY2UiLCJheGlzIiwiZGlyZWN0aW9uTXVsdGlwbGllciIsInRyYW5zZm9ybSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwidGlja3MiLCJhcHBseSIsImZvcm1hdCIsImlkZW50aXR5Iiwic3BhY2luZyIsImdyaWRPZmZzZXQiLCJ0aWNrT2Zmc2V0IiwiYmFyT2Zmc2V0IiwicHJldkF4aXMiLCJkaXNwYXRjaCIsInN0YXRlIiwiYXhlcyIsIngiLCJ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O2tCQXdCd0JBLFc7O0FBeEJ4Qjs7QUFPQTs7Ozs7QUFEQTs7O0FBUUEsSUFBTUMsU0FBUztBQUNiQyw4QkFEYTtBQUViQyx3QkFGYTtBQUdiQywwQkFIYTtBQUliQztBQUphLENBQWY7O0FBT0EsSUFBTUMsaUJBQWlCLFNBQWpCQSxjQUFpQjtBQUFBLFNBQVksMENBQThCQyxPQUE5QixDQUFzQ0MsUUFBdEMsSUFBa0QsQ0FBQyxDQUEvRDtBQUFBLENBQXZCO0FBQ0EsSUFBTUMsWUFBWSxTQUFaQSxTQUFZLENBQUNELFFBQUQ7QUFBQSxTQUFjLHlDQUE2QkQsT0FBN0IsQ0FBcUNDLFFBQXJDLElBQWlELENBQUMsQ0FBaEU7QUFBQSxDQUFsQjs7QUFFZSxTQUFTUixXQUFULENBQXNCVSxLQUF0QixFQUE2QjtBQUFBLE1BR3hDQyxFQUh3QyxHQXNCdENELEtBdEJzQyxDQUd4Q0MsRUFId0M7QUFBQSxNQUt4Q0MsSUFMd0MsR0FzQnRDRixLQXRCc0MsQ0FLeENFLElBTHdDO0FBQUEsTUFNeENKLFFBTndDLEdBc0J0Q0UsS0F0QnNDLENBTXhDRixRQU53QztBQUFBLE1BT3hDSyxNQVB3QyxHQXNCdENILEtBdEJzQyxDQU94Q0csTUFQd0M7QUFBQSxNQVF4Q0MsT0FSd0MsR0FzQnRDSixLQXRCc0MsQ0FReENJLE9BUndDO0FBQUEsTUFTeENDLE9BVHdDLEdBc0J0Q0wsS0F0QnNDLENBU3hDSyxPQVR3QztBQUFBLE1BVXhDQyxZQVZ3QyxHQXNCdENOLEtBdEJzQyxDQVV4Q00sWUFWd0M7QUFBQSxNQVd4Q0MsWUFYd0MsR0FzQnRDUCxLQXRCc0MsQ0FXeENPLFlBWHdDO0FBQUEsTUFZeENDLGFBWndDLEdB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QUFJVCxTQUFTLFNBQWIsRUFBd0I7QUFDdEJnRSxTQUFLVSxVQUFMLEdBQWtCLEVBQUVWLEtBQUtYLFFBQUwsR0FBZ0JqRCxZQUFsQixJQUFrQyxDQUFwRDtBQUNBNEQsU0FBS1csVUFBTCxHQUFrQlgsS0FBS1osT0FBTCxHQUFlLENBQWpDO0FBQ0FZLFNBQUtZLFNBQUwsR0FBaUIsQ0FBakI7QUFDRCxHQUpELE1BSU87QUFDTFosU0FBS1csVUFBTCxHQUFrQixDQUFsQjtBQUNBWCxTQUFLWSxTQUFMLEdBQWlCLENBQUNaLEtBQUtaLE9BQU4sR0FBZ0IsQ0FBakM7QUFDRDs7QUFFRDtBQUNBLE9BQUt5QixRQUFMLEdBQWdCLEtBQUtBLFFBQUwsSUFBaUJiLElBQWpDOztBQUVBLE9BQUtsRSxLQUFMLENBQVdnRixRQUFYLENBQW9CO0FBQUEsd0JBQ2ZDLEtBRGU7QUFFbEJDLHlCQUNLRCxNQUFNQyxJQURYLHNCQUVHakYsRUFGSCxFQUVRaUUsSUFGUjtBQUZrQjtBQUFBLEdBQXBCLEVBTUk7QUFDRmhFLFVBQU07QUFESixHQU5KO0FBU0Q7O0FBRUQsU0FBU3dFLFFBQVQsQ0FBbUJTLENBQW5CLEVBQXNCO0FBQ3BCLFNBQU9BLENBQVA7QUFDRDs7QUFFRCxTQUFTZCxVQUFULENBQXFCYyxDQUFyQixFQUF3QjtBQUN0QixTQUFPLGVBQWVBLENBQWYsR0FBbUIsTUFBMUI7QUFDRDs7QUFFRCxTQUFTYixVQUFULENBQXFCYyxDQUFyQixFQUF3QjtBQUN0QixTQUFPLGtCQUFrQkEsQ0FBbEIsR0FBc0IsR0FBN0I7QUFDRCIsImZpbGUiOiJBeGlzLnVwZGF0ZVNjYWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgc2NhbGVMaW5lYXIsXG4gIHNjYWxlTG9nLFxuICBzY2FsZVRpbWUsXG4gIHNjYWxlQmFuZFxufSBmcm9tICdkMy1zY2FsZSdcbi8vXG5pbXBvcnQge1xuICBwb3NpdGlvblRvcCxcbiAgcG9zaXRpb25MZWZ0LFxuICBwb3NpdGlvblJpZ2h0LFxuICBwb3NpdGlvbkJvdHRvbVxuIH0gZnJvbSAnLi9BeGlzJ1xuXG5jb25zdCBzY2FsZXMgPSB7XG4gIGxpbmVhcjogc2NhbGVMaW5lYXIsXG4gIGxvZzogc2NhbGVMb2csXG4gIHRpbWU6IHNjYWxlVGltZSxcbiAgb3JkaW5hbDogc2NhbGVCYW5kXG59XG5cbmNvbnN0IGRldGVjdFZlcnRpY2FsID0gcG9zaXRpb24gPT4gW3Bvc2l0aW9uTGVmdCwgcG9zaXRpb25SaWdodF0uaW5kZXhPZihwb3NpdGlvbikgPiAtMVxuY29uc3QgZGV0ZWN0UlRMID0gKHBvc2l0aW9uKSA9PiBbcG9zaXRpb25Ub3AsIHBvc2l0aW9uUmlnaHRdLmluZGV4T2YocG9zaXRpb24pID4gLTFcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlU2NhbGUgKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICAvLyBDb21wdXRlZFxuICAgIGlkLFxuICAgIC8vIFByb3BzXG4gICAgdHlwZSxcbiAgICBwb3NpdGlvbixcbiAgICBpbnZlcnQsXG4gICAgcHJpbWFyeSxcbiAgICBzdGFja2VkLFxuICAgIGlubmVyUGFkZGluZyxcbiAgICBvdXRlclBhZGRpbmcsXG4gICAgdGlja0FyZ3VtZW50cyxcbiAgICB0aWNrVmFsdWVzLFxuICAgIHRpY2tGb3JtYXQsXG4gICAgdGlja1BhZGRpbmcsXG4gICAgdGlja1NpemVJbm5lcixcbiAgICAvLyBDb250ZXh0XG4gICAgbWF0ZXJpYWxpemVkRGF0YSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgcHJpbWFyeUF4aXNcbiAgfSA9IHByb3BzXG5cbiAgLy8gV2UgbmVlZCB0aGUgZGF0YSB0byBwcm9jZWVkXG4gIGlmICghbWF0ZXJpYWxpemVkRGF0YSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gSWYgdGhpcyBheGlzIGlzIHNlY29uZGFyeSwgd2UgbmVlZCB0aGUgcHJpbWFyeUF4aXMgdG8gcHJvY2VlZFxuICBpZiAoIXByaW1hcnkgJiYgIXByaW1hcnlBeGlzKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBEZXRlY3Qgc29tZSBzZXR0aW5nc1xuICBjb25zdCB2YWx1ZUtleSA9IHByaW1hcnkgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5J1xuICBjb25zdCBncm91cEtleSA9ICFwcmltYXJ5ICYmICdwcmltYXJ5J1xuICBjb25zdCB2ZXJ0aWNhbCA9IGRldGVjdFZlcnRpY2FsKHBvc2l0aW9uKVxuICBjb25zdCBSVEwgPSBwcmltYXJ5ICYmIGRldGVjdFJUTChwb3NpdGlvbikgLy8gUmlnaHQgdG8gbGVmdCBPUiB0b3AgdG8gYm90dG9tXG5cbiAgLy8gVE9ETzogQW55IHNvcnRpbmcgbmVlZHMgdG8gaGFwcGVuIGhlcmUsIGVsc2UgdGhlIG1pbi9tYXgncyBtaWdodCBub3QgbGluZSB1cCBjb3JyZWN0bHlcblxuICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGZpbmQgdW5pcXVlIHZhbHVlcywgbWluL21heCB2YWx1ZXMgYW5kIG5lZ2F0aXZlL3Bvc2l0aXZlIHRvdGFsc1xuICBsZXQgdW5pcXVlVmFscyA9IFtdXG4gIGxldCBtaW4gPSAwXG4gIGxldCBtYXggPSAwXG4gIGxldCBkYXR1bVZhbHVlcyA9IHt9XG4gIGxldCBuZWdhdGl2ZVRvdGFsID0gMFxuICBsZXQgcG9zaXRpdmVUb3RhbCA9IDBcbiAgbGV0IGRvbWFpblxuXG4gIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBtYXRlcmlhbGl6ZWREYXRhLmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc1ZhbHVlcyA9IHNlcmllcy5kYXRhLm1hcChkID0+IGRbdmFsdWVLZXldKVxuICAgICAgc2VyaWVzVmFsdWVzLmZvckVhY2goZCA9PiB7XG4gICAgICAgIGlmICh1bmlxdWVWYWxzLmluZGV4T2YoZCkgPT09IC0xKSB7XG4gICAgICAgICAgdW5pcXVlVmFscy5wdXNoKGQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICBkb21haW4gPSBpbnZlcnQgPyBbLi4udW5pcXVlVmFsc10ucmV2ZXJzZSgpIDogdW5pcXVlVmFsc1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0aW1lJykge1xuICAgIGNvbnN0IGZpcnN0Um93ID0gbWF0ZXJpYWxpemVkRGF0YVswXS5kYXRhWzBdIHx8IHt9XG4gICAgbWluID0gbWF4ID0gZmlyc3RSb3dbdmFsdWVLZXldXG4gICAgbWF0ZXJpYWxpemVkRGF0YS5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICBjb25zdCBzZXJpZXNWYWx1ZXMgPSBzZXJpZXMuZGF0YS5tYXAoZCA9PiArZFt2YWx1ZUtleV0pXG4gICAgICBzZXJpZXNWYWx1ZXMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBncm91cEtleSA/IHNlcmllcy5kYXRhW2ldW2dyb3VwS2V5XSA6IGlcbiAgICAgICAgZGF0dW1WYWx1ZXNba2V5XSA9IFsuLi4oZGF0dW1WYWx1ZXNba2V5XSB8fCBbXSksIGRdXG4gICAgICB9KVxuICAgICAgY29uc3Qgc2VyaWVzTWluID0gTWF0aC5taW4oLi4uc2VyaWVzVmFsdWVzKVxuICAgICAgY29uc3Qgc2VyaWVzTWF4ID0gTWF0aC5tYXgoLi4uc2VyaWVzVmFsdWVzKVxuICAgICAgbWluID0gTWF0aC5taW4obWluLCBzZXJpZXNNaW4pXG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIHNlcmllc01heClcbiAgICB9KVxuICAgIGRvbWFpbiA9IGludmVydCA/IFttYXgsIG1pbl0gOiBbbWluLCBtYXhdXG4gIH0gZWxzZSB7XG4gICAgbWF0ZXJpYWxpemVkRGF0YS5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICBjb25zdCBzZXJpZXNWYWx1ZXMgPSBzZXJpZXMuZGF0YS5tYXAoZCA9PiBkW3ZhbHVlS2V5XSlcbiAgICAgIHNlcmllc1ZhbHVlcy5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdyb3VwS2V5ID8gc2VyaWVzLmRhdGFbaV1bZ3JvdXBLZXldIDogaVxuICAgICAgICBkYXR1bVZhbHVlc1trZXldID0gWy4uLihkYXR1bVZhbHVlc1trZXldIHx8IFtdKSwgZF1cbiAgICAgIH0pXG4gICAgICBjb25zdCBzZXJpZXNNaW4gPSBNYXRoLm1pbiguLi5zZXJpZXNWYWx1ZXMpXG4gICAgICBjb25zdCBzZXJpZXNNYXggPSBNYXRoLm1heCguLi5zZXJpZXNWYWx1ZXMpXG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHNlcmllc01pbilcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgc2VyaWVzTWF4KVxuICAgIH0pXG4gICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN0YWNraW5nLCBjYWxjdWxhdGUgYW5kIHVzZSB0aGUgbWF4IGFuZCBtaW4gdmFsdWVzIGZvciB0aGUgbGFyZ2VzdCBzdGFja1xuICAgICAgW3Bvc2l0aXZlVG90YWwsIG5lZ2F0aXZlVG90YWxdID0gT2JqZWN0LmtleXMoZGF0dW1WYWx1ZXMpLm1hcChkID0+IGRhdHVtVmFsdWVzW2RdKS5yZWR1Y2UoKHRvdGFscywgdmFscykgPT4ge1xuICAgICAgICBjb25zdCBwb3NpdGl2ZSA9IHZhbHMuZmlsdGVyKGQgPT4gZCA+PSAwKS5yZWR1Y2UoKGRzLCBkKSA9PiBkcyArIGQsIDApXG4gICAgICAgIGNvbnN0IG5lZ2F0aXZlID0gdmFscy5maWx0ZXIoZCA9PiBkIDwgMCkucmVkdWNlKChkcywgZCkgPT4gZHMgKyBkLCAwKVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHBvc2l0aXZlID4gdG90YWxzWzBdID8gcG9zaXRpdmUgOiB0b3RhbHNbMF0sXG4gICAgICAgICAgbmVnYXRpdmUgPCB0b3RhbHNbMV0gPyBuZWdhdGl2ZSA6IHRvdGFsc1sxXVxuICAgICAgICBdXG4gICAgICB9LCBbMCwgMF0pXG4gICAgICBkb21haW4gPSBpbnZlcnQgPyBbcG9zaXRpdmVUb3RhbCwgbmVnYXRpdmVUb3RhbF0gOiBbbmVnYXRpdmVUb3RhbCwgcG9zaXRpdmVUb3RhbF1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UncmUgbm90IHN0YWNraW5nLCB1c2UgdGhlIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgICAgZG9tYWluID0gaW52ZXJ0ID8gW21heCwgbWluXSA6IFttaW4sIG1heF1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgd2UgbmVlZCB0byBmaWd1cmUgb3V0IHRoZSByYW5nZVxuICBsZXQgcmFuZ2UgPSB2ZXJ0aWNhbFxuICAgID8gaW52ZXJ0ID8gWzAsIGhlaWdodF0gOiBbaGVpZ2h0LCAwXSAvLyBJZiB0aGUgYXhpcyBpcyBpbnZlcnRlZCwgc3dhcCB0aGUgcmFuZ2UsIHRvb1xuICAgIDogaW52ZXJ0ID8gW3dpZHRoLCAwXSA6IFswLCB3aWR0aF1cblxuICBpZiAoIXByaW1hcnkpIHtcbiAgICAvLyBTZWNvbmRhcnkgYXhlcyBhcmUgdXN1YWxseSBkZXBlbmRlbnQgb24gcHJpbWFyeSBheGVzIGZvciBvcmllbnRhdGlvbiwgc28gaWYgdGhlXG4gICAgLy8gcHJpbWFyeUF4aXMgaXMgaW4gUlRMIG1vZGUsIHdlIG5lZWQgdG8gcmV2ZXJzZSB0aGUgcmFuZ2Ugb24gdGhpcyBzZWNvbmRhcnkgYXhpc1xuICAgIC8vIHRvIG1hdGNoIHRoZSBvcmlnaW4gb2YgdGhlIHByaW1hcnkgYXhpc1xuICAgIGlmIChwcmltYXJ5QXhpcy5SVEwpIHtcbiAgICAgIHJhbmdlID0gcmFuZ2UucmV2ZXJzZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIHRoZSBzY2FsZSBhIGhvbWVcbiAgbGV0IHNjYWxlXG5cbiAgLy8gSWYgdGhpcyBpcyBhbiBvcmRpbmFsIG9yIG90aGVyIHByaW1hcnkgYXhpcywgaXQgbmVlZHMgdG8gYmUgYWJsZSB0byBkaXNwbGF5IGJhcnMuXG4gIGxldCBiYW5kU2NhbGVcbiAgbGV0IGJhclNpemUgPSAxXG4gIGxldCBzdGVwU2l6ZSA9IDBcblxuICBpZiAodHlwZSA9PT0gJ29yZGluYWwnIHx8IHByaW1hcnkpIHtcbiAgICAvLyBDYWxjdWxhdGUgYSBiYW5kIGF4aXMgdGhhdCBpcyBzaW1pbGFyIGFuZCBwYXNzIGRvd24gdGhlIGJhbmR3aWR0aFxuICAgIC8vIGp1c3QgaW4gY2FzZS5cbiAgICBiYW5kU2NhbGUgPSBzY2FsZUJhbmQoKVxuICAgICAgLmRvbWFpbihtYXRlcmlhbGl6ZWREYXRhLnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4gY3VycmVudC5kYXRhLmxlbmd0aCA+IHByZXYubGVuZ3RoID8gY3VycmVudC5kYXRhIDogcHJldiwgW10pLm1hcChkID0+IGQucHJpbWFyeSkpXG4gICAgICAucmFuZ2VSb3VuZChyYW5nZSwgMC4xKVxuICAgICAgLnBhZGRpbmcoMClcblxuICAgIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgIGJhbmRTY2FsZVxuICAgICAgICAucGFkZGluZ091dGVyKG91dGVyUGFkZGluZylcbiAgICAgICAgLnBhZGRpbmdJbm5lcihpbm5lclBhZGRpbmcpXG4gICAgICBiYXJTaXplID0gYmFuZFNjYWxlLmJhbmR3aWR0aCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJhclNpemUgPSBiYW5kU2NhbGUuYmFuZHdpZHRoKClcbiAgICB9XG5cbiAgICBzdGVwU2l6ZSA9IGJhbmRTY2FsZS5zdGVwKClcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAvLyBJZiBpdCdzIG9yZGluYWwsIGp1c3QgYXNzaWduIHRoZSBiYW5kU2NhbGUgd2UgbWFkZVxuICAgIHNjYWxlID0gYmFuZFNjYWxlXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYSBuZXcgc2NhbGUgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGVcbiAgICBzY2FsZSA9IHNjYWxlc1t0eXBlXSgpXG4gIH1cblxuICAvLyBTZXQgdGhlIGRvbWFpblxuICBzY2FsZS5kb21haW4oZG9tYWluKVxuXG4gIC8vIE5vdyBzZXQgdGhlIHJhbmdlXG4gIHNjYWxlLnJhbmdlKHJhbmdlKVxuXG4gIC8vIElmIHdlJ3JlIG5vdCB1c2luZyBhbiBvcmRpbmFsIHNjYWxlLCByb3VuZCB0aGUgdGlja3MgdG8gXCJuaWNlXCIgdmFsdWVzXG4gIGlmICh0eXBlICE9PSAnb3JkaW5hbCcpIHtcbiAgICBzY2FsZS5uaWNlKClcbiAgfVxuXG4gIC8vIFBhc3MgZG93biB0aGUgYXhpcyBjb25maWcgKGluY2x1ZGluZyB0aGUgc2NhbGUgaXRzZWxmKSBmb3IgcG9zdGVyaXR5XG4gIGNvbnN0IGF4aXMgPSB7XG4gICAgdHlwZSxcbiAgICBzY2FsZSxcbiAgICB1bmlxdWVWYWxzLFxuICAgIHByaW1hcnksXG4gICAgaW52ZXJ0LFxuICAgIHZlcnRpY2FsLFxuICAgIFJUTCxcbiAgICBwb3NpdGlvbixcbiAgICBzdGFja2VkLFxuICAgIGJhclNpemUsXG4gICAgc3RlcFNpemUsXG4gICAgZG9tYWluLFxuICAgIHJhbmdlLFxuICAgIG1heDpcbiAgICAgIHBvc2l0aW9uID09PSBwb3NpdGlvbkJvdHRvbSA/IC1oZWlnaHRcbiAgICAgIDogcG9zaXRpb24gPT09IHBvc2l0aW9uTGVmdCA/IHdpZHRoXG4gICAgICA6IHBvc2l0aW9uID09PSBwb3NpdGlvblRvcCA/IGhlaWdodFxuICAgICAgOiAtd2lkdGgsXG4gICAgZGlyZWN0aW9uTXVsdGlwbGllcjogKHBvc2l0aW9uID09PSBwb3NpdGlvblRvcCB8fCBwb3NpdGlvbiA9PT0gcG9zaXRpb25MZWZ0KSA/IC0xIDogMSxcbiAgICB0cmFuc2Zvcm06ICF2ZXJ0aWNhbCA/IHRyYW5zbGF0ZVggOiB0cmFuc2xhdGVZLFxuICAgIHRpY2tzOiB0aGlzLnRpY2tzID0gdGlja1ZhbHVlcyA9PSBudWxsID8gKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogc2NhbGUuZG9tYWluKCkpIDogdGlja1ZhbHVlcyxcbiAgICBmb3JtYXQ6IHRpY2tGb3JtYXQgPT0gbnVsbCA/IChzY2FsZS50aWNrRm9ybWF0ID8gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBpZGVudGl0eSkgOiB0aWNrRm9ybWF0LFxuICAgIHNwYWNpbmc6IE1hdGgubWF4KHRpY2tTaXplSW5uZXIsIDApICsgdGlja1BhZGRpbmdcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBheGlzLmdyaWRPZmZzZXQgPSAtKGF4aXMuc3RlcFNpemUgKiBpbm5lclBhZGRpbmcpIC8gMlxuICAgIGF4aXMudGlja09mZnNldCA9IGF4aXMuYmFyU2l6ZSAvIDJcbiAgICBheGlzLmJhck9mZnNldCA9IDBcbiAgfSBlbHNlIHtcbiAgICBheGlzLnRpY2tPZmZzZXQgPSAwXG4gICAgYXhpcy5iYXJPZmZzZXQgPSAtYXhpcy5iYXJTaXplIC8gMlxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIHN0YXJ0IHdpdGggYSBwcmV2QXhpc1xuICB0aGlzLnByZXZBeGlzID0gdGhpcy5wcmV2QXhpcyB8fCBheGlzXG5cbiAgdGhpcy5wcm9wcy5kaXNwYXRjaChzdGF0ZSA9PiAoe1xuICAgIC4uLnN0YXRlLFxuICAgIGF4ZXM6IHtcbiAgICAgIC4uLnN0YXRlLmF4ZXMsXG4gICAgICBbaWRdOiBheGlzXG4gICAgfVxuICB9KSwge1xuICAgIHR5cGU6ICdheGlzVXBkYXRlU2NhbGUnXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5ICh4KSB7XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVggKHgpIHtcbiAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHggKyAnLCAwKSdcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlWSAoeSkge1xuICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCAnICsgeSArICcpJ1xufVxuIl19