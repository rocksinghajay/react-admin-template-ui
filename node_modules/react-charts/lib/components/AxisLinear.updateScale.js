'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = updateScale;

var _d3Scale = require('d3-scale');

var _AxisLinear = require('./AxisLinear');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
//


var scales = {
  linear: _d3Scale.scaleLinear,
  log: _d3Scale.scaleLog,
  time: _d3Scale.scaleTime,
  ordinal: _d3Scale.scaleBand
};

var detectVertical = function detectVertical(position) {
  return [_AxisLinear.positionLeft, _AxisLinear.positionRight].indexOf(position) > -1;
};
var detectRTL = function detectRTL(position) {
  return [_AxisLinear.positionTop, _AxisLinear.positionRight].indexOf(position) > -1;
};

function updateScale(props) {
  var id = props.id,
      type = props.type,
      position = props.position,
      invert = props.invert,
      primary = props.primary,
      stacked = props.stacked,
      innerPadding = props.innerPadding,
      outerPadding = props.outerPadding,
      tickArguments = props.tickArguments,
      tickValues = props.tickValues,
      tickFormat = props.tickFormat,
      tickPadding = props.tickPadding,
      tickSizeInner = props.tickSizeInner,
      base = props.base,
      defaultMin = props.min,
      defaultMax = props.max,
      hardMin = props.hardMin,
      hardMax = props.hardMax,
      materializedData = props.materializedData,
      width = props.width,
      height = props.height,
      primaryAxis = props.primaryAxis;

  // We need the data to proceed

  if (!materializedData) {
    return;
  }

  // If this axis is secondary, we need the primaryAxis to proceed
  if (!primary && !primaryAxis) {
    return;
  }

  // Detect some settings
  var valueKey = primary ? 'primary' : 'secondary';
  var groupKey = !primary && 'primary';
  var vertical = detectVertical(position);
  var RTL = primary && detectRTL(position); // Right to left OR top to bottom

  // TODO: Any sorting needs to happen here, else the min/max's might not line up correctly

  // First we need to find unique values, min/max values and negative/positive totals
  var uniqueVals = [];
  var min = void 0;
  var max = void 0;
  var datumValues = {};
  var negativeTotal = 0;
  var positiveTotal = 0;
  var domain = void 0;

  if (type === 'ordinal') {
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d) {
        if (uniqueVals.indexOf(d) === -1) {
          uniqueVals.push(d);
        }
      });
    });
    domain = uniqueVals;
  } else if (type === 'time') {
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return +d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.data[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      min = Math.min.apply(Math, _toConsumableArray(typeof min !== 'undefined' ? [min] : []).concat(_toConsumableArray(seriesValues)));
      max = Math.max.apply(Math, _toConsumableArray(typeof max !== 'undefined' ? [max] : []).concat(_toConsumableArray(seriesValues)));
    });
    domain = [min, max];
  } else {
    materializedData.forEach(function (series) {
      var seriesValues = series.data.map(function (d) {
        return d[valueKey];
      });
      seriesValues.forEach(function (d, i) {
        var key = groupKey ? series.data[i][groupKey] : i;
        datumValues[key] = [].concat(_toConsumableArray(datumValues[key] || []), [d]);
      });
      seriesValues = seriesValues.filter(function (d) {
        return typeof d === 'number';
      });
      min = Math.min.apply(Math, _toConsumableArray(typeof min === 'number' ? [min] : []).concat(_toConsumableArray(seriesValues)));
      max = Math.max.apply(Math, _toConsumableArray(typeof max === 'number' ? [max] : []).concat(_toConsumableArray(seriesValues)));
    });
    if (stacked) {
      // If we're stacking, calculate and use the max and min values for the largest stack
      ;
      var _Object$keys$map$redu = Object.keys(datumValues).map(function (d) {
        return datumValues[d];
      }).reduce(function (totals, vals) {
        var positive = vals.filter(function (d) {
          return d >= 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        var negative = vals.filter(function (d) {
          return d < 0;
        }).reduce(function (ds, d) {
          return ds + d;
        }, 0);
        return [positive > totals[0] ? positive : totals[0], negative < totals[1] ? negative : totals[1]];
      }, [0, 0]);

      var _Object$keys$map$redu2 = _slicedToArray(_Object$keys$map$redu, 2);

      positiveTotal = _Object$keys$map$redu2[0];
      negativeTotal = _Object$keys$map$redu2[1];

      domain = [negativeTotal, positiveTotal];
    } else {
      // If we're not stacking, use the min and max values
      domain = [min, max];
    }
  }

  // Now we need to figure out the range
  var range = vertical ? [height, 0] // If the axis is inverted, swap the range, too
  : [0, width];

  if (!primary) {
    // Secondary axes are usually dependent on primary axes for orientation, so if the
    // primaryAxis is in RTL mode, we need to reverse the range on this secondary axis
    // to match the origin of the primary axis
    if (primaryAxis.RTL) {
      range = [].concat(_toConsumableArray(range)).reverse();
    }
  }

  // Give the scale a home
  var scale = void 0;

  // If this is an ordinal or other primary axis, it needs to be able to display bars.
  var bandScale = void 0;
  var barSize = 1;
  var stepSize = 0;

  if (type === 'ordinal' || primary) {
    // Calculate a band axis that is similar and pass down the bandwidth
    // just in case.
    bandScale = (0, _d3Scale.scaleBand)().domain(materializedData.reduce(function (prev, current) {
      return current.data.length > prev.length ? current.data : prev;
    }, []).map(function (d) {
      return d.primary;
    })).rangeRound(range, 0.1).padding(0);

    if (type === 'ordinal') {
      bandScale.paddingOuter(outerPadding).paddingInner(innerPadding);
      barSize = bandScale.bandwidth();
    } else {
      barSize = bandScale.bandwidth();
    }

    stepSize = bandScale.step();
  }

  if (type === 'ordinal') {
    // If it's ordinal, just assign the bandScale we made
    scale = bandScale;
  } else {
    // Otherwise, create a new scale of the appropriate type
    scale = scales[type]();
  }

  // Set base, min, and max
  if (typeof base === 'number') {
    domain[0] = Math.min(domain[0], base);
    domain[1] = Math.max(domain[1], base);
  }
  if (typeof defaultMin === 'number') {
    domain[0] = Math.min(domain[0], defaultMin);
  }
  if (typeof defaultMax === 'number') {
    domain[1] = Math.max(domain[1], defaultMax);
  }

  // Set the domain
  scale.domain(domain);

  // If we're not using an ordinal scale, round the ticks to "nice" values
  if (type !== 'ordinal') {
    scale.nice();
  }

  // If hard min and max are set, override any "nice" rounding values
  if (typeof hardMin === 'number') {
    scale.domain([hardMin, scale.domain()[1]]);
  }
  if (typeof hardMax === 'number') {
    scale.domain([scale.domain()[0], hardMax]);
  }

  // Invert if necessary
  if (invert) {
    scale.domain([].concat(_toConsumableArray(scale.domain())).reverse());
  }

  // Now set the range
  scale.range(range);

  // Pass down the axis config (including the scale itself) for posterity
  var axis = {
    type: type,
    scale: scale,
    uniqueVals: uniqueVals,
    primary: primary,
    invert: invert,
    vertical: vertical,
    RTL: RTL,
    position: position,
    stacked: stacked,
    barSize: barSize,
    stepSize: stepSize,
    domain: domain,
    range: range,
    max: position === _AxisLinear.positionBottom ? -height : position === _AxisLinear.positionLeft ? width : position === _AxisLinear.positionTop ? height : -width,
    directionMultiplier: position === _AxisLinear.positionTop || position === _AxisLinear.positionLeft ? -1 : 1,
    transform: !vertical ? translateX : translateY,
    ticks: this.ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
    format: tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity : tickFormat,
    spacing: Math.max(tickSizeInner, 0) + tickPadding
  };

  if (type === 'ordinal') {
    axis.gridOffset = -(axis.stepSize * innerPadding) / 2;
    axis.tickOffset = axis.barSize / 2;
    axis.barOffset = 0;
  } else {
    axis.tickOffset = 0;
    axis.barOffset = -axis.barSize / 2;
  }

  // Make sure we start with a prevAxis
  this.prevAxis = this.prevAxis || axis;

  this.props.dispatch(function (state) {
    return _extends({}, state, {
      axes: _extends({}, state.axes, _defineProperty({}, id, axis))
    });
  }, {
    type: 'axisUpdateScale'
  });
}

function identity(x) {
  return x;
}

function translateX(x) {
  return 'translate(' + x + ', 0)';
}

function translateY(y) {
  return 'translate(0, ' + y + ')';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0F4aXNMaW5lYXIudXBkYXRlU2NhbGUuanMiXSwibmFtZXMiOlsidXBkYXRlU2NhbGUiLCJzY2FsZXMiLCJsaW5lYXIiLCJsb2ciLCJ0aW1lIiwib3JkaW5hbCIsImRldGVjdFZlcnRpY2FsIiwiaW5kZXhPZiIsInBvc2l0aW9uIiwiZGV0ZWN0UlRMIiwicHJvcHMiLCJpZCIsInR5cGUiLCJpbnZlcnQiLCJwcmltYXJ5Iiwic3RhY2tlZCIsImlubmVyUGFkZGluZyIsIm91dGVyUGFkZGluZyIsInRpY2tBcmd1bWVudHMiLCJ0aWNrVmFsdWVzIiwidGlja0Zvcm1hdCIsInRpY2tQYWRkaW5nIiwidGlja1NpemVJbm5lciIsImJhc2UiLCJkZWZhdWx0TWluIiwibWluIiwiZGVmYXVsdE1heCIsIm1heCIsImhhcmRNaW4iLCJoYXJkTWF4IiwibWF0ZXJpYWxpemVkRGF0YSIsIndpZHRoIiwiaGVpZ2h0IiwicHJpbWFyeUF4aXMiLCJ2YWx1ZUtleSIsImdyb3VwS2V5IiwidmVydGljYWwiLCJSVEwiLCJ1bmlxdWVWYWxzIiwiZGF0dW1WYWx1ZXMiLCJuZWdhdGl2ZVRvdGFsIiwicG9zaXRpdmVUb3RhbCIsImRvbWFpbiIsImZvckVhY2giLCJzZXJpZXNWYWx1ZXMiLCJzZXJpZXMiLCJkYXRhIiwibWFwIiwiZCIsInB1c2giLCJpIiwia2V5IiwiTWF0aCIsImZpbHRlciIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJ0b3RhbHMiLCJ2YWxzIiwicG9zaXRpdmUiLCJkcyIsIm5lZ2F0aXZlIiwicmFuZ2UiLCJyZXZlcnNlIiwic2NhbGUiLCJiYW5kU2NhbGUiLCJiYXJTaXplIiwic3RlcFNpemUiLCJwcmV2IiwiY3VycmVudCIsImxlbmd0aCIsInJhbmdlUm91bmQiLCJwYWRkaW5nIiwicGFkZGluZ091dGVyIiwicGFkZGluZ0lubmVyIiwiYmFuZHdpZHRoIiwic3RlcCIsIm5pY2UiLCJheGlzIiwiZGlyZWN0aW9uTXVsdGlwbGllciIsInRyYW5zZm9ybSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwidGlja3MiLCJhcHBseSIsImZvcm1hdCIsImlkZW50aXR5Iiwic3BhY2luZyIsImdyaWRPZmZzZXQiLCJ0aWNrT2Zmc2V0IiwiYmFyT2Zmc2V0IiwicHJldkF4aXMiLCJkaXNwYXRjaCIsInN0YXRlIiwiYXhlcyIsIngiLCJ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O2tCQXFCd0JBLFc7O0FBckJ4Qjs7QUFFQTs7Ozs7QUFEQTs7O0FBUUEsSUFBTUMsU0FBUztBQUNiQyw4QkFEYTtBQUViQyx3QkFGYTtBQUdiQywwQkFIYTtBQUliQztBQUphLENBQWY7O0FBT0EsSUFBTUMsaUJBQWlCLFNBQWpCQSxjQUFpQjtBQUFBLFNBQ3JCLHNEQUE4QkMsT0FBOUIsQ0FBc0NDLFFBQXRDLElBQWtELENBQUMsQ0FEOUI7QUFBQSxDQUF2QjtBQUVBLElBQU1DLFlBQVksU0FBWkEsU0FBWTtBQUFBLFNBQ2hCLHFEQUE2QkYsT0FBN0IsQ0FBcUNDLFFBQXJDLElBQWlELENBQUMsQ0FEbEM7QUFBQSxDQUFsQjs7QUFHZSxTQUFTUixXQUFULENBQXNCVSxLQUF0QixFQUE2QjtBQUFBLE1BR3hDQyxFQUh3QyxHQTJCdENELEtBM0JzQyxDQUd4Q0MsRUFId0M7QUFBQSxNQUt4Q0MsSUFMd0MsR0EyQnRDRixLQTNCc0MsQ0FLeENFLElBTHdDO0FBQUEsTUFNeENKLFFBTndDLEdBMkJ0Q0UsS0EzQnNDLENBTXhDRixRQU53QztBQUFBLE1BT3hDSyxNQVB3QyxHQTJCdENILEtBM0JzQyxDQU94Q0csTUFQd0M7QUFBQSxNQVF4Q0MsT0FSd0MsR0EyQnRDSixLQTNCc0MsQ0FReENJLE9BUndDO0FBQUEsTUFTeENDLE9BVHdDLEdBMkJ0Q0wsS0EzQnNDLENBU3hDSyxPQVR3QztBQUFBLE1BVXhDQyxZQVZ3QyxHQTJCdENOLEtBM0JzQyxDQVV4Q00sWUFWd0M7QUFBQSxNQVd4Q0MsWUFYd0MsR0EyQnRDUCxLQTNCc0MsQ0FXeENPLFlBWHdDO0FBQUEs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QlgsS0FBS1osT0FBTCxHQUFlLENBQWpDO0FBQ0FZLFNBQUtZLFNBQUwsR0FBaUIsQ0FBakI7QUFDRCxHQUpELE1BSU87QUFDTFosU0FBS1csVUFBTCxHQUFrQixDQUFsQjtBQUNBWCxTQUFLWSxTQUFMLEdBQWlCLENBQUNaLEtBQUtaLE9BQU4sR0FBZ0IsQ0FBakM7QUFDRDs7QUFFRDtBQUNBLE9BQUt5QixRQUFMLEdBQWdCLEtBQUtBLFFBQUwsSUFBaUJiLElBQWpDOztBQUVBLE9BQUtwRSxLQUFMLENBQVdrRixRQUFYLENBQ0U7QUFBQSx3QkFDS0MsS0FETDtBQUVFQyx5QkFDS0QsTUFBTUMsSUFEWCxzQkFFR25GLEVBRkgsRUFFUW1FLElBRlI7QUFGRjtBQUFBLEdBREYsRUFRRTtBQUNFbEUsVUFBTTtBQURSLEdBUkY7QUFZRDs7QUFFRCxTQUFTMEUsUUFBVCxDQUFtQlMsQ0FBbkIsRUFBc0I7QUFDcEIsU0FBT0EsQ0FBUDtBQUNEOztBQUVELFNBQVNkLFVBQVQsQ0FBcUJjLENBQXJCLEVBQXdCO0FBQ3RCLFNBQU8sZUFBZUEsQ0FBZixHQUFtQixNQUExQjtBQUNEOztBQUVELFNBQVNiLFVBQVQsQ0FBcUJjLENBQXJCLEVBQXdCO0FBQ3RCLFNBQU8sa0JBQWtCQSxDQUFsQixHQUFzQixHQUE3QjtBQUNEIiwiZmlsZSI6IkF4aXNMaW5lYXIudXBkYXRlU2NhbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVMb2csIHNjYWxlVGltZSwgc2NhbGVCYW5kIH0gZnJvbSAnZDMtc2NhbGUnXG4vL1xuaW1wb3J0IHtcbiAgcG9zaXRpb25Ub3AsXG4gIHBvc2l0aW9uTGVmdCxcbiAgcG9zaXRpb25SaWdodCxcbiAgcG9zaXRpb25Cb3R0b20sXG59IGZyb20gJy4vQXhpc0xpbmVhcidcblxuY29uc3Qgc2NhbGVzID0ge1xuICBsaW5lYXI6IHNjYWxlTGluZWFyLFxuICBsb2c6IHNjYWxlTG9nLFxuICB0aW1lOiBzY2FsZVRpbWUsXG4gIG9yZGluYWw6IHNjYWxlQmFuZCxcbn1cblxuY29uc3QgZGV0ZWN0VmVydGljYWwgPSBwb3NpdGlvbiA9PlxuICBbcG9zaXRpb25MZWZ0LCBwb3NpdGlvblJpZ2h0XS5pbmRleE9mKHBvc2l0aW9uKSA+IC0xXG5jb25zdCBkZXRlY3RSVEwgPSBwb3NpdGlvbiA9PlxuICBbcG9zaXRpb25Ub3AsIHBvc2l0aW9uUmlnaHRdLmluZGV4T2YocG9zaXRpb24pID4gLTFcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlU2NhbGUgKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICAvLyBDb21wdXRlZFxuICAgIGlkLFxuICAgIC8vIFByb3BzXG4gICAgdHlwZSxcbiAgICBwb3NpdGlvbixcbiAgICBpbnZlcnQsXG4gICAgcHJpbWFyeSxcbiAgICBzdGFja2VkLFxuICAgIGlubmVyUGFkZGluZyxcbiAgICBvdXRlclBhZGRpbmcsXG4gICAgdGlja0FyZ3VtZW50cyxcbiAgICB0aWNrVmFsdWVzLFxuICAgIHRpY2tGb3JtYXQsXG4gICAgdGlja1BhZGRpbmcsXG4gICAgdGlja1NpemVJbm5lcixcbiAgICBiYXNlLFxuICAgIG1pbjogZGVmYXVsdE1pbixcbiAgICBtYXg6IGRlZmF1bHRNYXgsXG4gICAgaGFyZE1pbixcbiAgICBoYXJkTWF4LFxuICAgIC8vIENvbnRleHRcbiAgICBtYXRlcmlhbGl6ZWREYXRhLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBwcmltYXJ5QXhpcyxcbiAgfSA9IHByb3BzXG5cbiAgLy8gV2UgbmVlZCB0aGUgZGF0YSB0byBwcm9jZWVkXG4gIGlmICghbWF0ZXJpYWxpemVkRGF0YSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gSWYgdGhpcyBheGlzIGlzIHNlY29uZGFyeSwgd2UgbmVlZCB0aGUgcHJpbWFyeUF4aXMgdG8gcHJvY2VlZFxuICBpZiAoIXByaW1hcnkgJiYgIXByaW1hcnlBeGlzKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBEZXRlY3Qgc29tZSBzZXR0aW5nc1xuICBjb25zdCB2YWx1ZUtleSA9IHByaW1hcnkgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5J1xuICBjb25zdCBncm91cEtleSA9ICFwcmltYXJ5ICYmICdwcmltYXJ5J1xuICBjb25zdCB2ZXJ0aWNhbCA9IGRldGVjdFZlcnRpY2FsKHBvc2l0aW9uKVxuICBjb25zdCBSVEwgPSBwcmltYXJ5ICYmIGRldGVjdFJUTChwb3NpdGlvbikgLy8gUmlnaHQgdG8gbGVmdCBPUiB0b3AgdG8gYm90dG9tXG5cbiAgLy8gVE9ETzogQW55IHNvcnRpbmcgbmVlZHMgdG8gaGFwcGVuIGhlcmUsIGVsc2UgdGhlIG1pbi9tYXgncyBtaWdodCBub3QgbGluZSB1cCBjb3JyZWN0bHlcblxuICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGZpbmQgdW5pcXVlIHZhbHVlcywgbWluL21heCB2YWx1ZXMgYW5kIG5lZ2F0aXZlL3Bvc2l0aXZlIHRvdGFsc1xuICBsZXQgdW5pcXVlVmFscyA9IFtdXG4gIGxldCBtaW5cbiAgbGV0IG1heFxuICBsZXQgZGF0dW1WYWx1ZXMgPSB7fVxuICBsZXQgbmVnYXRpdmVUb3RhbCA9IDBcbiAgbGV0IHBvc2l0aXZlVG90YWwgPSAwXG4gIGxldCBkb21haW5cblxuICBpZiAodHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgbWF0ZXJpYWxpemVkRGF0YS5mb3JFYWNoKHNlcmllcyA9PiB7XG4gICAgICBjb25zdCBzZXJpZXNWYWx1ZXMgPSBzZXJpZXMuZGF0YS5tYXAoZCA9PiBkW3ZhbHVlS2V5XSlcbiAgICAgIHNlcmllc1ZhbHVlcy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICBpZiAodW5pcXVlVmFscy5pbmRleE9mKGQpID09PSAtMSkge1xuICAgICAgICAgIHVuaXF1ZVZhbHMucHVzaChkKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gICAgZG9tYWluID0gdW5pcXVlVmFsc1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0aW1lJykge1xuICAgIG1hdGVyaWFsaXplZERhdGEuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzVmFsdWVzID0gc2VyaWVzLmRhdGEubWFwKGQgPT4gK2RbdmFsdWVLZXldKVxuICAgICAgc2VyaWVzVmFsdWVzLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ3JvdXBLZXkgPyBzZXJpZXMuZGF0YVtpXVtncm91cEtleV0gOiBpXG4gICAgICAgIGRhdHVtVmFsdWVzW2tleV0gPSBbLi4uKGRhdHVtVmFsdWVzW2tleV0gfHwgW10pLCBkXVxuICAgICAgfSlcbiAgICAgIG1pbiA9IE1hdGgubWluKFxuICAgICAgICAuLi4odHlwZW9mIG1pbiAhPT0gJ3VuZGVmaW5lZCcgPyBbbWluXSA6IFtdKSxcbiAgICAgICAgLi4uc2VyaWVzVmFsdWVzXG4gICAgICApXG4gICAgICBtYXggPSBNYXRoLm1heChcbiAgICAgICAgLi4uKHR5cGVvZiBtYXggIT09ICd1bmRlZmluZWQnID8gW21heF0gOiBbXSksXG4gICAgICAgIC4uLnNlcmllc1ZhbHVlc1xuICAgICAgKVxuICAgIH0pXG4gICAgZG9tYWluID0gW21pbiwgbWF4XVxuICB9IGVsc2Uge1xuICAgIG1hdGVyaWFsaXplZERhdGEuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgbGV0IHNlcmllc1ZhbHVlcyA9IHNlcmllcy5kYXRhLm1hcChkID0+IGRbdmFsdWVLZXldKVxuICAgICAgc2VyaWVzVmFsdWVzLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ3JvdXBLZXkgPyBzZXJpZXMuZGF0YVtpXVtncm91cEtleV0gOiBpXG4gICAgICAgIGRhdHVtVmFsdWVzW2tleV0gPSBbLi4uKGRhdHVtVmFsdWVzW2tleV0gfHwgW10pLCBkXVxuICAgICAgfSlcbiAgICAgIHNlcmllc1ZhbHVlcyA9IHNlcmllc1ZhbHVlcy5maWx0ZXIoZCA9PiB0eXBlb2YgZCA9PT0gJ251bWJlcicpXG4gICAgICBtaW4gPSBNYXRoLm1pbiguLi4odHlwZW9mIG1pbiA9PT0gJ251bWJlcicgPyBbbWluXSA6IFtdKSwgLi4uc2VyaWVzVmFsdWVzKVxuICAgICAgbWF4ID0gTWF0aC5tYXgoLi4uKHR5cGVvZiBtYXggPT09ICdudW1iZXInID8gW21heF0gOiBbXSksIC4uLnNlcmllc1ZhbHVlcylcbiAgICB9KVxuICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBzdGFja2luZywgY2FsY3VsYXRlIGFuZCB1c2UgdGhlIG1heCBhbmQgbWluIHZhbHVlcyBmb3IgdGhlIGxhcmdlc3Qgc3RhY2tcbiAgICAgIDtbcG9zaXRpdmVUb3RhbCwgbmVnYXRpdmVUb3RhbF0gPSBPYmplY3Qua2V5cyhkYXR1bVZhbHVlcylcbiAgICAgICAgLm1hcChkID0+IGRhdHVtVmFsdWVzW2RdKVxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgICh0b3RhbHMsIHZhbHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aXZlID0gdmFsc1xuICAgICAgICAgICAgICAuZmlsdGVyKGQgPT4gZCA+PSAwKVxuICAgICAgICAgICAgICAucmVkdWNlKChkcywgZCkgPT4gZHMgKyBkLCAwKVxuICAgICAgICAgICAgY29uc3QgbmVnYXRpdmUgPSB2YWxzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZCA9PiBkIDwgMClcbiAgICAgICAgICAgICAgLnJlZHVjZSgoZHMsIGQpID0+IGRzICsgZCwgMClcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIHBvc2l0aXZlID4gdG90YWxzWzBdID8gcG9zaXRpdmUgOiB0b3RhbHNbMF0sXG4gICAgICAgICAgICAgIG5lZ2F0aXZlIDwgdG90YWxzWzFdID8gbmVnYXRpdmUgOiB0b3RhbHNbMV0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBbMCwgMF1cbiAgICAgICAgKVxuICAgICAgZG9tYWluID0gW25lZ2F0aXZlVG90YWwsIHBvc2l0aXZlVG90YWxdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3JlIG5vdCBzdGFja2luZywgdXNlIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICAgIGRvbWFpbiA9IFttaW4sIG1heF1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgd2UgbmVlZCB0byBmaWd1cmUgb3V0IHRoZSByYW5nZVxuICBsZXQgcmFuZ2UgPSB2ZXJ0aWNhbFxuICAgID8gW2hlaWdodCwgMF0gLy8gSWYgdGhlIGF4aXMgaXMgaW52ZXJ0ZWQsIHN3YXAgdGhlIHJhbmdlLCB0b29cbiAgICA6IFswLCB3aWR0aF1cblxuICBpZiAoIXByaW1hcnkpIHtcbiAgICAvLyBTZWNvbmRhcnkgYXhlcyBhcmUgdXN1YWxseSBkZXBlbmRlbnQgb24gcHJpbWFyeSBheGVzIGZvciBvcmllbnRhdGlvbiwgc28gaWYgdGhlXG4gICAgLy8gcHJpbWFyeUF4aXMgaXMgaW4gUlRMIG1vZGUsIHdlIG5lZWQgdG8gcmV2ZXJzZSB0aGUgcmFuZ2Ugb24gdGhpcyBzZWNvbmRhcnkgYXhpc1xuICAgIC8vIHRvIG1hdGNoIHRoZSBvcmlnaW4gb2YgdGhlIHByaW1hcnkgYXhpc1xuICAgIGlmIChwcmltYXJ5QXhpcy5SVEwpIHtcbiAgICAgIHJhbmdlID0gWy4uLnJhbmdlXS5yZXZlcnNlKClcbiAgICB9XG4gIH1cblxuICAvLyBHaXZlIHRoZSBzY2FsZSBhIGhvbWVcbiAgbGV0IHNjYWxlXG5cbiAgLy8gSWYgdGhpcyBpcyBhbiBvcmRpbmFsIG9yIG90aGVyIHByaW1hcnkgYXhpcywgaXQgbmVlZHMgdG8gYmUgYWJsZSB0byBkaXNwbGF5IGJhcnMuXG4gIGxldCBiYW5kU2NhbGVcbiAgbGV0IGJhclNpemUgPSAxXG4gIGxldCBzdGVwU2l6ZSA9IDBcblxuICBpZiAodHlwZSA9PT0gJ29yZGluYWwnIHx8IHByaW1hcnkpIHtcbiAgICAvLyBDYWxjdWxhdGUgYSBiYW5kIGF4aXMgdGhhdCBpcyBzaW1pbGFyIGFuZCBwYXNzIGRvd24gdGhlIGJhbmR3aWR0aFxuICAgIC8vIGp1c3QgaW4gY2FzZS5cbiAgICBiYW5kU2NhbGUgPSBzY2FsZUJhbmQoKVxuICAgICAgLmRvbWFpbihcbiAgICAgICAgbWF0ZXJpYWxpemVkRGF0YVxuICAgICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgICAocHJldiwgY3VycmVudCkgPT5cbiAgICAgICAgICAgICAgY3VycmVudC5kYXRhLmxlbmd0aCA+IHByZXYubGVuZ3RoID8gY3VycmVudC5kYXRhIDogcHJldixcbiAgICAgICAgICAgIFtdXG4gICAgICAgICAgKVxuICAgICAgICAgIC5tYXAoZCA9PiBkLnByaW1hcnkpXG4gICAgICApXG4gICAgICAucmFuZ2VSb3VuZChyYW5nZSwgMC4xKVxuICAgICAgLnBhZGRpbmcoMClcblxuICAgIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgIGJhbmRTY2FsZS5wYWRkaW5nT3V0ZXIob3V0ZXJQYWRkaW5nKS5wYWRkaW5nSW5uZXIoaW5uZXJQYWRkaW5nKVxuICAgICAgYmFyU2l6ZSA9IGJhbmRTY2FsZS5iYW5kd2lkdGgoKVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXJTaXplID0gYmFuZFNjYWxlLmJhbmR3aWR0aCgpXG4gICAgfVxuXG4gICAgc3RlcFNpemUgPSBiYW5kU2NhbGUuc3RlcCgpXG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgLy8gSWYgaXQncyBvcmRpbmFsLCBqdXN0IGFzc2lnbiB0aGUgYmFuZFNjYWxlIHdlIG1hZGVcbiAgICBzY2FsZSA9IGJhbmRTY2FsZVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGEgbmV3IHNjYWxlIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlXG4gICAgc2NhbGUgPSBzY2FsZXNbdHlwZV0oKVxuICB9XG5cbiAgLy8gU2V0IGJhc2UsIG1pbiwgYW5kIG1heFxuICBpZiAodHlwZW9mIGJhc2UgPT09ICdudW1iZXInKSB7XG4gICAgZG9tYWluWzBdID0gTWF0aC5taW4oZG9tYWluWzBdLCBiYXNlKVxuICAgIGRvbWFpblsxXSA9IE1hdGgubWF4KGRvbWFpblsxXSwgYmFzZSlcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRNaW4gPT09ICdudW1iZXInKSB7XG4gICAgZG9tYWluWzBdID0gTWF0aC5taW4oZG9tYWluWzBdLCBkZWZhdWx0TWluKVxuICB9XG4gIGlmICh0eXBlb2YgZGVmYXVsdE1heCA9PT0gJ251bWJlcicpIHtcbiAgICBkb21haW5bMV0gPSBNYXRoLm1heChkb21haW5bMV0sIGRlZmF1bHRNYXgpXG4gIH1cblxuICAvLyBTZXQgdGhlIGRvbWFpblxuICBzY2FsZS5kb21haW4oZG9tYWluKVxuXG4gIC8vIElmIHdlJ3JlIG5vdCB1c2luZyBhbiBvcmRpbmFsIHNjYWxlLCByb3VuZCB0aGUgdGlja3MgdG8gXCJuaWNlXCIgdmFsdWVzXG4gIGlmICh0eXBlICE9PSAnb3JkaW5hbCcpIHtcbiAgICBzY2FsZS5uaWNlKClcbiAgfVxuXG4gIC8vIElmIGhhcmQgbWluIGFuZCBtYXggYXJlIHNldCwgb3ZlcnJpZGUgYW55IFwibmljZVwiIHJvdW5kaW5nIHZhbHVlc1xuICBpZiAodHlwZW9mIGhhcmRNaW4gPT09ICdudW1iZXInKSB7XG4gICAgc2NhbGUuZG9tYWluKFtoYXJkTWluLCBzY2FsZS5kb21haW4oKVsxXV0pXG4gIH1cbiAgaWYgKHR5cGVvZiBoYXJkTWF4ID09PSAnbnVtYmVyJykge1xuICAgIHNjYWxlLmRvbWFpbihbc2NhbGUuZG9tYWluKClbMF0sIGhhcmRNYXhdKVxuICB9XG5cbiAgLy8gSW52ZXJ0IGlmIG5lY2Vzc2FyeVxuICBpZiAoaW52ZXJ0KSB7XG4gICAgc2NhbGUuZG9tYWluKFsuLi5zY2FsZS5kb21haW4oKV0ucmV2ZXJzZSgpKVxuICB9XG5cbiAgLy8gTm93IHNldCB0aGUgcmFuZ2VcbiAgc2NhbGUucmFuZ2UocmFuZ2UpXG5cbiAgLy8gUGFzcyBkb3duIHRoZSBheGlzIGNvbmZpZyAoaW5jbHVkaW5nIHRoZSBzY2FsZSBpdHNlbGYpIGZvciBwb3N0ZXJpdHlcbiAgY29uc3QgYXhpcyA9IHtcbiAgICB0eXBlLFxuICAgIHNjYWxlLFxuICAgIHVuaXF1ZVZhbHMsXG4gICAgcHJpbWFyeSxcbiAgICBpbnZlcnQsXG4gICAgdmVydGljYWwsXG4gICAgUlRMLFxuICAgIHBvc2l0aW9uLFxuICAgIHN0YWNrZWQsXG4gICAgYmFyU2l6ZSxcbiAgICBzdGVwU2l6ZSxcbiAgICBkb21haW4sXG4gICAgcmFuZ2UsXG4gICAgbWF4OiBwb3NpdGlvbiA9PT0gcG9zaXRpb25Cb3R0b21cbiAgICAgID8gLWhlaWdodFxuICAgICAgOiBwb3NpdGlvbiA9PT0gcG9zaXRpb25MZWZ0XG4gICAgICAgID8gd2lkdGhcbiAgICAgICAgOiBwb3NpdGlvbiA9PT0gcG9zaXRpb25Ub3AgPyBoZWlnaHQgOiAtd2lkdGgsXG4gICAgZGlyZWN0aW9uTXVsdGlwbGllcjogcG9zaXRpb24gPT09IHBvc2l0aW9uVG9wIHx8IHBvc2l0aW9uID09PSBwb3NpdGlvbkxlZnRcbiAgICAgID8gLTFcbiAgICAgIDogMSxcbiAgICB0cmFuc2Zvcm06ICF2ZXJ0aWNhbCA/IHRyYW5zbGF0ZVggOiB0cmFuc2xhdGVZLFxuICAgIHRpY2tzOiAodGhpcy50aWNrcyA9IHRpY2tWYWx1ZXMgPT0gbnVsbFxuICAgICAgPyBzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpXG4gICAgICA6IHRpY2tWYWx1ZXMpLFxuICAgIGZvcm1hdDogdGlja0Zvcm1hdCA9PSBudWxsXG4gICAgICA/IHNjYWxlLnRpY2tGb3JtYXRcbiAgICAgICAgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKVxuICAgICAgICA6IGlkZW50aXR5XG4gICAgICA6IHRpY2tGb3JtYXQsXG4gICAgc3BhY2luZzogTWF0aC5tYXgodGlja1NpemVJbm5lciwgMCkgKyB0aWNrUGFkZGluZyxcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBheGlzLmdyaWRPZmZzZXQgPSAtKGF4aXMuc3RlcFNpemUgKiBpbm5lclBhZGRpbmcpIC8gMlxuICAgIGF4aXMudGlja09mZnNldCA9IGF4aXMuYmFyU2l6ZSAvIDJcbiAgICBheGlzLmJhck9mZnNldCA9IDBcbiAgfSBlbHNlIHtcbiAgICBheGlzLnRpY2tPZmZzZXQgPSAwXG4gICAgYXhpcy5iYXJPZmZzZXQgPSAtYXhpcy5iYXJTaXplIC8gMlxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIHN0YXJ0IHdpdGggYSBwcmV2QXhpc1xuICB0aGlzLnByZXZBeGlzID0gdGhpcy5wcmV2QXhpcyB8fCBheGlzXG5cbiAgdGhpcy5wcm9wcy5kaXNwYXRjaChcbiAgICBzdGF0ZSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBheGVzOiB7XG4gICAgICAgIC4uLnN0YXRlLmF4ZXMsXG4gICAgICAgIFtpZF06IGF4aXMsXG4gICAgICB9LFxuICAgIH0pLFxuICAgIHtcbiAgICAgIHR5cGU6ICdheGlzVXBkYXRlU2NhbGUnLFxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiBpZGVudGl0eSAoeCkge1xuICByZXR1cm4geFxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVYICh4KSB7XG4gIHJldHVybiAndHJhbnNsYXRlKCcgKyB4ICsgJywgMCknXG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVkgKHkpIHtcbiAgcmV0dXJuICd0cmFuc2xhdGUoMCwgJyArIHkgKyAnKSdcbn1cbiJdfQ==