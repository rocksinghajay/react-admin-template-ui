'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.positionLeft = exports.positionBottom = exports.positionRight = exports.positionTop = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactState = require('react-state');

var _reactMove = require('react-move');

var _Utils = require('../utils/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

var _AxisLinear = require('./AxisLinear.measure');

var _AxisLinear2 = _interopRequireDefault(_AxisLinear);

var _AxisLinear3 = require('./AxisLinear.updateScale');

var _AxisLinear4 = _interopRequireDefault(_AxisLinear3);

var _Path = require('../primitives/Path');

var _Path2 = _interopRequireDefault(_Path);

var _Line = require('../primitives/Line');

var _Line2 = _interopRequireDefault(_Line);

var _Text = require('../primitives/Text');

var _Text2 = _interopRequireDefault(_Text);

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


var positionTop = exports.positionTop = 'top';
var positionRight = exports.positionRight = 'right';
var positionBottom = exports.positionBottom = 'bottom';
var positionLeft = exports.positionLeft = 'left';

var defaultStyles = {
  line: {
    stroke: '#acacac',
    strokeWidth: '1',
    fill: 'transparent'
  },
  tick: {
    fontSize: 10,
    color: '#000',
    fontFamily: 'sans-serif'
  }
};

var Axis = function (_PureComponent) {
  _inherits(Axis, _PureComponent);

  // Lifecycle
  function Axis() {
    _classCallCheck(this, Axis);

    var _this = _possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this));

    _this.state = {
      rotation: 0
    };
    _this.measureRotation = _Utils2.default.throttle(_AxisLinear2.default.bind(_this));
    _this.measure = _Utils2.default.throttle(_AxisLinear2.default.bind(_this));
    _this.updateScale = _AxisLinear4.default.bind(_this);
    return _this;
  }

  _createClass(Axis, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      var oldProps = this.props;
      if (oldProps.axis !== newProps.axis && oldProps.axis) {
        this.prevAxis = oldProps.axis;
      }

      // If any of the following change,
      // we need to update the axis
      if (newProps.primary !== oldProps.primary || newProps.type !== oldProps.type || newProps.invert !== oldProps.invert || newProps.materializedData !== oldProps.materializedData || newProps.height !== oldProps.height || newProps.width !== oldProps.width || newProps.position !== oldProps.position || newProps.min !== oldProps.min || newProps.max !== oldProps.max || newProps.hardMin !== oldProps.hardMin || newProps.hardMax !== oldProps.hardMax) {
        this.updateScale(newProps);
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateScale(this.props);
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(newProps, nextState) {
      if (newProps.axis !== this.props.axis || this.state.rotation !== nextState.rotation) {
        return true;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          type = _props.type,
          axis = _props.axis,
          position = _props.position,
          width = _props.width,
          height = _props.height,
          showGrid = _props.showGrid,
          tickSizeInner = _props.tickSizeInner,
          tickSizeOuter = _props.tickSizeOuter,
          display = _props.display,
          styles = _props.styles;
      var rotation = this.state.rotation;

      // Combine default styles with style props

      var axisStyles = _extends({}, defaultStyles, styles);

      // Render Dependencies
      if (!axis || !display) {
        return null;
      }

      var scale = axis.scale,
          max = axis.max,
          transform = axis.transform,
          vertical = axis.vertical,
          format = axis.format,
          ticks = axis.ticks,
          _axis$range = _slicedToArray(axis.range, 2),
          range0 = _axis$range[0],
          range1 = _axis$range[1],
          directionMultiplier = axis.directionMultiplier,
          tickOffset = axis.tickOffset,
          gridOffset = axis.gridOffset,
          spacing = axis.spacing;

      return _react2.default.createElement(
        _reactMove.Animate,
        {
          data: {
            width: width,
            height: height,
            max: max,
            range0: range0,
            range1: range1,
            directionMultiplier: directionMultiplier,
            tickSizeOuter: tickSizeOuter,
            tickOffset: tickOffset,
            gridOffset: gridOffset,
            spacing: spacing,
            rotation: rotation
          },
          onRest: function onRest() {
            return _this2.measureRotation(true);
          }
        },
        function (_ref) {
          var width = _ref.width,
              height = _ref.height,
              max = _ref.max,
              range0 = _ref.range0,
              range1 = _ref.range1,
              directionMultiplier = _ref.directionMultiplier,
              tickSizeOuter = _ref.tickSizeOuter,
              tickOffset = _ref.tickOffset,
              gridOffset = _ref.gridOffset,
              spacing = _ref.spacing;

          var axisPath = void 0;
          if (vertical) {
            if (position === positionLeft) {
              axisPath = '\n                M ' + -tickSizeOuter + ', ' + range0 + '\n                H 0\n                V ' + range1 + '\n                H ' + -tickSizeOuter + '\n              ';
            } else {
              axisPath = '\n                M ' + tickSizeOuter + ', ' + range0 + '\n                H 0\n                V ' + range1 + '\n                H ' + tickSizeOuter + '\n              ';
            }
          } else {
            if (position === positionBottom) {
              axisPath = '\n                M 0, ' + tickSizeOuter + '\n                V 0\n                H ' + range1 + '\n                V ' + tickSizeOuter + '\n              ';
            } else {
              axisPath = '\n                M 0, ' + -tickSizeOuter + '\n                V 0\n                H ' + range1 + '\n                V ' + -tickSizeOuter + '\n              ';
            }
          }

          return _react2.default.createElement(
            'g',
            {
              className: 'Axis',
              transform: position === positionRight ? translateX(width) : position === positionBottom ? translateY(height) : undefined
            },
            _react2.default.createElement(_Path2.default, { className: 'domain', d: axisPath, style: axisStyles.line }),
            _react2.default.createElement(
              _reactMove.Transition,
              {
                data: [].concat(_toConsumableArray(ticks)),
                getKey: function getKey(d, i) {
                  return String(d);
                },
                update: function update(d) {
                  return {
                    tick: scale(d),
                    visibility: 1,
                    measureable: 1,
                    rotation: rotation
                  };
                },
                enter: function enter(d) {
                  return {
                    tick: _this2.prevAxis.scale(d),
                    visibility: 0,
                    measureable: 1,
                    rotation: rotation
                  };
                },
                leave: function leave(d) {
                  return {
                    tick: scale(d),
                    visibility: 0,
                    measureable: 0,
                    rotation: rotation
                  };
                },
                ignore: ['measureable'],
                duration: 500,
                onRest: function onRest() {
                  return _this2.measure();
                }
              },
              function (inters) {
                var showGridLine = showGrid;

                // If ordinal and showGrid isn't explicit, hide it
                if (type === 'ordinal' && showGrid === 1) {
                  showGridLine = false;
                }

                return _react2.default.createElement(
                  'g',
                  {
                    className: 'ticks',
                    ref: function ref(el) {
                      _this2.el = el;
                    }
                  },
                  inters.map(function (inter, index) {
                    return _react2.default.createElement(
                      'g',
                      {
                        key: inter.key,
                        className: 'tick' + (inter.state.measureable ? ' -measureable' : ''),
                        transform: transform(inter.state.tick)
                      },
                      _react2.default.createElement(_Line2.default, {
                        x1: vertical ? 0 : tickOffset,
                        x2: vertical ? directionMultiplier * tickSizeInner : tickOffset,
                        y1: vertical ? tickOffset : 0,
                        y2: vertical ? tickOffset : directionMultiplier * tickSizeInner,
                        style: {
                          strokeWidth: 1
                        },
                        opacity: inter.state.visibility * 0.2
                      }),
                      showGridLine && _react2.default.createElement(_Line2.default, {
                        x1: vertical ? 0 : gridOffset,
                        x2: vertical ? max : gridOffset,
                        y1: vertical ? gridOffset : 0,
                        y2: vertical ? gridOffset : max,
                        style: {
                          strokeWidth: 1
                        },
                        opacity: inter.state.visibility * (index !== 0 && index !== inters.length - 1 && inter.data === 0 ? 0.5 : 0.2)
                      }),
                      _react2.default.createElement(
                        _Text2.default,
                        {
                          opacity: inter.state.visibility,
                          style: axisStyles.tick,
                          transform: '\n                                translate(' + (vertical ? directionMultiplier * spacing : tickOffset) + ', ' + (vertical ? tickOffset : directionMultiplier * spacing) + ')\n                                rotate(' + -inter.state.rotation + ')\n                              ',
                          dominantBaseline: inter.state.rotation ? 'central' : position === positionBottom ? 'hanging' : position === positionTop ? 'alphabetic' : 'central',
                          textAnchor: inter.state.rotation ? 'end' : position === positionRight ? 'start' : position === positionLeft ? 'end' : 'middle'
                        },
                        format(inter.data)
                      )
                    );
                  })
                );
              }
            )
          );
        }
      );
    }
  }]);

  return Axis;
}(_react.PureComponent);

Axis.defaultProps = {
  min: undefined,
  max: undefined,
  hardMin: undefined,
  hardMax: undefined,
  base: undefined,
  tickArguments: [],
  tickValues: null,
  tickFormat: null,
  tickSizeInner: 6,
  tickSizeOuter: 6,
  tickPadding: 3,
  maxLabelRotation: 50,
  innerPadding: 0.2,
  outerPadding: 0.1,
  showGrid: 1,
  display: true
};
exports.default = (0, _reactState.Connect)(function () {
  var selectors = {
    gridWidth: _Selectors2.default.gridWidth(),
    gridHeight: _Selectors2.default.gridHeight(),
    primaryAxis: _Selectors2.default.primaryAxis()
  };
  return function (state, props) {
    var type = props.type,
        position = props.position;


    var id = type + '_' + position;

    return {
      id: id,
      materializedData: state.materializedData,
      width: selectors.gridWidth(state),
      height: selectors.gridHeight(state),
      primaryAxis: selectors.primaryAxis(state),
      axis: state.axes && state.axes[id]
    };
  };
}, {
  filter: function filter(oldState, newState, meta) {
    return meta.type !== 'cursor';
  }
})(Axis);


function translateX(x) {
  return 'translate(' + x + ', 0)';
}

function translateY(y) {
  return 'translate(0, ' + y + ')';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0F4aXNMaW5lYXIuanMiXSwibmFtZXMiOlsicG9zaXRpb25Ub3AiLCJwb3NpdGlvblJpZ2h0IiwicG9zaXRpb25Cb3R0b20iLCJwb3NpdGlvbkxlZnQiLCJkZWZhdWx0U3R5bGVzIiwibGluZSIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwiZmlsbCIsInRpY2siLCJmb250U2l6ZSIsImNvbG9yIiwiZm9udEZhbWlseSIsIkF4aXMiLCJzdGF0ZSIsInJvdGF0aW9uIiwibWVhc3VyZVJvdGF0aW9uIiwidGhyb3R0bGUiLCJiaW5kIiwibWVhc3VyZSIsInVwZGF0ZVNjYWxlIiwibmV3UHJvcHMiLCJvbGRQcm9wcyIsInByb3BzIiwiYXhpcyIsInByZXZBeGlzIiwicHJpbWFyeSIsInR5cGUiLCJpbnZlcnQiLCJtYXRlcmlhbGl6ZWREYXRhIiwiaGVpZ2h0Iiwid2lkdGgiLCJwb3NpdGlvbiIsIm1pbiIsIm1heCIsImhhcmRNaW4iLCJoYXJkTWF4IiwibmV4dFN0YXRlIiwic2hvd0dyaWQiLCJ0aWNrU2l6ZUlubmVyIiwidGlja1NpemVPdXRlciIsImRpc3BsYXkiLCJzdHlsZXMiLCJheGlzU3R5bGVzIiwic2NhbGUiLCJ0cmFuc2Zvcm0iLCJ2ZXJ0aWNhbCIsImZvcm1hdCIsInRpY2tzIiwicmFuZ2UiLCJyYW5nZTAiLCJyYW5nZTEiLCJkaXJlY3Rpb25NdWx0aXBsaWVyIiwidGlja09mZnNldCIsImdyaWRPZmZzZXQiLCJzcGFjaW5nIiwiYXhpc1BhdGgiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsInVuZGVmaW5lZCIsImQiLCJpIiwiU3RyaW5nIiwidmlzaWJpbGl0eSIsIm1lYXN1cmVhYmxlIiwic2hvd0dyaWRMaW5lIiwiZWwiLCJpbnRlcnMiLCJtYXAiLCJpbnRlciIsImluZGV4Iiwia2V5IiwibGVuZ3RoIiwiZGF0YSIsImRlZmF1bHRQcm9wcyIsImJhc2UiLCJ0aWNrQXJndW1lbnRzIiwidGlja1ZhbHVlcyIsInRpY2tGb3JtYXQiLCJ0aWNrUGFkZGluZyIsIm1heExhYmVsUm90YXRpb24iLCJpbm5lclBhZGRpbmciLCJvdXRlclBhZGRpbmciLCJzZWxlY3RvcnMiLCJncmlkV2lkdGgiLCJncmlkSGVpZ2h0IiwicHJpbWFyeUF4aXMiLCJpZCIsImF4ZXMiLCJmaWx0ZXIiLCJvbGRTdGF0ZSIsIm5ld1N0YXRlIiwibWV0YSIsIngiLCJ5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7Ozs7Ozs7OztBQVZBOzs7QUFZTyxJQUFNQSxvQ0FBYyxLQUFwQjtBQUNBLElBQU1DLHdDQUFnQixPQUF0QjtBQUNBLElBQU1DLDBDQUFpQixRQUF2QjtBQUNBLElBQU1DLHNDQUFlLE1BQXJCOztBQUVQLElBQU1DLGdCQUFnQjtBQUNwQkMsUUFBTTtBQUNKQyxZQUFRLFNBREo7QUFFSkMsaUJBQWEsR0FGVDtBQUdKQyxVQUFNO0FBSEYsR0FEYztBQU1wQkMsUUFBTTtBQUNKQyxjQUFVLEVBRE47QUFFSkMsV0FBTyxNQUZIO0FBR0pDLGdCQUFZO0FBSFI7QUFOYyxDQUF0Qjs7SUFhTUMsSTs7O0FBbUJKO0FBQ0Esa0JBQWU7QUFBQTs7QUFBQTs7QUFFYixVQUFLQyxLQUFMLEdBQWE7QUFDWEMsZ0JBQVU7QUFEQyxLQUFiO0FBR0EsVUFBS0MsZUFBTCxHQUF1QixnQkFBTUMsUUFBTixDQUFlLHFCQUFRQyxJQUFSLE9BQWYsQ0FBdkI7QUFDQSxVQUFLQyxPQUFMLEdBQWUsZ0JBQU1GLFFBQU4sQ0FBZSxxQkFBUUMsSUFBUixPQUFmLENBQWY7QUFDQSxVQUFLRSxXQUFMLEdBQW1CLHFCQUFZRixJQUFaLE9BQW5CO0FBUGE7QUFRZDs7Ozs4Q0FDMEJHLFEsRUFBVTtBQUNuQyxVQUFNQyxXQUFXLEtBQUtDLEtBQXRCO0FBQ0EsVUFBSUQsU0FBU0UsSUFBVCxLQUFrQkgsU0FBU0csSUFBM0IsSUFB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LEVBREs7QUFFaEJDLGdCQUFZLG9CQUFVQSxVQUFWLEVBRkk7QUFHaEJDLGlCQUFhLG9CQUFVQSxXQUFWO0FBSEcsR0FBbEI7QUFLQSxTQUFPLFVBQUN4RSxLQUFELEVBQVFTLEtBQVIsRUFBa0I7QUFBQSxRQUNmSSxJQURlLEdBQ0lKLEtBREosQ0FDZkksSUFEZTtBQUFBLFFBQ1RLLFFBRFMsR0FDSVQsS0FESixDQUNUUyxRQURTOzs7QUFHdkIsUUFBTXVELEtBQVE1RCxJQUFSLFNBQWdCSyxRQUF0Qjs7QUFFQSxXQUFPO0FBQ0x1RCxZQURLO0FBRUwxRCx3QkFBa0JmLE1BQU1lLGdCQUZuQjtBQUdMRSxhQUFPb0QsVUFBVUMsU0FBVixDQUFvQnRFLEtBQXBCLENBSEY7QUFJTGdCLGNBQVFxRCxVQUFVRSxVQUFWLENBQXFCdkUsS0FBckIsQ0FKSDtBQUtMd0UsbUJBQWFILFVBQVVHLFdBQVYsQ0FBc0J4RSxLQUF0QixDQUxSO0FBTUxVLFlBQU1WLE1BQU0wRSxJQUFOLElBQWMxRSxNQUFNMEUsSUFBTixDQUFXRCxFQUFYO0FBTmYsS0FBUDtBQVFELEdBYkQ7QUFjRCxDQXJCWSxFQXNCYjtBQUNFRSxVQUFRLGdCQUFDQyxRQUFELEVBQVdDLFFBQVgsRUFBcUJDLElBQXJCLEVBQThCO0FBQ3BDLFdBQU9BLEtBQUtqRSxJQUFMLEtBQWMsUUFBckI7QUFDRDtBQUhILENBdEJhLEVBMkJiZCxJQTNCYSxDOzs7QUE2QmYsU0FBUzRDLFVBQVQsQ0FBcUJvQyxDQUFyQixFQUF3QjtBQUN0QixTQUFPLGVBQWVBLENBQWYsR0FBbUIsTUFBMUI7QUFDRDs7QUFFRCxTQUFTbkMsVUFBVCxDQUFxQm9DLENBQXJCLEVBQXdCO0FBQ3RCLFNBQU8sa0JBQWtCQSxDQUFsQixHQUFzQixHQUE3QjtBQUNEIiwiZmlsZSI6IkF4aXNMaW5lYXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ29ubmVjdCB9IGZyb20gJ3JlYWN0LXN0YXRlJ1xuaW1wb3J0IHsgQW5pbWF0ZSwgVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LW1vdmUnXG4vL1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL1V0aWxzJ1xuXG5pbXBvcnQgbWVhc3VyZSBmcm9tICcuL0F4aXNMaW5lYXIubWVhc3VyZSdcbmltcG9ydCB1cGRhdGVTY2FsZSBmcm9tICcuL0F4aXNMaW5lYXIudXBkYXRlU2NhbGUnXG5cbmltcG9ydCBQYXRoIGZyb20gJy4uL3ByaW1pdGl2ZXMvUGF0aCdcbmltcG9ydCBMaW5lIGZyb20gJy4uL3ByaW1pdGl2ZXMvTGluZSdcbmltcG9ydCBUZXh0IGZyb20gJy4uL3ByaW1pdGl2ZXMvVGV4dCdcblxuaW1wb3J0IFNlbGVjdG9ycyBmcm9tICcuLi91dGlscy9TZWxlY3RvcnMnXG5cbmV4cG9ydCBjb25zdCBwb3NpdGlvblRvcCA9ICd0b3AnXG5leHBvcnQgY29uc3QgcG9zaXRpb25SaWdodCA9ICdyaWdodCdcbmV4cG9ydCBjb25zdCBwb3NpdGlvbkJvdHRvbSA9ICdib3R0b20nXG5leHBvcnQgY29uc3QgcG9zaXRpb25MZWZ0ID0gJ2xlZnQnXG5cbmNvbnN0IGRlZmF1bHRTdHlsZXMgPSB7XG4gIGxpbmU6IHtcbiAgICBzdHJva2U6ICcjYWNhY2FjJyxcbiAgICBzdHJva2VXaWR0aDogJzEnLFxuICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gIH0sXG4gIHRpY2s6IHtcbiAgICBmb250U2l6ZTogMTAsXG4gICAgY29sb3I6ICcjMDAwJyxcbiAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gIH0sXG59XG5cbmNsYXNzIEF4aXMgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBtaW46IHVuZGVmaW5lZCxcbiAgICBtYXg6IHVuZGVmaW5lZCxcbiAgICBoYXJkTWluOiB1bmRlZmluZWQsXG4gICAgaGFyZE1heDogdW5kZWZpbmVkLFxuICAgIGJhc2U6IHVuZGVmaW5lZCxcbiAgICB0aWNrQXJndW1lbnRzOiBbXSxcbiAgICB0aWNrVmFsdWVzOiBudWxsLFxuICAgIHRpY2tGb3JtYXQ6IG51bGwsXG4gICAgdGlja1NpemVJbm5lcjogNixcbiAgICB0aWNrU2l6ZU91dGVyOiA2LFxuICAgIHRpY2tQYWRkaW5nOiAzLFxuICAgIG1heExhYmVsUm90YXRpb246IDUwLFxuICAgIGlubmVyUGFkZGluZzogMC4yLFxuICAgIG91dGVyUGFkZGluZzogMC4xLFxuICAgIHNob3dHcmlkOiAxLFxuICAgIGRpc3BsYXk6IHRydWUsXG4gIH1cbiAgLy8gTGlmZWN5Y2xlXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgIH1cbiAgICB0aGlzLm1lYXN1cmVSb3RhdGlvbiA9IFV0aWxzLnRocm90dGxlKG1lYXN1cmUuYmluZCh0aGlzKSlcbiAgICB0aGlzLm1lYXN1cmUgPSBVdGlscy50aHJvdHRsZShtZWFzdXJlLmJpbmQodGhpcykpXG4gICAgdGhpcy51cGRhdGVTY2FsZSA9IHVwZGF0ZVNjYWxlLmJpbmQodGhpcylcbiAgfVxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXdQcm9wcykge1xuICAgIGNvbnN0IG9sZFByb3BzID0gdGhpcy5wcm9wc1xuICAgIGlmIChvbGRQcm9wcy5heGlzICE9PSBuZXdQcm9wcy5heGlzICYmIG9sZFByb3BzLmF4aXMpIHtcbiAgICAgIHRoaXMucHJldkF4aXMgPSBvbGRQcm9wcy5heGlzXG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgY2hhbmdlLFxuICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBheGlzXG4gICAgaWYgKFxuICAgICAgbmV3UHJvcHMucHJpbWFyeSAhPT0gb2xkUHJvcHMucHJpbWFyeSB8fFxuICAgICAgbmV3UHJvcHMudHlwZSAhPT0gb2xkUHJvcHMudHlwZSB8fFxuICAgICAgbmV3UHJvcHMuaW52ZXJ0ICE9PSBvbGRQcm9wcy5pbnZlcnQgfHxcbiAgICAgIG5ld1Byb3BzLm1hdGVyaWFsaXplZERhdGEgIT09IG9sZFByb3BzLm1hdGVyaWFsaXplZERhdGEgfHxcbiAgICAgIG5ld1Byb3BzLmhlaWdodCAhPT0gb2xkUHJvcHMuaGVpZ2h0IHx8XG4gICAgICBuZXdQcm9wcy53aWR0aCAhPT0gb2xkUHJvcHMud2lkdGggfHxcbiAgICAgIG5ld1Byb3BzLnBvc2l0aW9uICE9PSBvbGRQcm9wcy5wb3NpdGlvbiB8fFxuICAgICAgbmV3UHJvcHMubWluICE9PSBvbGRQcm9wcy5taW4gfHxcbiAgICAgIG5ld1Byb3BzLm1heCAhPT0gb2xkUHJvcHMubWF4IHx8XG4gICAgICBuZXdQcm9wcy5oYXJkTWluICE9PSBvbGRQcm9wcy5oYXJkTWluIHx8XG4gICAgICBuZXdQcm9wcy5oYXJkTWF4ICE9PSBvbGRQcm9wcy5oYXJkTWF4XG4gICAgKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNjYWxlKG5ld1Byb3BzKVxuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy51cGRhdGVTY2FsZSh0aGlzLnByb3BzKVxuICB9XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV3UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIGlmIChcbiAgICAgIG5ld1Byb3BzLmF4aXMgIT09IHRoaXMucHJvcHMuYXhpcyB8fFxuICAgICAgdGhpcy5zdGF0ZS5yb3RhdGlvbiAhPT0gbmV4dFN0YXRlLnJvdGF0aW9uXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBheGlzLFxuICAgICAgcG9zaXRpb24sXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNob3dHcmlkLFxuICAgICAgdGlja1NpemVJbm5lcixcbiAgICAgIHRpY2tTaXplT3V0ZXIsXG4gICAgICBkaXNwbGF5LFxuICAgICAgc3R5bGVzLFxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB7IHJvdGF0aW9uIH0gPSB0aGlzLnN0YXRlXG5cbiAgICAvLyBDb21iaW5lIGRlZmF1bHQgc3R5bGVzIHdpdGggc3R5bGUgcHJvcHNcbiAgICBjb25zdCBheGlzU3R5bGVzID0ge1xuICAgICAgLi4uZGVmYXVsdFN0eWxlcyxcbiAgICAgIC4uLnN0eWxlcyxcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgRGVwZW5kZW5jaWVzXG4gICAgaWYgKCFheGlzIHx8ICFkaXNwbGF5KSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHNjYWxlLFxuICAgICAgbWF4LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdmVydGljYWwsXG4gICAgICBmb3JtYXQsXG4gICAgICAvL1xuICAgICAgdGlja3MsXG4gICAgICByYW5nZTogW3JhbmdlMCwgcmFuZ2UxXSxcbiAgICAgIGRpcmVjdGlvbk11bHRpcGxpZXIsXG4gICAgICB0aWNrT2Zmc2V0LFxuICAgICAgZ3JpZE9mZnNldCxcbiAgICAgIHNwYWNpbmcsXG4gICAgfSA9IGF4aXNcblxuICAgIHJldHVybiAoXG4gICAgICA8QW5pbWF0ZVxuICAgICAgICBkYXRhPXt7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIG1heCxcbiAgICAgICAgICByYW5nZTAsXG4gICAgICAgICAgcmFuZ2UxLFxuICAgICAgICAgIGRpcmVjdGlvbk11bHRpcGxpZXIsXG4gICAgICAgICAgdGlja1NpemVPdXRlcixcbiAgICAgICAgICB0aWNrT2Zmc2V0LFxuICAgICAgICAgIGdyaWRPZmZzZXQsXG4gICAgICAgICAgc3BhY2luZyxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgfX1cbiAgICAgICAgb25SZXN0PXsoKSA9PiB0aGlzLm1lYXN1cmVSb3RhdGlvbih0cnVlKX1cbiAgICAgID5cbiAgICAgICAgeyh7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIG1heCxcbiAgICAgICAgICByYW5nZTAsXG4gICAgICAgICAgcmFuZ2UxLFxuICAgICAgICAgIGRpcmVjdGlvbk11bHRpcGxpZXIsXG4gICAgICAgICAgdGlja1NpemVPdXRlcixcbiAgICAgICAgICB0aWNrT2Zmc2V0LFxuICAgICAgICAgIGdyaWRPZmZzZXQsXG4gICAgICAgICAgc3BhY2luZyxcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgIGxldCBheGlzUGF0aFxuICAgICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBwb3NpdGlvbkxlZnQpIHtcbiAgICAgICAgICAgICAgYXhpc1BhdGggPSBgXG4gICAgICAgICAgICAgICAgTSAkey10aWNrU2l6ZU91dGVyfSwgJHtyYW5nZTB9XG4gICAgICAgICAgICAgICAgSCAwXG4gICAgICAgICAgICAgICAgViAke3JhbmdlMX1cbiAgICAgICAgICAgICAgICBIICR7LXRpY2tTaXplT3V0ZXJ9XG4gICAgICAgICAgICAgIGBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF4aXNQYXRoID0gYFxuICAgICAgICAgICAgICAgIE0gJHt0aWNrU2l6ZU91dGVyfSwgJHtyYW5nZTB9XG4gICAgICAgICAgICAgICAgSCAwXG4gICAgICAgICAgICAgICAgViAke3JhbmdlMX1cbiAgICAgICAgICAgICAgICBIICR7dGlja1NpemVPdXRlcn1cbiAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IHBvc2l0aW9uQm90dG9tKSB7XG4gICAgICAgICAgICAgIGF4aXNQYXRoID0gYFxuICAgICAgICAgICAgICAgIE0gMCwgJHt0aWNrU2l6ZU91dGVyfVxuICAgICAgICAgICAgICAgIFYgMFxuICAgICAgICAgICAgICAgIEggJHtyYW5nZTF9XG4gICAgICAgICAgICAgICAgViAke3RpY2tTaXplT3V0ZXJ9XG4gICAgICAgICAgICAgIGBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF4aXNQYXRoID0gYFxuICAgICAgICAgICAgICAgIE0gMCwgJHstdGlja1NpemVPdXRlcn1cbiAgICAgICAgICAgICAgICBWIDBcbiAgICAgICAgICAgICAgICBIICR7cmFuZ2UxfVxuICAgICAgICAgICAgICAgIFYgJHstdGlja1NpemVPdXRlcn1cbiAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8Z1xuICAgICAgICAgICAgICBjbGFzc05hbWU9J0F4aXMnXG4gICAgICAgICAgICAgIHRyYW5zZm9ybT17XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPT09IHBvc2l0aW9uUmlnaHRcbiAgICAgICAgICAgICAgICAgID8gdHJhbnNsYXRlWCh3aWR0aClcbiAgICAgICAgICAgICAgICAgIDogcG9zaXRpb24gPT09IHBvc2l0aW9uQm90dG9tID8gdHJhbnNsYXRlWShoZWlnaHQpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPFBhdGggY2xhc3NOYW1lPSdkb21haW4nIGQ9e2F4aXNQYXRofSBzdHlsZT17YXhpc1N0eWxlcy5saW5lfSAvPlxuICAgICAgICAgICAgICA8VHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIGRhdGE9e1suLi50aWNrc119XG4gICAgICAgICAgICAgICAgZ2V0S2V5PXsoZCwgaSkgPT4gU3RyaW5nKGQpfVxuICAgICAgICAgICAgICAgIHVwZGF0ZT17ZCA9PiAoe1xuICAgICAgICAgICAgICAgICAgdGljazogc2NhbGUoZCksXG4gICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgbWVhc3VyZWFibGU6IDEsXG4gICAgICAgICAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICBlbnRlcj17ZCA9PiAoe1xuICAgICAgICAgICAgICAgICAgdGljazogdGhpcy5wcmV2QXhpcy5zY2FsZShkKSxcbiAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IDAsXG4gICAgICAgICAgICAgICAgICBtZWFzdXJlYWJsZTogMSxcbiAgICAgICAgICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIGxlYXZlPXtkID0+ICh7XG4gICAgICAgICAgICAgICAgICB0aWNrOiBzY2FsZShkKSxcbiAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IDAsXG4gICAgICAgICAgICAgICAgICBtZWFzdXJlYWJsZTogMCxcbiAgICAgICAgICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIGlnbm9yZT17WydtZWFzdXJlYWJsZSddfVxuICAgICAgICAgICAgICAgIGR1cmF0aW9uPXs1MDB9XG4gICAgICAgICAgICAgICAgb25SZXN0PXsoKSA9PiB0aGlzLm1lYXN1cmUoKX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtpbnRlcnMgPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IHNob3dHcmlkTGluZSA9IHNob3dHcmlkXG5cbiAgICAgICAgICAgICAgICAgIC8vIElmIG9yZGluYWwgYW5kIHNob3dHcmlkIGlzbid0IGV4cGxpY2l0LCBoaWRlIGl0XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ29yZGluYWwnICYmIHNob3dHcmlkID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dHcmlkTGluZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxnXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPSd0aWNrcydcbiAgICAgICAgICAgICAgICAgICAgICByZWY9e2VsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwgPSBlbFxuICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7aW50ZXJzLm1hcCgoaW50ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8Z1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW50ZXIua2V5fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGljaycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGludGVyLnN0YXRlLm1lYXN1cmVhYmxlID8gJyAtbWVhc3VyZWFibGUnIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17dHJhbnNmb3JtKGludGVyLnN0YXRlLnRpY2spfVxuICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPExpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxPXt2ZXJ0aWNhbCA/IDAgOiB0aWNrT2Zmc2V0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDI9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGlyZWN0aW9uTXVsdGlwbGllciAqIHRpY2tTaXplSW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRpY2tPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxPXt2ZXJ0aWNhbCA/IHRpY2tPZmZzZXQgOiAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTI9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGlja09mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGlyZWN0aW9uTXVsdGlwbGllciAqIHRpY2tTaXplSW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9e2ludGVyLnN0YXRlLnZpc2liaWxpdHkgKiAwLjJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c2hvd0dyaWRMaW5lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MT17dmVydGljYWwgPyAwIDogZ3JpZE9mZnNldH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDI9e3ZlcnRpY2FsID8gbWF4IDogZ3JpZE9mZnNldH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTE9e3ZlcnRpY2FsID8gZ3JpZE9mZnNldCA6IDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyPXt2ZXJ0aWNhbCA/IGdyaWRPZmZzZXQgOiBtYXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyLnN0YXRlLnZpc2liaWxpdHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbmRleCAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggIT09IGludGVycy5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlci5kYXRhID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDAuNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwLjIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5PXtpbnRlci5zdGF0ZS52aXNpYmlsaXR5fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e2F4aXNTdHlsZXMudGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUoJHt2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGlyZWN0aW9uTXVsdGlwbGllciAqIHNwYWNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRpY2tPZmZzZXR9LCAke3ZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGlja09mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRpcmVjdGlvbk11bHRpcGxpZXIgKiBzcGFjaW5nfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlKCR7LWludGVyLnN0YXRlLnJvdGF0aW9ufSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXIuc3RhdGUucm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdjZW50cmFsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcG9zaXRpb24gPT09IHBvc2l0aW9uQm90dG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdoYW5naW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwb3NpdGlvbiA9PT0gcG9zaXRpb25Ub3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYWxwaGFiZXRpYydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnY2VudHJhbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlci5zdGF0ZS5yb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2VuZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBvc2l0aW9uID09PSBwb3NpdGlvblJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcG9zaXRpb24gPT09IHBvc2l0aW9uTGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdlbmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Zm9ybWF0KGludGVyLmRhdGEpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPC9UcmFuc2l0aW9uPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgIDwvQW5pbWF0ZT5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29ubmVjdChcbiAgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9ycyA9IHtcbiAgICAgIGdyaWRXaWR0aDogU2VsZWN0b3JzLmdyaWRXaWR0aCgpLFxuICAgICAgZ3JpZEhlaWdodDogU2VsZWN0b3JzLmdyaWRIZWlnaHQoKSxcbiAgICAgIHByaW1hcnlBeGlzOiBTZWxlY3RvcnMucHJpbWFyeUF4aXMoKSxcbiAgICB9XG4gICAgcmV0dXJuIChzdGF0ZSwgcHJvcHMpID0+IHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgcG9zaXRpb24gfSA9IHByb3BzXG5cbiAgICAgIGNvbnN0IGlkID0gYCR7dHlwZX1fJHtwb3NpdGlvbn1gXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICBtYXRlcmlhbGl6ZWREYXRhOiBzdGF0ZS5tYXRlcmlhbGl6ZWREYXRhLFxuICAgICAgICB3aWR0aDogc2VsZWN0b3JzLmdyaWRXaWR0aChzdGF0ZSksXG4gICAgICAgIGhlaWdodDogc2VsZWN0b3JzLmdyaWRIZWlnaHQoc3RhdGUpLFxuICAgICAgICBwcmltYXJ5QXhpczogc2VsZWN0b3JzLnByaW1hcnlBeGlzKHN0YXRlKSxcbiAgICAgICAgYXhpczogc3RhdGUuYXhlcyAmJiBzdGF0ZS5heGVzW2lkXSxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHtcbiAgICBmaWx0ZXI6IChvbGRTdGF0ZSwgbmV3U3RhdGUsIG1ldGEpID0+IHtcbiAgICAgIHJldHVybiBtZXRhLnR5cGUgIT09ICdjdXJzb3InXG4gICAgfSxcbiAgfVxuKShBeGlzKVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVYICh4KSB7XG4gIHJldHVybiAndHJhbnNsYXRlKCcgKyB4ICsgJywgMCknXG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVkgKHkpIHtcbiAgcmV0dXJuICd0cmFuc2xhdGUoMCwgJyArIHkgKyAnKSdcbn1cbiJdfQ==