'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactState = require('react-state');

var _reactMove = require('react-move');

var _d3Shape = require('d3-shape');

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

var _Utils = require('../utils/Utils');

var _Utils2 = _interopRequireDefault(_Utils);

var _interactionMethods = require('../utils/interactionMethods');

var _Path = require('../primitives/Path');

var _Path2 = _interopRequireDefault(_Path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//


var Arc = _d3Shape.arc;

var arcDefaultStyle = {
  r: 2
};

var Pie = function (_PureComponent) {
  _inherits(Pie, _PureComponent);

  function Pie() {
    _classCallCheck(this, Pie);

    var _this = _possibleConstructorReturn(this, (Pie.__proto__ || Object.getPrototypeOf(Pie)).call(this));

    _this.selectSeries = _interactionMethods.selectSeries.bind(_this);
    _this.hoverSeries = _interactionMethods.hoverSeries.bind(_this);
    _this.selectDatum = _interactionMethods.selectDatum.bind(_this);
    _this.hoverDatum = _interactionMethods.hoverDatum.bind(_this);
    return _this;
  }

  _createClass(Pie, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          series = _props.series,
          visibility = _props.visibility,
          stackData = _props.stackData,
          selected = _props.selected,
          hovered = _props.hovered,
          interaction = _props.interaction,
          primaryAxis = _props.primaryAxis;


      var status = _Utils2.default.seriesStatus(series, hovered, selected);
      var style = _Utils2.default.getStatusStyle(status, series.statusStyles);

      var radius = primaryAxis.radius,
          cutoutPercentage = primaryAxis.cutoutPercentage,
          cornerRadius = primaryAxis.cornerRadius,
          arcPadding = primaryAxis.arcPadding,
          seriesPadding = primaryAxis.seriesPadding;


      var outerRadius = radius;
      var innerRadius = radius * cutoutPercentage;
      var totalRadius = outerRadius - innerRadius;
      var seriesRadius = totalRadius / stackData.length;
      var seriesInnerRadius = innerRadius + seriesRadius * series.index;
      var seriesOuterRadius = seriesInnerRadius + seriesRadius;

      var arcPaddingRadius = outerRadius * arcPadding * 20;
      var seriesPaddingRadius = totalRadius * seriesPadding / 2.5;

      var preData = series.data.map(function (d) {
        return {
          x: d.primary,
          y: d.secondary
        };
      });

      var pie = (0, _d3Shape.pie)().sort(null).padAngle(0.01).value(function (d) {
        return d.y;
      });
      var data = pie(preData);

      return _react2.default.createElement(
        _reactMove.Animate,
        {
          'default': {
            data: data,
            visibility: 0,
            seriesPaddingRadius: 0,
            seriesInnerRadius: outerRadius,
            seriesOuterRadius: outerRadius,
            cornerRadius: cornerRadius,
            arcPaddingRadius: arcPaddingRadius
          },
          data: {
            data: data,
            visibility: visibility,
            seriesPaddingRadius: seriesPaddingRadius,
            seriesInnerRadius: seriesInnerRadius,
            seriesOuterRadius: seriesOuterRadius,
            cornerRadius: cornerRadius,
            arcPaddingRadius: arcPaddingRadius
          },
          duration: 500
        },
        function (inter) {
          var seriesInteractionProps = interaction === 'series' ? {
            onClick: function onClick() {
              return _this2.selectSeries(series);
            },
            onMouseEnter: function onMouseEnter() {
              return _this2.hoverSeries(series);
            },
            onMouseMove: function onMouseMove() {
              return _this2.hoverSeries(series);
            },
            onMouseLeave: function onMouseLeave() {
              return _this2.hoverSeries(null);
            }
          } : {};

          return _react2.default.createElement(
            'g',
            {
              transform: 'translate(' + primaryAxis.width / 2 + ', ' + primaryAxis.height / 2 + ')'
            },
            series.data.map(function (datum, i) {
              var status = _Utils2.default.datumStatus(series, datum, hovered, selected);
              var dataStyle = _Utils2.default.getStatusStyle(status, datum.statusStyles);

              var datumInteractionProps = interaction === 'element' ? {
                onClick: function onClick() {
                  return _this2.selectDatum(datum);
                },
                onMouseEnter: function onMouseEnter() {
                  return _this2.hoverDatum(datum);
                },
                onMouseMove: function onMouseMove() {
                  return _this2.hoverDatum(datum);
                },
                onMouseLeave: function onMouseLeave() {
                  return _this2.hoverDatum(null);
                }
              } : {};

              var arc = Arc().startAngle(inter.data[i].startAngle).endAngle(inter.data[i].endAngle).padAngle(inter.data[i].padAngle).padRadius(inter.arcPaddingRadius).innerRadius(inter.seriesInnerRadius + seriesPaddingRadius).outerRadius(inter.seriesOuterRadius).cornerRadius(inter.cornerRadius);

              return _react2.default.createElement(_Path2.default, _extends({
                key: i,
                d: arc(),
                style: _extends({}, arcDefaultStyle, style, style.arc, dataStyle, dataStyle.arc),
                opacity: inter.visibility
              }, seriesInteractionProps, datumInteractionProps));
            })
          );
        }
      );
    }
  }]);

  return Pie;
}(_react.PureComponent);

Pie.defaultProps = {
  showPoints: true
};
exports.default = (0, _reactState.Connect)(function () {
  var selectors = {
    primaryAxis: _Selectors2.default.primaryAxis()
  };
  return function (state, props) {
    return {
      primaryAxis: selectors.primaryAxis(state),
      hovered: state.hovered,
      selected: state.selected,
      interaction: state.interaction
    };
  };
}, {
  filter: function filter(oldState, newState, meta) {
    return meta.type !== 'cursor';
  },
  statics: {
    SeriesType: 'Pie'
  }
})(Pie);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL1BpZS5qcyJdLCJuYW1lcyI6WyJBcmMiLCJhcmNEZWZhdWx0U3R5bGUiLCJyIiwiUGllIiwic2VsZWN0U2VyaWVzIiwiYmluZCIsImhvdmVyU2VyaWVzIiwic2VsZWN0RGF0dW0iLCJob3ZlckRhdHVtIiwicHJvcHMiLCJzZXJpZXMiLCJ2aXNpYmlsaXR5Iiwic3RhY2tEYXRhIiwic2VsZWN0ZWQiLCJob3ZlcmVkIiwiaW50ZXJhY3Rpb24iLCJwcmltYXJ5QXhpcyIsInN0YXR1cyIsInNlcmllc1N0YXR1cyIsInN0eWxlIiwiZ2V0U3RhdHVzU3R5bGUiLCJzdGF0dXNTdHlsZXMiLCJyYWRpdXMiLCJjdXRvdXRQZXJjZW50YWdlIiwiY29ybmVyUmFkaXVzIiwiYXJjUGFkZGluZyIsInNlcmllc1BhZGRpbmciLCJvdXRlclJhZGl1cyIsImlubmVyUmFkaXVzIiwidG90YWxSYWRpdXMiLCJzZXJpZXNSYWRpdXMiLCJsZW5ndGgiLCJzZXJpZXNJbm5lclJhZGl1cyIsImluZGV4Iiwic2VyaWVzT3V0ZXJSYWRpdXMiLCJhcmNQYWRkaW5nUmFkaXVzIiwic2VyaWVzUGFkZGluZ1JhZGl1cyIsInByZURhdGEiLCJkYXRhIiwibWFwIiwieCIsImQiLCJwcmltYXJ5IiwieSIsInNlY29uZGFyeSIsInBpZSIsInNvcnQiLCJwYWRBbmdsZSIsInZhbHVlIiwic2VyaWVzSW50ZXJhY3Rpb25Qcm9wcyIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VMZWF2ZSIsIndpZHRoIiwiaGVpZ2h0IiwiZGF0dW0iLCJpIiwiZGF0dW1TdGF0dXMiLCJkYXRhU3R5bGUiLCJkYXR1bUludGVyYWN0aW9uUHJvcHMiLCJhcmMiLCJzdGFydEFuZ2xlIiwiaW50ZXIiLCJlbmRBbmdsZSIsInBhZFJhZGl1cyIsImRlZmF1bHRQcm9wcyIsInNob3dQb2ludHMiLCJzZWxlY3RvcnMiLCJzdGF0ZSIsImZpbHRlciIsIm9s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TXhELFFBSFg7QUFJTEUsbUJBQWFzRCxNQUFNdEQ7QUFKZCxLQUFQO0FBTUQsR0FQRDtBQVFELENBYlksRUFjYjtBQUNFdUQsVUFBUSxnQkFBQ0MsUUFBRCxFQUFXQyxRQUFYLEVBQXFCQyxJQUFyQjtBQUFBLFdBQThCQSxLQUFLQyxJQUFMLEtBQWMsUUFBNUM7QUFBQSxHQURWO0FBRUVDLFdBQVM7QUFDUEMsZ0JBQVk7QUFETDtBQUZYLENBZGEsRUFvQmJ6RSxHQXBCYSxDIiwiZmlsZSI6IlBpZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDb25uZWN0IH0gZnJvbSAncmVhY3Qtc3RhdGUnXG5pbXBvcnQgeyBBbmltYXRlIH0gZnJvbSAncmVhY3QtbW92ZSdcbmltcG9ydCB7IHBpZSBhcyBtYWtlUGllLCBhcmMgYXMgbWFrZUFyYyB9IGZyb20gJ2QzLXNoYXBlJ1xuXG5pbXBvcnQgU2VsZWN0b3JzIGZyb20gJy4uL3V0aWxzL1NlbGVjdG9ycydcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy9VdGlscydcbmltcG9ydCB7XG4gIHNlbGVjdFNlcmllcyxcbiAgc2VsZWN0RGF0dW0sXG4gIGhvdmVyU2VyaWVzLFxuICBob3ZlckRhdHVtLFxufSBmcm9tICcuLi91dGlscy9pbnRlcmFjdGlvbk1ldGhvZHMnXG5cbi8vXG5pbXBvcnQgUGF0aCBmcm9tICcuLi9wcmltaXRpdmVzL1BhdGgnXG5cbmNvbnN0IEFyYyA9IG1ha2VBcmNcblxuY29uc3QgYXJjRGVmYXVsdFN0eWxlID0ge1xuICByOiAyLFxufVxuXG5jbGFzcyBQaWUgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBzaG93UG9pbnRzOiB0cnVlLFxuICB9XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zZWxlY3RTZXJpZXMgPSBzZWxlY3RTZXJpZXMuYmluZCh0aGlzKVxuICAgIHRoaXMuaG92ZXJTZXJpZXMgPSBob3ZlclNlcmllcy5iaW5kKHRoaXMpXG4gICAgdGhpcy5zZWxlY3REYXR1bSA9IHNlbGVjdERhdHVtLmJpbmQodGhpcylcbiAgICB0aGlzLmhvdmVyRGF0dW0gPSBob3ZlckRhdHVtLmJpbmQodGhpcylcbiAgfVxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcmllcyxcbiAgICAgIHZpc2liaWxpdHksXG4gICAgICBzdGFja0RhdGEsIC8vIHdlIG5lZWQgdGhpcyB0byBmaWd1cmUgb3V0IHdoaWNoIGxldmVsIHdlJ3JlIG9uXG4gICAgICAvL1xuICAgICAgc2VsZWN0ZWQsXG4gICAgICBob3ZlcmVkLFxuICAgICAgaW50ZXJhY3Rpb24sXG4gICAgICBwcmltYXJ5QXhpcyxcbiAgICB9ID0gdGhpcy5wcm9wc1xuXG4gICAgY29uc3Qgc3RhdHVzID0gVXRpbHMuc2VyaWVzU3RhdHVzKHNlcmllcywgaG92ZXJlZCwgc2VsZWN0ZWQpXG4gICAgY29uc3Qgc3R5bGUgPSBVdGlscy5nZXRTdGF0dXNTdHlsZShzdGF0dXMsIHNlcmllcy5zdGF0dXNTdHlsZXMpXG5cbiAgICBjb25zdCB7XG4gICAgICByYWRpdXMsXG4gICAgICBjdXRvdXRQZXJjZW50YWdlLFxuICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgYXJjUGFkZGluZyxcbiAgICAgIHNlcmllc1BhZGRpbmcsXG4gICAgfSA9IHByaW1hcnlBeGlzXG5cbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHJhZGl1c1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzICogY3V0b3V0UGVyY2VudGFnZVxuICAgIGNvbnN0IHRvdGFsUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1c1xuICAgIGNvbnN0IHNlcmllc1JhZGl1cyA9IHRvdGFsUmFkaXVzIC8gc3RhY2tEYXRhLmxlbmd0aFxuICAgIGNvbnN0IHNlcmllc0lubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBzZXJpZXNSYWRpdXMgKiBzZXJpZXMuaW5kZXhcbiAgICBjb25zdCBzZXJpZXNPdXRlclJhZGl1cyA9IHNlcmllc0lubmVyUmFkaXVzICsgc2VyaWVzUmFkaXVzXG5cbiAgICBjb25zdCBhcmNQYWRkaW5nUmFkaXVzID0gb3V0ZXJSYWRpdXMgKiBhcmNQYWRkaW5nICogMjBcbiAgICBjb25zdCBzZXJpZXNQYWRkaW5nUmFkaXVzID0gdG90YWxSYWRpdXMgKiBzZXJpZXNQYWRkaW5nIC8gMi41XG5cbiAgICBjb25zdCBwcmVEYXRhID0gc2VyaWVzLmRhdGEubWFwKGQgPT4gKHtcbiAgICAgIHg6IGQucHJpbWFyeSxcbiAgICAgIHk6IGQuc2Vjb25kYXJ5LFxuICAgIH0pKVxuXG4gICAgY29uc3QgcGllID0gbWFrZVBpZSgpLnNvcnQobnVsbCkucGFkQW5nbGUoMC4wMSkudmFsdWUoZCA9PiBkLnkpXG4gICAgY29uc3QgZGF0YSA9IHBpZShwcmVEYXRhKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxBbmltYXRlXG4gICAgICAgIGRlZmF1bHQ9e3tcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHZpc2liaWxpdHk6IDAsXG4gICAgICAgICAgc2VyaWVzUGFkZGluZ1JhZGl1czogMCxcbiAgICAgICAgICBzZXJpZXNJbm5lclJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgICAgICAgc2VyaWVzT3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBhcmNQYWRkaW5nUmFkaXVzLFxuICAgICAgICB9fVxuICAgICAgICBkYXRhPXt7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICB2aXNpYmlsaXR5LFxuICAgICAgICAgIHNlcmllc1BhZGRpbmdSYWRpdXMsXG4gICAgICAgICAgc2VyaWVzSW5uZXJSYWRpdXMsXG4gICAgICAgICAgc2VyaWVzT3V0ZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGFyY1BhZGRpbmdSYWRpdXMsXG4gICAgICAgIH19XG4gICAgICAgIGR1cmF0aW9uPXs1MDB9XG4gICAgICA+XG4gICAgICAgIHtpbnRlciA9PiB7XG4gICAgICAgICAgY29uc3Qgc2VyaWVzSW50ZXJhY3Rpb25Qcm9wcyA9IGludGVyYWN0aW9uID09PSAnc2VyaWVzJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHRoaXMuc2VsZWN0U2VyaWVzKHNlcmllcyksXG4gICAgICAgICAgICAgIG9uTW91c2VFbnRlcjogKCkgPT4gdGhpcy5ob3ZlclNlcmllcyhzZXJpZXMpLFxuICAgICAgICAgICAgICBvbk1vdXNlTW92ZTogKCkgPT4gdGhpcy5ob3ZlclNlcmllcyhzZXJpZXMpLFxuICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU6ICgpID0+IHRoaXMuaG92ZXJTZXJpZXMobnVsbCksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGdcbiAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7cHJpbWFyeUF4aXMud2lkdGggL1xuICAgICAgICAgICAgICAgIDJ9LCAke3ByaW1hcnlBeGlzLmhlaWdodCAvIDJ9KWB9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtzZXJpZXMuZGF0YS5tYXAoKGRhdHVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gVXRpbHMuZGF0dW1TdGF0dXMoXG4gICAgICAgICAgICAgICAgICBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICBkYXR1bSxcbiAgICAgICAgICAgICAgICAgIGhvdmVyZWQsXG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhU3R5bGUgPSBVdGlscy5nZXRTdGF0dXNTdHlsZShcbiAgICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIGRhdHVtLnN0YXR1c1N0eWxlc1xuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdHVtSW50ZXJhY3Rpb25Qcm9wcyA9IGludGVyYWN0aW9uID09PSAnZWxlbWVudCdcbiAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0aGlzLnNlbGVjdERhdHVtKGRhdHVtKSxcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyOiAoKSA9PiB0aGlzLmhvdmVyRGF0dW0oZGF0dW0pLFxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZTogKCkgPT4gdGhpcy5ob3ZlckRhdHVtKGRhdHVtKSxcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlOiAoKSA9PiB0aGlzLmhvdmVyRGF0dW0obnVsbCksXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICA6IHt9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhcmMgPSBBcmMoKVxuICAgICAgICAgICAgICAgICAgLnN0YXJ0QW5nbGUoaW50ZXIuZGF0YVtpXS5zdGFydEFuZ2xlKVxuICAgICAgICAgICAgICAgICAgLmVuZEFuZ2xlKGludGVyLmRhdGFbaV0uZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgICAucGFkQW5nbGUoaW50ZXIuZGF0YVtpXS5wYWRBbmdsZSlcbiAgICAgICAgICAgICAgICAgIC5wYWRSYWRpdXMoaW50ZXIuYXJjUGFkZGluZ1JhZGl1cylcbiAgICAgICAgICAgICAgICAgIC5pbm5lclJhZGl1cyhpbnRlci5zZXJpZXNJbm5lclJhZGl1cyArIHNlcmllc1BhZGRpbmdSYWRpdXMpXG4gICAgICAgICAgICAgICAgICAub3V0ZXJSYWRpdXMoaW50ZXIuc2VyaWVzT3V0ZXJSYWRpdXMpXG4gICAgICAgICAgICAgICAgICAuY29ybmVyUmFkaXVzKGludGVyLmNvcm5lclJhZGl1cylcblxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICA8UGF0aFxuICAgICAgICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgICAgICAgIGQ9e2FyYygpfVxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmFyY0RlZmF1bHRTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAuLi5zdHlsZS5hcmMsXG4gICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YVN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGFTdHlsZS5hcmMsXG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9e2ludGVyLnZpc2liaWxpdHl9XG4gICAgICAgICAgICAgICAgICAgIHsuLi5zZXJpZXNJbnRlcmFjdGlvblByb3BzfVxuICAgICAgICAgICAgICAgICAgICB7Li4uZGF0dW1JbnRlcmFjdGlvblByb3BzfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgIDwvQW5pbWF0ZT5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29ubmVjdChcbiAgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9ycyA9IHtcbiAgICAgIHByaW1hcnlBeGlzOiBTZWxlY3RvcnMucHJpbWFyeUF4aXMoKSxcbiAgICB9XG4gICAgcmV0dXJuIChzdGF0ZSwgcHJvcHMpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByaW1hcnlBeGlzOiBzZWxlY3RvcnMucHJpbWFyeUF4aXMoc3RhdGUpLFxuICAgICAgICBob3ZlcmVkOiBzdGF0ZS5ob3ZlcmVkLFxuICAgICAgICBzZWxlY3RlZDogc3RhdGUuc2VsZWN0ZWQsXG4gICAgICAgIGludGVyYWN0aW9uOiBzdGF0ZS5pbnRlcmFjdGlvbixcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHtcbiAgICBmaWx0ZXI6IChvbGRTdGF0ZSwgbmV3U3RhdGUsIG1ldGEpID0+IG1ldGEudHlwZSAhPT0gJ2N1cnNvcicsXG4gICAgc3RhdGljczoge1xuICAgICAgU2VyaWVzVHlwZTogJ1BpZScsXG4gICAgfSxcbiAgfVxuKShQaWUpXG4iXX0=