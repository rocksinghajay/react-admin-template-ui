'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactState = require('react-state');

var _d3Voronoi = require('d3-voronoi');

var _d3Shape = require('d3-shape');

var _Path = require('../primitives/Path');

var _Path2 = _interopRequireDefault(_Path);

var _Selectors = require('../utils/Selectors');

var _Selectors2 = _interopRequireDefault(_Selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//


var noop = function noop() {
  return null;
};

var modeClosestSeries = 'closestSeries';
var modeClosestPoint = 'closestPoint';
var modeAxis = 'axis';

var Interaction = function (_PureComponent) {
  _inherits(Interaction, _PureComponent);

  function Interaction() {
    _classCallCheck(this, Interaction);

    var _this = _possibleConstructorReturn(this, (Interaction.__proto__ || Object.getPrototypeOf(Interaction)).call(this));

    _this.onHover = _this.onHover.bind(_this);
    _this.onClick = _this.onClick.bind(_this);
    return _this;
  }

  _createClass(Interaction, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          interaction = _props.interaction,
          stackData = _props.stackData,
          primaryAxis = _props.primaryAxis,
          secondaryAxis = _props.secondaryAxis;

      // Don't render until we have all dependencies

      if (!stackData || !primaryAxis || !secondaryAxis) {
        return null;
      }

      var xScale = primaryAxis.vertical ? secondaryAxis : primaryAxis;
      var yScale = primaryAxis.vertical ? primaryAxis : secondaryAxis;

      var extent = [[xScale.scale.range()[0], yScale.scale.range()[1]], [xScale.scale.range()[1], yScale.scale.range()[0]]];
      var lineFn = (0, _d3Shape.line)();

      var polygons = void 0;

      if (interaction === modeClosestSeries) {
        // Closest Point Voronoi
        var voronoiData = stackData.reduce(function (prev, now) {
          return prev.concat(now.data);
        }, []).map(function (d) {
          return {
            x: d.focus.x,
            y: d.focus.y,
            series: stackData[d.seriesIndex],
            datums: null,
            single: false
          };
        }).filter(function (d) {
          return typeof d.x === 'number' && typeof d.y === 'number';
        });
        var vor = (0, _d3Voronoi.voronoi)().x(function (d) {
          return d.x;
        }).y(function (d) {
          return d.y;
        }).extent(extent)(voronoiData);
        polygons = vor.polygons();
      } else if (interaction === modeClosestPoint) {
        // Closest Point Voronoi
        var _voronoiData = stackData.reduce(function (prev, now) {
          return prev.concat(now.data);
        }, []).map(function (d) {
          return {
            x: d.focus.x,
            y: d.focus.y,
            series: null,
            datums: [d],
            single: true
          };
        }).filter(function (d) {
          return typeof d.x === 'number' && typeof d.y === 'number';
        });
        var _vor = (0, _d3Voronoi.voronoi)().x(function (d) {
          return d.x;
        }).y(function (d) {
          return d.y;
        }).extent(extent)(_voronoiData);
        polygons = _vor.polygons();
      } else if (interaction === modeAxis) {
        // Axis Voronoi
        // Group all data points based on primaryAxis
        var allDatums = stackData.reduce(function (prev, now) {
          return prev.concat(now.data);
        }, []);
        var datumsByAxis = {};
        allDatums.forEach(function (d) {
          var key = String(d.primary);
          datumsByAxis[key] = datumsByAxis[key] || {
            x: d.focus.x,
            y: d.focus.y,
            series: null, // AxisAxis can't be the series, so don't send it
            datums: [],
            single: false
          };
          datumsByAxis[key].datums.push(d);
        });
        var _voronoiData2 = Object.keys(datumsByAxis).map(function (d) {
          return datumsByAxis[d];
        });
        var _vor2 = (0, _d3Voronoi.voronoi)().x(function (d) {
          return primaryAxis.vertical ? 0 : d.x;
        }).y(function (d) {
          return primaryAxis.vertical ? d.y : 0;
        }).extent(extent)(_voronoiData2);
        polygons = _vor2.polygons();
      } else {
        return null;
      }

      // Series and Element interactions modes are handled by the
      // elements themselves, so do nothing for them here.

      return _react2.default.createElement(
        'g',
        { className: 'Interaction', onMouseLeave: function onMouseLeave() {
            return _this2.onHover(null, null);
          } },
        !!polygons && polygons.map(function (points, i) {
          // Only draw the voronoi if we need it
          var path = lineFn(points);
          return _react2.default.createElement(_Path2.default, {
            key: i,
            d: path,
            className: 'action-voronoi',
            onMouseEnter: function onMouseEnter(e) {
              return _this2.onHover(points.data.series, points.data.datums);
            },
            onClick: function onClick(e) {
              return _this2.onClick(points.data.series, points.data.datums);
            },
            style: {
              fill: 'rgba(0,0,0,.2)',
              strokeWidth: 5,
              stroke: 'rgba(255,255,255,.5)',
              opacity: 0
            }
          });
        })
      );
    }
  }, {
    key: 'onHover',
    value: function onHover(series, datums) {
      // activate the hover with any series or datums
      if (series || datums) {
        return this.props.dispatch(function (state) {
          return _extends({}, state, {
            hovered: {
              active: true,
              series: series,
              datums: datums
            }
          });
        }, {
          type: 'hoveredVoronoi'
        });
      }
      // If we just left the area, deactive the hover
      return this.props.dispatch(function (state) {
        return _extends({}, state, {
          hovered: _extends({}, state.hovered, {
            active: false
          })
        });
      }, {
        type: 'hoveredVoronoi'
      });
    }
  }, {
    key: 'onClick',
    value: function onClick(series, datums) {
      if (series || datums) {
        return this.props.dispatch(function (state) {
          return _extends({}, state, {
            selected: {
              active: true,
              series: series,
              datums: datums
            }
          });
        }, {
          type: 'selectedVoronoi'
        });
      }
    }
  }]);

  return Interaction;
}(_react.PureComponent);

Interaction.defaultProps = {
  onHover: noop,
  onActivate: noop
};
exports.default = (0, _reactState.Connect)(function () {
  var selectors = {
    primaryAxis: _Selectors2.default.primaryAxis(),
    secondaryAxis: _Selectors2.default.secondaryAxis()
  };
  return function (state) {
    return {
      stackData: state.stackData,
      primaryAxis: selectors.primaryAxis(state),
      secondaryAxis: selectors.secondaryAxis(state),
      interaction: state.interaction
    };
  };
}, {
  filter: function filter(oldState, newState, meta) {
    return meta.type !== 'cursor';
  }
})(Interaction);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL1Zvcm9ub2kuanMiXSwibmFtZXMiOlsibm9vcCIsIm1vZGVDbG9zZXN0U2VyaWVzIiwibW9kZUNsb3Nlc3RQb2ludCIsIm1vZGVBeGlzIiwiSW50ZXJhY3Rpb24iLCJvbkhvdmVyIiwiYmluZCIsIm9uQ2xpY2siLCJwcm9wcyIsImludGVyYWN0aW9uIiwic3RhY2tEYXRhIiwicHJpbWFyeUF4aXMiLCJzZWNvbmRhcnlBeGlzIiwieFNjYWxlIiwidmVydGljYWwiLCJ5U2NhbGUiLCJleHRlbnQiLCJzY2FsZSIsInJhbmdlIiwibGluZUZuIiwicG9seWdvbnMiLCJ2b3Jvbm9pRGF0YSIsInJlZHVjZSIsInByZXYiLCJub3ciLCJjb25jYXQiLCJkYXRhIiwibWFwIiwieCIsImQiLCJmb2N1cyIsInkiLCJzZXJpZXMiLCJzZXJpZXNJbmRleCIsImRhdHVtcyIsInNpbmdsZSIsImZpbHRlciIsInZvciIsImFsbERhdHVtcyIsImRhdHVtc0J5QXhpcyIsImZvckVhY2giLCJrZXkiLCJTdHJpbmciLCJwcmltYXJ5IiwicHVzaCIsIk9iamVjdCIsImtleXMiLCJwb2ludHMiLCJpIiwicGF0aCIsImZpbGwiLCJzdHJva2VXaWR0aCIsInN0cm9rZSIsIm9wYWNpdHkiLCJkaXNwYXRjaCIsInN0YXRlIiwiaG92ZXJlZCIsImFjdGl2ZSIsInR5cGUiLCJzZWxlY3RlZCIsImRlZmF1bHRQcm9wcyIsIm9uQWN0aXZhdGUiLCJzZWxlY3RvcnMiLCJvbGRTdGF0ZSIsIm5ld1N0YXRlIiwibWV0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7Ozs7QUFGQTs7O0FBSUEsSUFBTUEsT0FBTyxTQUFQQSxJQUFPO0FBQUEsU0FBTSxJQUFOO0FBQUEsQ0FBYjs7QUFFQSxJQUFNQyxvQkFBb0IsZUFBMUI7QUFDQSxJQUFNQyxtQkFBbUIsY0FBekI7QUFDQSxJQUFNQyxX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VWxELGFBQVYsQ0FBd0IyQyxLQUF4QixDQUhBO0FBSWY5QyxtQkFBYThDLE1BQU05QztBQUpKLEtBQVY7QUFBQSxHQUFQO0FBTUQsQ0FaWSxFQWFiO0FBQ0UyQixVQUFRLGdCQUFDMkIsUUFBRCxFQUFXQyxRQUFYLEVBQXFCQyxJQUFyQjtBQUFBLFdBQThCQSxLQUFLUCxJQUFMLEtBQWMsUUFBNUM7QUFBQTtBQURWLENBYmEsRUFnQmJ0RCxXQWhCYSxDIiwiZmlsZSI6IlZvcm9ub2kuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ29ubmVjdCB9IGZyb20gJ3JlYWN0LXN0YXRlJ1xuaW1wb3J0IHsgdm9yb25vaSB9IGZyb20gJ2QzLXZvcm9ub2knXG5pbXBvcnQgeyBsaW5lIH0gZnJvbSAnZDMtc2hhcGUnXG4vL1xuaW1wb3J0IFBhdGggZnJvbSAnLi4vcHJpbWl0aXZlcy9QYXRoJ1xuaW1wb3J0IFNlbGVjdG9ycyBmcm9tICcuLi91dGlscy9TZWxlY3RvcnMnXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiBudWxsXG5cbmNvbnN0IG1vZGVDbG9zZXN0U2VyaWVzID0gJ2Nsb3Nlc3RTZXJpZXMnXG5jb25zdCBtb2RlQ2xvc2VzdFBvaW50ID0gJ2Nsb3Nlc3RQb2ludCdcbmNvbnN0IG1vZGVBeGlzID0gJ2F4aXMnXG5cbmNsYXNzIEludGVyYWN0aW9uIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgb25Ib3Zlcjogbm9vcCxcbiAgICBvbkFjdGl2YXRlOiBub29wLFxuICB9XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5vbkhvdmVyID0gdGhpcy5vbkhvdmVyLmJpbmQodGhpcylcbiAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKVxuICB9XG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJhY3Rpb24sXG4gICAgICAvL1xuICAgICAgc3RhY2tEYXRhLFxuICAgICAgcHJpbWFyeUF4aXMsXG4gICAgICBzZWNvbmRhcnlBeGlzLFxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICAvLyBEb24ndCByZW5kZXIgdW50aWwgd2UgaGF2ZSBhbGwgZGVwZW5kZW5jaWVzXG4gICAgaWYgKCFzdGFja0RhdGEgfHwgIXByaW1hcnlBeGlzIHx8ICFzZWNvbmRhcnlBeGlzKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHhTY2FsZSA9IHByaW1hcnlBeGlzLnZlcnRpY2FsID8gc2Vjb25kYXJ5QXhpcyA6IHByaW1hcnlBeGlzXG4gICAgY29uc3QgeVNjYWxlID0gcHJpbWFyeUF4aXMudmVydGljYWwgPyBwcmltYXJ5QXhpcyA6IHNlY29uZGFyeUF4aXNcblxuICAgIGNvbnN0IGV4dGVudCA9IFtcbiAgICAgIFt4U2NhbGUuc2NhbGUucmFuZ2UoKVswXSwgeVNjYWxlLnNjYWxlLnJhbmdlKClbMV1dLFxuICAgICAgW3hTY2FsZS5zY2FsZS5yYW5nZSgpWzFdLCB5U2NhbGUuc2NhbGUucmFuZ2UoKVswXV0sXG4gICAgXVxuICAgIGNvbnN0IGxpbmVGbiA9IGxpbmUoKVxuXG4gICAgbGV0IHBvbHlnb25zXG5cbiAgICBpZiAoaW50ZXJhY3Rpb24gPT09IG1vZGVDbG9zZXN0U2VyaWVzKSB7XG4gICAgICAvLyBDbG9zZXN0IFBvaW50IFZvcm9ub2lcbiAgICAgIGNvbnN0IHZvcm9ub2lEYXRhID0gc3RhY2tEYXRhXG4gICAgICAgIC5yZWR1Y2UoKHByZXYsIG5vdykgPT4gcHJldi5jb25jYXQobm93LmRhdGEpLCBbXSlcbiAgICAgICAgLm1hcChkID0+ICh7XG4gICAgICAgICAgeDogZC5mb2N1cy54LFxuICAgICAgICAgIHk6IGQuZm9jdXMueSxcbiAgICAgICAgICBzZXJpZXM6IHN0YWNrRGF0YVtkLnNlcmllc0luZGV4XSxcbiAgICAgICAgICBkYXR1bXM6IG51bGwsXG4gICAgICAgICAgc2luZ2xlOiBmYWxzZSxcbiAgICAgICAgfSkpXG4gICAgICAgIC5maWx0ZXIoZCA9PiB0eXBlb2YgZC54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZC55ID09PSAnbnVtYmVyJylcbiAgICAgIGNvbnN0IHZvciA9IHZvcm9ub2koKS54KGQgPT4gZC54KS55KGQgPT4gZC55KS5leHRlbnQoZXh0ZW50KSh2b3Jvbm9pRGF0YSlcbiAgICAgIHBvbHlnb25zID0gdm9yLnBvbHlnb25zKClcbiAgICB9IGVsc2UgaWYgKGludGVyYWN0aW9uID09PSBtb2RlQ2xvc2VzdFBvaW50KSB7XG4gICAgICAvLyBDbG9zZXN0IFBvaW50IFZvcm9ub2lcbiAgICAgIGNvbnN0IHZvcm9ub2lEYXRhID0gc3RhY2tEYXRhXG4gICAgICAgIC5yZWR1Y2UoKHByZXYsIG5vdykgPT4gcHJldi5jb25jYXQobm93LmRhdGEpLCBbXSlcbiAgICAgICAgLm1hcChkID0+ICh7XG4gICAgICAgICAgeDogZC5mb2N1cy54LFxuICAgICAgICAgIHk6IGQuZm9jdXMueSxcbiAgICAgICAgICBzZXJpZXM6IG51bGwsXG4gICAgICAgICAgZGF0dW1zOiBbZF0sXG4gICAgICAgICAgc2luZ2xlOiB0cnVlLFxuICAgICAgICB9KSlcbiAgICAgICAgLmZpbHRlcihkID0+IHR5cGVvZiBkLnggPT09ICdudW1iZXInICYmIHR5cGVvZiBkLnkgPT09ICdudW1iZXInKVxuICAgICAgY29uc3Qgdm9yID0gdm9yb25vaSgpLngoZCA9PiBkLngpLnkoZCA9PiBkLnkpLmV4dGVudChleHRlbnQpKHZvcm9ub2lEYXRhKVxuICAgICAgcG9seWdvbnMgPSB2b3IucG9seWdvbnMoKVxuICAgIH0gZWxzZSBpZiAoaW50ZXJhY3Rpb24gPT09IG1vZGVBeGlzKSB7XG4gICAgICAvLyBBeGlzIFZvcm9ub2lcbiAgICAgIC8vIEdyb3VwIGFsbCBkYXRhIHBvaW50cyBiYXNlZCBvbiBwcmltYXJ5QXhpc1xuICAgICAgY29uc3QgYWxsRGF0dW1zID0gc3RhY2tEYXRhLnJlZHVjZShcbiAgICAgICAgKHByZXYsIG5vdykgPT4gcHJldi5jb25jYXQobm93LmRhdGEpLFxuICAgICAgICBbXVxuICAgICAgKVxuICAgICAgY29uc3QgZGF0dW1zQnlBeGlzID0ge31cbiAgICAgIGFsbERhdHVtcy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBTdHJpbmcoZC5wcmltYXJ5KVxuICAgICAgICBkYXR1bXNCeUF4aXNba2V5XSA9IGRhdHVtc0J5QXhpc1trZXldIHx8IHtcbiAgICAgICAgICB4OiBkLmZvY3VzLngsXG4gICAgICAgICAgeTogZC5mb2N1cy55LFxuICAgICAgICAgIHNlcmllczogbnVsbCwgLy8gQXhpc0F4aXMgY2FuJ3QgYmUgdGhlIHNlcmllcywgc28gZG9uJ3Qgc2VuZCBpdFxuICAgICAgICAgIGRhdHVtczogW10sXG4gICAgICAgICAgc2luZ2xlOiBmYWxzZSxcbiAgICAgICAgfVxuICAgICAgICBkYXR1bXNCeUF4aXNba2V5XS5kYXR1bXMucHVzaChkKVxuICAgICAgfSlcbiAgICAgIGNvbnN0IHZvcm9ub2lEYXRhID0gT2JqZWN0LmtleXMoZGF0dW1zQnlBeGlzKS5tYXAoZCA9PiBkYXR1bXNCeUF4aXNbZF0pXG4gICAgICBjb25zdCB2b3IgPSB2b3Jvbm9pKClcbiAgICAgICAgLngoZCA9PiAocHJpbWFyeUF4aXMudmVydGljYWwgPyAwIDogZC54KSlcbiAgICAgICAgLnkoZCA9PiAocHJpbWFyeUF4aXMudmVydGljYWwgPyBkLnkgOiAwKSlcbiAgICAgICAgLmV4dGVudChleHRlbnQpKHZvcm9ub2lEYXRhKVxuICAgICAgcG9seWdvbnMgPSB2b3IucG9seWdvbnMoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIFNlcmllcyBhbmQgRWxlbWVudCBpbnRlcmFjdGlvbnMgbW9kZXMgYXJlIGhhbmRsZWQgYnkgdGhlXG4gICAgLy8gZWxlbWVudHMgdGhlbXNlbHZlcywgc28gZG8gbm90aGluZyBmb3IgdGhlbSBoZXJlLlxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxnIGNsYXNzTmFtZT0nSW50ZXJhY3Rpb24nIG9uTW91c2VMZWF2ZT17KCkgPT4gdGhpcy5vbkhvdmVyKG51bGwsIG51bGwpfT5cbiAgICAgICAgeyEhcG9seWdvbnMgJiZcbiAgICAgICAgICBwb2x5Z29ucy5tYXAoKHBvaW50cywgaSkgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBkcmF3IHRoZSB2b3Jvbm9pIGlmIHdlIG5lZWQgaXRcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBsaW5lRm4ocG9pbnRzKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPFBhdGhcbiAgICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgICAgZD17cGF0aH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9J2FjdGlvbi12b3Jvbm9pJ1xuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17ZSA9PlxuICAgICAgICAgICAgICAgICAgdGhpcy5vbkhvdmVyKHBvaW50cy5kYXRhLnNlcmllcywgcG9pbnRzLmRhdGEuZGF0dW1zKX1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtlID0+XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xpY2socG9pbnRzLmRhdGEuc2VyaWVzLCBwb2ludHMuZGF0YS5kYXR1bXMpfVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBmaWxsOiAncmdiYSgwLDAsMCwuMiknLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDUsXG4gICAgICAgICAgICAgICAgICBzdHJva2U6ICdyZ2JhKDI1NSwyNTUsMjU1LC41KScsXG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApXG4gICAgICAgICAgfSl9XG4gICAgICA8L2c+XG4gICAgKVxuICB9XG4gIG9uSG92ZXIgKHNlcmllcywgZGF0dW1zKSB7XG4gICAgLy8gYWN0aXZhdGUgdGhlIGhvdmVyIHdpdGggYW55IHNlcmllcyBvciBkYXR1bXNcbiAgICBpZiAoc2VyaWVzIHx8IGRhdHVtcykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZGlzcGF0Y2goXG4gICAgICAgIHN0YXRlID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBob3ZlcmVkOiB7XG4gICAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgc2VyaWVzLFxuICAgICAgICAgICAgICBkYXR1bXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdob3ZlcmVkVm9yb25vaScsXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gICAgLy8gSWYgd2UganVzdCBsZWZ0IHRoZSBhcmVhLCBkZWFjdGl2ZSB0aGUgaG92ZXJcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5kaXNwYXRjaChcbiAgICAgIHN0YXRlID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBob3ZlcmVkOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ob3ZlcmVkLFxuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAnaG92ZXJlZFZvcm9ub2knLFxuICAgICAgfVxuICAgIClcbiAgfVxuICBvbkNsaWNrIChzZXJpZXMsIGRhdHVtcykge1xuICAgIGlmIChzZXJpZXMgfHwgZGF0dW1zKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5kaXNwYXRjaChcbiAgICAgICAgc3RhdGUgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgc2VyaWVzLFxuICAgICAgICAgICAgICBkYXR1bXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdzZWxlY3RlZFZvcm9ub2knLFxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbm5lY3QoXG4gICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvcnMgPSB7XG4gICAgICBwcmltYXJ5QXhpczogU2VsZWN0b3JzLnByaW1hcnlBeGlzKCksXG4gICAgICBzZWNvbmRhcnlBeGlzOiBTZWxlY3RvcnMuc2Vjb25kYXJ5QXhpcygpLFxuICAgIH1cbiAgICByZXR1cm4gc3RhdGUgPT4gKHtcbiAgICAgIHN0YWNrRGF0YTogc3RhdGUuc3RhY2tEYXRhLFxuICAgICAgcHJpbWFyeUF4aXM6IHNlbGVjdG9ycy5wcmltYXJ5QXhpcyhzdGF0ZSksXG4gICAgICBzZWNvbmRhcnlBeGlzOiBzZWxlY3RvcnMuc2Vjb25kYXJ5QXhpcyhzdGF0ZSksXG4gICAgICBpbnRlcmFjdGlvbjogc3RhdGUuaW50ZXJhY3Rpb24sXG4gICAgfSlcbiAgfSxcbiAge1xuICAgIGZpbHRlcjogKG9sZFN0YXRlLCBuZXdTdGF0ZSwgbWV0YSkgPT4gbWV0YS50eXBlICE9PSAnY3Vyc29yJyxcbiAgfVxuKShJbnRlcmFjdGlvbilcbiJdfQ==