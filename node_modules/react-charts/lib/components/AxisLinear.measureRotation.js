'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = measure;

var _AxisLinear = require('./AxisLinear');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var fontSize = 10;

var getPixel = function getPixel(d) {
  return d;
};
var radiansToDegrees = function radiansToDegrees(r) {
  return r * (180 / Math.PI);
};

function measure() {
  // Measure finds the amount of overflow this axis produces and
  // updates the margins to ensure that the axis is visibility
  // Unfortunately, this currently happens after a render, but potentially
  // could happen pre-render if we could reliably predict the size of the
  // labels before they render. Considering that ticks could be anything,
  // even a react component, this could get very tough.
  var _props = this.props,
      axis = _props.axis,
      tickSizeInner = _props.tickSizeInner,
      tickSizeOuter = _props.tickSizeOuter,
      tickPadding = _props.tickPadding,
      maxLabelRotation = _props.maxLabelRotation,
      position = _props.position,
      dispatch = _props.dispatch;
  var visibleLabelStep = this.visibleLabelStep;


  if (!this.el) {
    return;
  }

  var isHorizontal = position === _AxisLinear.positionTop || position === _AxisLinear.positionBottom;
  var labelDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick.-measureable text'))).map(function (el) {
    return el.getBoundingClientRect();
  });

  var smallestTickGap = 10000; // This is just a ridiculously large tick spacing that would never happen (hopefully)
  // If the axis is horizontal, we need to determine any necessary rotation and tick skipping
  if (isHorizontal) {
    var tickDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick.-measureable'))).map(function (el) {
      return el.getBoundingClientRect();
    });
    tickDims.reduce(function (prev, current) {
      if (prev) {
        var gap = current.left - prev.left;
        smallestTickGap = gap < smallestTickGap ? gap : smallestTickGap;
      }
      return current;
    }, false);
    var largestLabel = labelDims.reduce(function (prev, current) {
      current._overflow = current.width - smallestTickGap - fontSize / 2;
      if (current._overflow > 0 && current._overflow > prev._overflow) {
        return current;
      }
      return prev;
    }, { _overflow: 0 });

    // Determine axis rotation before we measure
    console.log(largestLabel.width, smallestTickGap);
    if (largestLabel.width <= smallestTickGap || Math.abs(largestLabel.width - smallestTickGap) > 5) {
      var newRotation = Math.min(Math.max(Math.abs(radiansToDegrees(Math.acos(smallestTickGap / largestLabel.width))), 0), maxLabelRotation);
      newRotation = isNaN(newRotation) ? 0 : Math.round(newRotation);

      if (this.state.rotation !== newRotation) {
        this.setState({
          rotation: axis.position === 'top' ? -newRotation : newRotation
        });
      }
    }
  }

  var newVisibleLabelStep = Math.ceil(fontSize / smallestTickGap);

  if (visibleLabelStep !== newVisibleLabelStep) {
    this.visibleLabelStep = newVisibleLabelStep;
  }

  if (!labelDims.length || labelDims.length !== this.ticks.length) {
    return false;
  }

  var width = 0;
  var height = 0;
  var top = 0;
  var bottom = 0;
  var left = 0;
  var right = 0;

  if (isHorizontal) {
    // Add width overflow from the first and last ticks
    left = Math.ceil(getPixel(labelDims[0].width) / 2);
    right = Math.ceil(getPixel(labelDims[labelDims.length - 1].width) / 2);
    height = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.height));
    }))); // Add the height of the largest label
  } else {
    // Add height overflow from the first and last ticks
    top = Math.ceil(getPixel(labelDims[0].height) / 2);
    bottom = Math.ceil(getPixel(labelDims[labelDims.length - 1].height) / 2);
    width = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.width));
    }))); // Add the width of the largest label
  }

  dispatch(function (state) {
    return _extends({}, state, {
      axisDimensions: _extends({}, state.axisDimensions, _defineProperty({}, position, {
        width: width,
        height: height,
        top: top,
        bottom: bottom,
        left: left,
        right: right
      }))
    });
  }, {
    type: 'axisDimensions'
  });

  return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0F4aXNMaW5lYXIubWVhc3VyZVJvdGF0aW9uLmpzIl0sIm5hbWVzIjpbIm1lYXN1cmUiLCJmb250U2l6ZSIsImdldFBpeGVsIiwiZCIsInJhZGlhbnNUb0RlZ3JlZXMiLCJyIiwiTWF0aCIsIlBJIiwicHJvcHMiLCJheGlzIiwidGlja1NpemVJbm5lciIsInRpY2tTaXplT3V0ZXIiLCJ0aWNrUGFkZGluZyIsIm1heExhYmVsUm90YXRpb24iLCJwb3NpdGlvbiIsImRpc3BhdGNoIiwidmlzaWJsZUxhYmVsU3RlcCIsImVsIiwiaXNIb3Jpem9udGFsIiwibGFiZWxEaW1zIiwiQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwibWFwIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic21hbGxlc3RUaWNrR2FwIiwidGlja0RpbXMiLCJyZWR1Y2UiLCJwcmV2IiwiY3VycmVudCIsImdhcCIsImxlZnQiLCJsYXJnZXN0TGFiZWwiLCJfb3ZlcmZsb3ciLCJ3aWR0aCIsImNvbnNvbGUiLCJsb2ciLCJhYnMiLCJuZXdSb3RhdGlvbiIsIm1pbiIsIm1heCIsImFjb3MiLCJpc05hTiIsInJvdW5kIiwic3RhdGUiLCJyb3RhdGlvbiIsInNldFN0YXRlIiwibmV3VmlzaWJsZUxhYmVsU3RlcCIsImNlaWwiLCJsZW5ndGgiLCJ0aWNrcyIsImhlaWdodCIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwiYXhpc0RpbWVuc2lvbnMiLCJ0eXBlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztrQkFPd0JBLE87O0FBUHhCOzs7Ozs7QUFFQSxJQUFNQyxXQUFXLEVBQWpCOztBQUVBLElBQU1DLFdBQVcsU0FBWEEsUUFBVztBQUFBLFNBQUtDLENBQUw7QUFBQSxDQUFqQjtBQUNBLElBQU1DLG1CQUFtQixTQUFuQkEsZ0JBQW1CO0FBQUEsU0FBS0MsS0FBSyxNQUFNQyxLQUFLQyxFQUFoQixDQUFMO0FBQUEsQ0FBekI7O0FBRWUsU0FBU1AsT0FBVCxHQUFvQjtB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QyxTQUFTaUIsVUFBVUEsVUFBVTZCLE1BQVYsR0FBbUIsQ0FBN0IsRUFBZ0NFLE1BQXpDLElBQW1ELENBQTdELENBQVQ7QUFDQWpCLFlBQ0UzQixLQUFLaUMsR0FBTCxDQUFTN0IsYUFBVCxFQUF3QkMsYUFBeEIsSUFBeUM7QUFDekNDLGVBREEsR0FDYztBQUNkTixTQUFLaUMsR0FBTCxnQ0FBWXBCLFVBQVVHLEdBQVYsQ0FBYztBQUFBLGFBQUtoQixLQUFLeUMsSUFBTCxDQUFVN0MsU0FBU0MsRUFBRThCLEtBQVgsQ0FBVixDQUFMO0FBQUEsS0FBZCxDQUFaLEVBSEYsQ0FKSyxDQU8yRDtBQUNqRTs7QUFFRGxCLFdBQ0U7QUFBQSx3QkFDSzRCLEtBREw7QUFFRVcsbUNBQ0tYLE1BQU1XLGNBRFgsc0JBRUd4QyxRQUZILEVBRWM7QUFDVm1CLG9CQURVO0FBRVZpQixzQkFGVTtBQUdWQyxnQkFIVTtBQUlWQyxzQkFKVTtBQUtWdEIsa0JBTFU7QUFNVnVCO0FBTlUsT0FGZDtBQUZGO0FBQUEsR0FERixFQWVFO0FBQ0VFLFVBQU07QUFEUixHQWZGOztBQW9CQSxTQUFPLElBQVA7QUFDRCIsImZpbGUiOiJBeGlzTGluZWFyLm1lYXN1cmVSb3RhdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBvc2l0aW9uVG9wLCBwb3NpdGlvbkJvdHRvbSB9IGZyb20gJy4vQXhpc0xpbmVhcidcblxuY29uc3QgZm9udFNpemUgPSAxMFxuXG5jb25zdCBnZXRQaXhlbCA9IGQgPT4gZFxuY29uc3QgcmFkaWFuc1RvRGVncmVlcyA9IHIgPT4gciAqICgxODAgLyBNYXRoLlBJKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZWFzdXJlICgpIHtcbiAgLy8gTWVhc3VyZSBmaW5kcyB0aGUgYW1vdW50IG9mIG92ZXJmbG93IHRoaXMgYXhpcyBwcm9kdWNlcyBhbmRcbiAgLy8gdXBkYXRlcyB0aGUgbWFyZ2lucyB0byBlbnN1cmUgdGhhdCB0aGUgYXhpcyBpcyB2aXNpYmlsaXR5XG4gIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgY3VycmVudGx5IGhhcHBlbnMgYWZ0ZXIgYSByZW5kZXIsIGJ1dCBwb3RlbnRpYWxseVxuICAvLyBjb3VsZCBoYXBwZW4gcHJlLXJlbmRlciBpZiB3ZSBjb3VsZCByZWxpYWJseSBwcmVkaWN0IHRoZSBzaXplIG9mIHRoZVxuICAvLyBsYWJlbHMgYmVmb3JlIHRoZXkgcmVuZGVyLiBDb25zaWRlcmluZyB0aGF0IHRpY2tzIGNvdWxkIGJlIGFueXRoaW5nLFxuICAvLyBldmVuIGEgcmVhY3QgY29tcG9uZW50LCB0aGlzIGNvdWxkIGdldCB2ZXJ5IHRvdWdoLlxuICBjb25zdCB7XG4gICAgYXhpcyxcbiAgICB0aWNrU2l6ZUlubmVyLFxuICAgIHRpY2tTaXplT3V0ZXIsXG4gICAgdGlja1BhZGRpbmcsXG4gICAgbWF4TGFiZWxSb3RhdGlvbixcbiAgICBwb3NpdGlvbixcbiAgICBkaXNwYXRjaCxcbiAgfSA9IHRoaXMucHJvcHNcblxuICBjb25zdCB7IHZpc2libGVMYWJlbFN0ZXAgfSA9IHRoaXNcblxuICBpZiAoIXRoaXMuZWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHBvc2l0aW9uID09PSBwb3NpdGlvblRvcCB8fCBwb3NpdGlvbiA9PT0gcG9zaXRpb25Cb3R0b21cbiAgY29uc3QgbGFiZWxEaW1zID0gQXJyYXkoXG4gICAgLi4udGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCcudGljay4tbWVhc3VyZWFibGUgdGV4dCcpXG4gICkubWFwKGVsID0+IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKVxuXG4gIGxldCBzbWFsbGVzdFRpY2tHYXAgPSAxMDAwMCAvLyBUaGlzIGlzIGp1c3QgYSByaWRpY3Vsb3VzbHkgbGFyZ2UgdGljayBzcGFjaW5nIHRoYXQgd291bGQgbmV2ZXIgaGFwcGVuIChob3BlZnVsbHkpXG4gIC8vIElmIHRoZSBheGlzIGlzIGhvcml6b250YWwsIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGFueSBuZWNlc3Nhcnkgcm90YXRpb24gYW5kIHRpY2sgc2tpcHBpbmdcbiAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgIGNvbnN0IHRpY2tEaW1zID0gQXJyYXkoXG4gICAgICAuLi50aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aWNrLi1tZWFzdXJlYWJsZScpXG4gICAgKS5tYXAoZWwgPT4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpXG4gICAgdGlja0RpbXMucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBjb25zdCBnYXAgPSBjdXJyZW50LmxlZnQgLSBwcmV2LmxlZnRcbiAgICAgICAgc21hbGxlc3RUaWNrR2FwID0gZ2FwIDwgc21hbGxlc3RUaWNrR2FwID8gZ2FwIDogc21hbGxlc3RUaWNrR2FwXG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudFxuICAgIH0sIGZhbHNlKVxuICAgIGNvbnN0IGxhcmdlc3RMYWJlbCA9IGxhYmVsRGltcy5yZWR1Y2UoXG4gICAgICAocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICBjdXJyZW50Ll9vdmVyZmxvdyA9IGN1cnJlbnQud2lkdGggLSBzbWFsbGVzdFRpY2tHYXAgLSBmb250U2l6ZSAvIDJcbiAgICAgICAgaWYgKGN1cnJlbnQuX292ZXJmbG93ID4gMCAmJiBjdXJyZW50Ll9vdmVyZmxvdyA+IHByZXYuX292ZXJmbG93KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldlxuICAgICAgfSxcbiAgICAgIHsgX292ZXJmbG93OiAwIH1cbiAgICApXG5cbiAgICAvLyBEZXRlcm1pbmUgYXhpcyByb3RhdGlvbiBiZWZvcmUgd2UgbWVhc3VyZVxuICAgIGNvbnNvbGUubG9nKGxhcmdlc3RMYWJlbC53aWR0aCwgc21hbGxlc3RUaWNrR2FwKVxuICAgIGlmIChcbiAgICAgIGxhcmdlc3RMYWJlbC53aWR0aCA8PSBzbWFsbGVzdFRpY2tHYXAgfHxcbiAgICAgIE1hdGguYWJzKGxhcmdlc3RMYWJlbC53aWR0aCAtIHNtYWxsZXN0VGlja0dhcCkgPiA1XG4gICAgKSB7XG4gICAgICBsZXQgbmV3Um90YXRpb24gPSBNYXRoLm1pbihcbiAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgTWF0aC5hYnMoXG4gICAgICAgICAgICByYWRpYW5zVG9EZWdyZWVzKE1hdGguYWNvcyhzbWFsbGVzdFRpY2tHYXAgLyBsYXJnZXN0TGFiZWwud2lkdGgpKVxuICAgICAgICAgICksXG4gICAgICAgICAgMFxuICAgICAgICApLFxuICAgICAgICBtYXhMYWJlbFJvdGF0aW9uXG4gICAgICApXG4gICAgICBuZXdSb3RhdGlvbiA9IGlzTmFOKG5ld1JvdGF0aW9uKSA/IDAgOiBNYXRoLnJvdW5kKG5ld1JvdGF0aW9uKVxuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5yb3RhdGlvbiAhPT0gbmV3Um90YXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgcm90YXRpb246IGF4aXMucG9zaXRpb24gPT09ICd0b3AnID8gLW5ld1JvdGF0aW9uIDogbmV3Um90YXRpb24sXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmV3VmlzaWJsZUxhYmVsU3RlcCA9IE1hdGguY2VpbChmb250U2l6ZSAvIHNtYWxsZXN0VGlja0dhcClcblxuICBpZiAodmlzaWJsZUxhYmVsU3RlcCAhPT0gbmV3VmlzaWJsZUxhYmVsU3RlcCkge1xuICAgIHRoaXMudmlzaWJsZUxhYmVsU3RlcCA9IG5ld1Zpc2libGVMYWJlbFN0ZXBcbiAgfVxuXG4gIGlmICghbGFiZWxEaW1zLmxlbmd0aCB8fCBsYWJlbERpbXMubGVuZ3RoICE9PSB0aGlzLnRpY2tzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgbGV0IHdpZHRoID0gMFxuICBsZXQgaGVpZ2h0ID0gMFxuICBsZXQgdG9wID0gMFxuICBsZXQgYm90dG9tID0gMFxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuXG4gIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAvLyBBZGQgd2lkdGggb3ZlcmZsb3cgZnJvbSB0aGUgZmlyc3QgYW5kIGxhc3QgdGlja3NcbiAgICBsZWZ0ID0gTWF0aC5jZWlsKGdldFBpeGVsKGxhYmVsRGltc1swXS53aWR0aCkgLyAyKVxuICAgIHJpZ2h0ID0gTWF0aC5jZWlsKGdldFBpeGVsKGxhYmVsRGltc1tsYWJlbERpbXMubGVuZ3RoIC0gMV0ud2lkdGgpIC8gMilcbiAgICBoZWlnaHQgPVxuICAgICAgTWF0aC5tYXgodGlja1NpemVJbm5lciwgdGlja1NpemVPdXRlcikgKyAvLyBBZGQgdGljayBzaXplXG4gICAgICB0aWNrUGFkZGluZyArIC8vIEFkZCB0aWNrIHBhZGRpbmdcbiAgICAgIE1hdGgubWF4KC4uLmxhYmVsRGltcy5tYXAoZCA9PiBNYXRoLmNlaWwoZ2V0UGl4ZWwoZC5oZWlnaHQpKSkpIC8vIEFkZCB0aGUgaGVpZ2h0IG9mIHRoZSBsYXJnZXN0IGxhYmVsXG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkIGhlaWdodCBvdmVyZmxvdyBmcm9tIHRoZSBmaXJzdCBhbmQgbGFzdCB0aWNrc1xuICAgIHRvcCA9IE1hdGguY2VpbChnZXRQaXhlbChsYWJlbERpbXNbMF0uaGVpZ2h0KSAvIDIpXG4gICAgYm90dG9tID0gTWF0aC5jZWlsKGdldFBpeGVsKGxhYmVsRGltc1tsYWJlbERpbXMubGVuZ3RoIC0gMV0uaGVpZ2h0KSAvIDIpXG4gICAgd2lkdGggPVxuICAgICAgTWF0aC5tYXgodGlja1NpemVJbm5lciwgdGlja1NpemVPdXRlcikgKyAvLyBBZGQgdGljayBzaXplXG4gICAgICB0aWNrUGFkZGluZyArIC8vIEFkZCB0aWNrIHBhZGRpbmdcbiAgICAgIE1hdGgubWF4KC4uLmxhYmVsRGltcy5tYXAoZCA9PiBNYXRoLmNlaWwoZ2V0UGl4ZWwoZC53aWR0aCkpKSkgLy8gQWRkIHRoZSB3aWR0aCBvZiB0aGUgbGFyZ2VzdCBsYWJlbFxuICB9XG5cbiAgZGlzcGF0Y2goXG4gICAgc3RhdGUgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgYXhpc0RpbWVuc2lvbnM6IHtcbiAgICAgICAgLi4uc3RhdGUuYXhpc0RpbWVuc2lvbnMsXG4gICAgICAgIFtwb3NpdGlvbl06IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHJpZ2h0LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KSxcbiAgICB7XG4gICAgICB0eXBlOiAnYXhpc0RpbWVuc2lvbnMnLFxuICAgIH1cbiAgKVxuXG4gIHJldHVybiB0cnVlXG59XG4iXX0=