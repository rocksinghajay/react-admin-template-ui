'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = measure;

var _AxisLinear = require('./AxisLinear');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var fontSize = 10;

var getPixel = function getPixel(d) {
  return d;
};
var radiansToDegrees = function radiansToDegrees(r) {
  return r * (180 / Math.PI);
};

function measure(isRotation) {
  // Measure finds the amount of overflow this axis produces and
  // updates the margins to ensure that the axis is visibility
  // Unfortunately, this currently happens after a render, but potentially
  // could happen pre-render if we could reliably predict the size of the
  // labels before they render. Considering that ticks could be anything,
  // even a react component, this could get very tough.
  var _props = this.props,
      axis = _props.axis,
      tickSizeInner = _props.tickSizeInner,
      tickSizeOuter = _props.tickSizeOuter,
      tickPadding = _props.tickPadding,
      maxLabelRotation = _props.maxLabelRotation,
      position = _props.position,
      dispatch = _props.dispatch;
  var rotation = this.state.rotation;
  var visibleLabelStep = this.visibleLabelStep;


  if (!this.el) {
    return;
  }

  var isHorizontal = position === _AxisLinear.positionTop || position === _AxisLinear.positionBottom;
  var labelDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick.-measureable text'))).map(function (el) {
    var bbox = el.getBoundingClientRect();
    var obj = {};
    for (var key in bbox) {
      obj[key] = bbox[key];
    }
    return obj;
  });

  var smallestTickGap = 10000; // This is just a ridiculously large tick spacing that would never happen (hopefully)
  // If the axis is horizontal, we need to determine any necessary rotation and tick skipping
  if (isHorizontal) {
    var tickDims = Array.apply(undefined, _toConsumableArray(this.el.querySelectorAll('.tick.-measureable'))).map(function (el) {
      return el.getBoundingClientRect();
    });
    tickDims.reduce(function (prev, current) {
      if (prev) {
        var gap = current.left - prev.left;
        smallestTickGap = gap < smallestTickGap ? gap : smallestTickGap;
      }
      return current;
    }, false);
    var largestLabel = labelDims.reduce(function (prev, current) {
      current._overflow = current.width - smallestTickGap;
      if (current._overflow > 0 && current._overflow > prev._overflow) {
        return current;
      }
      return prev;
    }, _extends({}, labelDims[0], { _overflow: 0 }));

    // Determine axis rotation before we measure
    if (isRotation) {
      var newRotation = Math.min(Math.max(Math.abs(radiansToDegrees(Math.acos((smallestTickGap + fontSize / 2) / largestLabel.width))), 0), maxLabelRotation);

      newRotation = isNaN(newRotation) ? 0 : Math.round(newRotation);
      if (Math.abs(rotation - newRotation) > 20) {
        this.setState({
          rotation: axis.position === 'top' ? -newRotation : newRotation
        });
      }
      return;
    }
  }

  var newVisibleLabelStep = Math.ceil(fontSize / smallestTickGap);

  if (visibleLabelStep !== newVisibleLabelStep) {
    this.visibleLabelStep = newVisibleLabelStep;
  }

  if (!labelDims.length || labelDims.length !== this.ticks.length) {
    return false;
  }

  var width = 0;
  var height = 0;
  var top = 0;
  var bottom = 0;
  var left = 0;
  var right = 0;

  if (isHorizontal) {
    // Add width overflow from the first and last ticks
    left = Math.ceil(getPixel(labelDims[0].width) / 2);
    right = Math.ceil(getPixel(labelDims[labelDims.length - 1].width) / 2);
    height = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.height));
    }))); // Add the height of the largest label
  } else {
    // Add height overflow from the first and last ticks
    top = Math.ceil(getPixel(labelDims[0].height) / 2);
    bottom = Math.ceil(getPixel(labelDims[labelDims.length - 1].height) / 2);
    width = Math.max(tickSizeInner, tickSizeOuter) + // Add tick size
    tickPadding + // Add tick padding
    Math.max.apply(Math, _toConsumableArray(labelDims.map(function (d) {
      return Math.ceil(getPixel(d.width));
    }))); // Add the width of the largest label
  }

  dispatch(function (state) {
    return _extends({}, state, {
      axisDimensions: _extends({}, state.axisDimensions, _defineProperty({}, position, {
        width: width,
        height: height,
        top: top,
        bottom: bottom,
        left: left,
        right: right
      }))
    });
  }, {
    type: 'axisDimensions'
  });

  return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL0F4aXNMaW5lYXIubWVhc3VyZS5qcyJdLCJuYW1lcyI6WyJtZWFzdXJlIiwiZm9udFNpemUiLCJnZXRQaXhlbCIsImQiLCJyYWRpYW5zVG9EZWdyZWVzIiwiciIsIk1hdGgiLCJQSSIsImlzUm90YXRpb24iLCJwcm9wcyIsImF4aXMiLCJ0aWNrU2l6ZUlubmVyIiwidGlja1NpemVPdXRlciIsInRpY2tQYWRkaW5nIiwibWF4TGFiZWxSb3RhdGlvbiIsInBvc2l0aW9uIiwiZGlzcGF0Y2giLCJyb3RhdGlvbiIsInN0YXRlIiwidmlzaWJsZUxhYmVsU3RlcCIsImVsIiwiaXNIb3Jpem9udGFsIiwibGFiZWxEaW1zIiwiQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwibWFwIiwiYmJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm9iaiIsImtleSIsInNtYWxsZXN0VGlja0dhcCIsInRpY2tEaW1zIiwicmVkdWNlIiwicHJldiIsImN1cnJlbnQiLCJnYXAiLCJsZWZ0IiwibGFyZ2VzdExhYmVsIiwiX292ZXJmbG93Iiwid2lkdGgiLCJuZXdSb3RhdGlvbiIsIm1pbiIsIm1heCIsImFicyIsImFjb3MiLCJpc05hTiIsInJvdW5kIiwic2V0U3RhdGUiLCJuZXdWaXNpYmxlTGFiZWxTdGVwIiwiY2VpbCIsImxlbmd0aCIsInRpY2tzIiwiaGVpZ2h0IiwidG9wIiwiYm90dG9tIiwicmlnaHQiLCJheGlzRGltZW5zaW9ucyIsInR5cGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O2tCQU93QkEsTzs7QUFQeEI7Ozs7OztBQUVBLElBQU1DLFdBQVcsRUFBakI7O0FBRUEsSUFBTUMsV0FBVyxTQUFYQSxRQUFXO0FBQUEsU0FBS0MsQ0FBTDtBQUFBLENBQWpCO0FBQ0EsSUFBTUMsbUJBQW1CLFNBQW5CQSxnQkFBbUI7QUFBQSxTQUFLQyxLQUFLLE1BQU1DLEtBQUtDLEVBQWhCLENBQUw7QUFBQSxDQUF6Qjs7QUFFZSxTQUFTUCxPQUFU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Q0w7QUFDQUMsVUFBTS9DLEtBQUsyQyxJQUFMLENBQVUvQyxTQUFTb0IsVUFBVSxDQUFWLEVBQWE4QixNQUF0QixJQUFnQyxDQUExQyxDQUFOO0FBQ0FFLGFBQVNoRCxLQUFLMkMsSUFBTCxDQUFVL0MsU0FBU29CLFVBQVVBLFVBQVU0QixNQUFWLEdBQW1CLENBQTdCLEVBQWdDRSxNQUF6QyxJQUFtRCxDQUE3RCxDQUFUO0FBQ0FiLFlBQ0VqQyxLQUFLb0MsR0FBTCxDQUFTL0IsYUFBVCxFQUF3QkMsYUFBeEIsSUFBeUM7QUFDekNDLGVBREEsR0FDYztBQUNkUCxTQUFLb0MsR0FBTCxnQ0FBWXBCLFVBQVVHLEdBQVYsQ0FBYztBQUFBLGFBQUtuQixLQUFLMkMsSUFBTCxDQUFVL0MsU0FBU0MsRUFBRW9DLEtBQVgsQ0FBVixDQUFMO0FBQUEsS0FBZCxDQUFaLEVBSEYsQ0FKSyxDQU8yRDtBQUNqRTs7QUFFRHZCLFdBQ0U7QUFBQSx3QkFDS0UsS0FETDtBQUVFc0MsbUNBQ0t0QyxNQUFNc0MsY0FEWCxzQkFFR3pDLFFBRkgsRUFFYztBQUNWd0Isb0JBRFU7QUFFVmEsc0JBRlU7QUFHVkMsZ0JBSFU7QUFJVkMsc0JBSlU7QUFLVmxCLGtCQUxVO0FBTVZtQjtBQU5VLE9BRmQ7QUFGRjtBQUFBLEdBREYsRUFlRTtBQUNFRSxVQUFNO0FBRFIsR0FmRjs7QUFvQkEsU0FBTyxJQUFQO0FBQ0QiLCJmaWxlIjoiQXhpc0xpbmVhci5tZWFzdXJlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9zaXRpb25Ub3AsIHBvc2l0aW9uQm90dG9tIH0gZnJvbSAnLi9BeGlzTGluZWFyJ1xuXG5jb25zdCBmb250U2l6ZSA9IDEwXG5cbmNvbnN0IGdldFBpeGVsID0gZCA9PiBkXG5jb25zdCByYWRpYW5zVG9EZWdyZWVzID0gciA9PiByICogKDE4MCAvIE1hdGguUEkpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lYXN1cmUgKGlzUm90YXRpb24pIHtcbiAgLy8gTWVhc3VyZSBmaW5kcyB0aGUgYW1vdW50IG9mIG92ZXJmbG93IHRoaXMgYXhpcyBwcm9kdWNlcyBhbmRcbiAgLy8gdXBkYXRlcyB0aGUgbWFyZ2lucyB0byBlbnN1cmUgdGhhdCB0aGUgYXhpcyBpcyB2aXNpYmlsaXR5XG4gIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgY3VycmVudGx5IGhhcHBlbnMgYWZ0ZXIgYSByZW5kZXIsIGJ1dCBwb3RlbnRpYWxseVxuICAvLyBjb3VsZCBoYXBwZW4gcHJlLXJlbmRlciBpZiB3ZSBjb3VsZCByZWxpYWJseSBwcmVkaWN0IHRoZSBzaXplIG9mIHRoZVxuICAvLyBsYWJlbHMgYmVmb3JlIHRoZXkgcmVuZGVyLiBDb25zaWRlcmluZyB0aGF0IHRpY2tzIGNvdWxkIGJlIGFueXRoaW5nLFxuICAvLyBldmVuIGEgcmVhY3QgY29tcG9uZW50LCB0aGlzIGNvdWxkIGdldCB2ZXJ5IHRvdWdoLlxuICBjb25zdCB7XG4gICAgYXhpcyxcbiAgICB0aWNrU2l6ZUlubmVyLFxuICAgIHRpY2tTaXplT3V0ZXIsXG4gICAgdGlja1BhZGRpbmcsXG4gICAgbWF4TGFiZWxSb3RhdGlvbixcbiAgICBwb3NpdGlvbixcbiAgICBkaXNwYXRjaCxcbiAgfSA9IHRoaXMucHJvcHNcblxuICBjb25zdCB7IHJvdGF0aW9uIH0gPSB0aGlzLnN0YXRlXG5cbiAgY29uc3QgeyB2aXNpYmxlTGFiZWxTdGVwIH0gPSB0aGlzXG5cbiAgaWYgKCF0aGlzLmVsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBpc0hvcml6b250YWwgPSBwb3NpdGlvbiA9PT0gcG9zaXRpb25Ub3AgfHwgcG9zaXRpb24gPT09IHBvc2l0aW9uQm90dG9tXG4gIGNvbnN0IGxhYmVsRGltcyA9IEFycmF5KFxuICAgIC4uLnRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnLnRpY2suLW1lYXN1cmVhYmxlIHRleHQnKVxuICApLm1hcChlbCA9PiB7XG4gICAgY29uc3QgYmJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3Qgb2JqID0ge31cbiAgICBmb3IgKGxldCBrZXkgaW4gYmJveCkge1xuICAgICAgb2JqW2tleV0gPSBiYm94W2tleV1cbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9KVxuXG4gIGxldCBzbWFsbGVzdFRpY2tHYXAgPSAxMDAwMCAvLyBUaGlzIGlzIGp1c3QgYSByaWRpY3Vsb3VzbHkgbGFyZ2UgdGljayBzcGFjaW5nIHRoYXQgd291bGQgbmV2ZXIgaGFwcGVuIChob3BlZnVsbHkpXG4gIC8vIElmIHRoZSBheGlzIGlzIGhvcml6b250YWwsIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGFueSBuZWNlc3Nhcnkgcm90YXRpb24gYW5kIHRpY2sgc2tpcHBpbmdcbiAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgIGNvbnN0IHRpY2tEaW1zID0gQXJyYXkoXG4gICAgICAuLi50aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aWNrLi1tZWFzdXJlYWJsZScpXG4gICAgKS5tYXAoZWwgPT4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpXG4gICAgdGlja0RpbXMucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBjb25zdCBnYXAgPSBjdXJyZW50LmxlZnQgLSBwcmV2LmxlZnRcbiAgICAgICAgc21hbGxlc3RUaWNrR2FwID0gZ2FwIDwgc21hbGxlc3RUaWNrR2FwID8gZ2FwIDogc21hbGxlc3RUaWNrR2FwXG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudFxuICAgIH0sIGZhbHNlKVxuICAgIGNvbnN0IGxhcmdlc3RMYWJlbCA9IGxhYmVsRGltcy5yZWR1Y2UoXG4gICAgICAocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICBjdXJyZW50Ll9vdmVyZmxvdyA9IGN1cnJlbnQud2lkdGggLSBzbWFsbGVzdFRpY2tHYXBcbiAgICAgICAgaWYgKGN1cnJlbnQuX292ZXJmbG93ID4gMCAmJiBjdXJyZW50Ll9vdmVyZmxvdyA+IHByZXYuX292ZXJmbG93KSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldlxuICAgICAgfSxcbiAgICAgIHsgLi4ubGFiZWxEaW1zWzBdLCBfb3ZlcmZsb3c6IDAgfVxuICAgIClcblxuICAgIC8vIERldGVybWluZSBheGlzIHJvdGF0aW9uIGJlZm9yZSB3ZSBtZWFzdXJlXG4gICAgaWYgKGlzUm90YXRpb24pIHtcbiAgICAgIGxldCBuZXdSb3RhdGlvbiA9IE1hdGgubWluKFxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICBNYXRoLmFicyhcbiAgICAgICAgICAgIHJhZGlhbnNUb0RlZ3JlZXMoXG4gICAgICAgICAgICAgIE1hdGguYWNvcygoc21hbGxlc3RUaWNrR2FwICsgZm9udFNpemUgLyAyKSAvIGxhcmdlc3RMYWJlbC53aWR0aClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgICAgIDBcbiAgICAgICAgKSxcbiAgICAgICAgbWF4TGFiZWxSb3RhdGlvblxuICAgICAgKVxuXG4gICAgICBuZXdSb3RhdGlvbiA9IGlzTmFOKG5ld1JvdGF0aW9uKSA/IDAgOiBNYXRoLnJvdW5kKG5ld1JvdGF0aW9uKVxuICAgICAgaWYgKE1hdGguYWJzKHJvdGF0aW9uIC0gbmV3Um90YXRpb24pID4gMjApIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgcm90YXRpb246IGF4aXMucG9zaXRpb24gPT09ICd0b3AnID8gLW5ld1JvdGF0aW9uIDogbmV3Um90YXRpb24sXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdWaXNpYmxlTGFiZWxTdGVwID0gTWF0aC5jZWlsKGZvbnRTaXplIC8gc21hbGxlc3RUaWNrR2FwKVxuXG4gIGlmICh2aXNpYmxlTGFiZWxTdGVwICE9PSBuZXdWaXNpYmxlTGFiZWxTdGVwKSB7XG4gICAgdGhpcy52aXNpYmxlTGFiZWxTdGVwID0gbmV3VmlzaWJsZUxhYmVsU3RlcFxuICB9XG5cbiAgaWYgKCFsYWJlbERpbXMubGVuZ3RoIHx8IGxhYmVsRGltcy5sZW5ndGggIT09IHRoaXMudGlja3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBsZXQgd2lkdGggPSAwXG4gIGxldCBoZWlnaHQgPSAwXG4gIGxldCB0b3AgPSAwXG4gIGxldCBib3R0b20gPSAwXG4gIGxldCBsZWZ0ID0gMFxuICBsZXQgcmlnaHQgPSAwXG5cbiAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgIC8vIEFkZCB3aWR0aCBvdmVyZmxvdyBmcm9tIHRoZSBmaXJzdCBhbmQgbGFzdCB0aWNrc1xuICAgIGxlZnQgPSBNYXRoLmNlaWwoZ2V0UGl4ZWwobGFiZWxEaW1zWzBdLndpZHRoKSAvIDIpXG4gICAgcmlnaHQgPSBNYXRoLmNlaWwoZ2V0UGl4ZWwobGFiZWxEaW1zW2xhYmVsRGltcy5sZW5ndGggLSAxXS53aWR0aCkgLyAyKVxuICAgIGhlaWdodCA9XG4gICAgICBNYXRoLm1heCh0aWNrU2l6ZUlubmVyLCB0aWNrU2l6ZU91dGVyKSArIC8vIEFkZCB0aWNrIHNpemVcbiAgICAgIHRpY2tQYWRkaW5nICsgLy8gQWRkIHRpY2sgcGFkZGluZ1xuICAgICAgTWF0aC5tYXgoLi4ubGFiZWxEaW1zLm1hcChkID0+IE1hdGguY2VpbChnZXRQaXhlbChkLmhlaWdodCkpKSkgLy8gQWRkIHRoZSBoZWlnaHQgb2YgdGhlIGxhcmdlc3QgbGFiZWxcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGQgaGVpZ2h0IG92ZXJmbG93IGZyb20gdGhlIGZpcnN0IGFuZCBsYXN0IHRpY2tzXG4gICAgdG9wID0gTWF0aC5jZWlsKGdldFBpeGVsKGxhYmVsRGltc1swXS5oZWlnaHQpIC8gMilcbiAgICBib3R0b20gPSBNYXRoLmNlaWwoZ2V0UGl4ZWwobGFiZWxEaW1zW2xhYmVsRGltcy5sZW5ndGggLSAxXS5oZWlnaHQpIC8gMilcbiAgICB3aWR0aCA9XG4gICAgICBNYXRoLm1heCh0aWNrU2l6ZUlubmVyLCB0aWNrU2l6ZU91dGVyKSArIC8vIEFkZCB0aWNrIHNpemVcbiAgICAgIHRpY2tQYWRkaW5nICsgLy8gQWRkIHRpY2sgcGFkZGluZ1xuICAgICAgTWF0aC5tYXgoLi4ubGFiZWxEaW1zLm1hcChkID0+IE1hdGguY2VpbChnZXRQaXhlbChkLndpZHRoKSkpKSAvLyBBZGQgdGhlIHdpZHRoIG9mIHRoZSBsYXJnZXN0IGxhYmVsXG4gIH1cblxuICBkaXNwYXRjaChcbiAgICBzdGF0ZSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBheGlzRGltZW5zaW9uczoge1xuICAgICAgICAuLi5zdGF0ZS5heGlzRGltZW5zaW9ucyxcbiAgICAgICAgW3Bvc2l0aW9uXToge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgYm90dG9tLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcmlnaHQsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pLFxuICAgIHtcbiAgICAgIHR5cGU6ICdheGlzRGltZW5zaW9ucycsXG4gICAgfVxuICApXG5cbiAgcmV0dXJuIHRydWVcbn1cbiJdfQ==